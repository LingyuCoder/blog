layout: art
title: Peertc和五子棋
subtitle: 使用Peertc实现双人对战五子棋
tags: 
- Canvas
- WebRTC
- WebIM
- 游戏
- 算法
- JavaScript
categories: 
- 即时通信
date: 2014/11/18
---

今天发现博客的分类错乱了。自己写的主题对一篇文章有多个分类的情况处理效果不好，所以就把文章的分类重新弄了一下。然后看了看归档发现这个月还没写过东西，于是乎决定写这么一篇文章介绍一下Peertc，以及使用它实现一个对战的五子棋。下载地址：[Peertc](https://github.com/LingyuCoder/peertc)、[五子棋](https://github.com/LingyuCoder/FiveChess)

<!-- more -->

##缘起
之前我曾经写过好几篇关于WebRTC和DataChannel相关的文章。WebRTC是我毕业设计中非常重要的一部分，因此对它做了不少研究。虽然WebRTC的RTC是real-time communication，但它带来的好处并不只局限在即时通信领域。建立点对点通信并在浏览器之间直接传递数据，光这一点就可以提出非常多有趣的设想。有两个应用的点子我一直想做：
- FC红白机那种双人对战（协作）游戏，配合Canvas和WebGL，这也就是这次五子棋想法的来源。
- 在线协作编辑：《黑客与画家》中曾经提到过，说在线协作这种工具很有市场。另外除了文档，我们还可以基于Canvas做协作绘图。

五子棋就来源一第一个点子。至于第二个，做了一些调研，估计用[OT.js](https://github.com/Operational-Transformation/ot.js)，只能等有时间的时候去弄了。

FC那么多牛逼的游戏，我却只是做了一个五子棋。原因很简单，Canvas玩的不够熟练也没有素材。五子棋游戏和其他游戏不同的是，它不需要做循环画面刷新，非常适合Canvas上手。

##Peertc
[Peertc](https://github.com/LingyuCoder/peertc)是我在WebRTC DataChannel基础上实现的一个建立点对点通信，发送数据和文件的一个库。由于WebRTC在建立通信信道上还是无法脱离服务器，所以使用Node.js和[ws](https://www.npmjs.org/package/ws)在后台弄了个WebSocket服务器，同时WebSocket也是很好的退化方案。

至于Peertc具体如何建立点对点连接，我已经在文章[使用WebRTC DataChannel在浏览器间传递数据](http://lingyu.wang/2014/10/21/datachannel/)中通过老姚和老刘的故事介绍过了

如果图简单的话，只要知道Peertc就是一个在俩浏览器之间传输数据的库就可以了

##五子棋
我以前没写过五子棋，玩五子棋也玩的比较渣。乘着这个机会，仔细研究了一下五子棋的实现。

###实现
一个棋盘（多大随意，我玩过15*15的，但是也玩过可以无限扩展的）就是一个二维数组，黑白轮流往棋盘上放棋子，也就是往二维数组里赋值。每次放下棋子，判断一下在当前位置的横线、竖线、两条斜线上是否能成五个相连，也就是判断各个方向是否能成5个数字相同。

状态也只有4个：
1. 黑色落子
2. 白色落子
3. 黑色获胜
4. 白色获胜

状态转移：
- 初始状态为黑色落子
- 黑色落子后judge判断是否获胜，若获胜转黑色获胜，否则转白色落子
- 白色落子后judge判断是否获胜，若获胜转白色获胜，否则转黑色落子

所以，五子棋的核心就是一个judge方法来判断是否连成5子，实现很简单

###AI
为什么要写AI？本来只是想实现双人对战的，那就不要AI了，但是觉着如果只能双人对战未免太过无趣，所以就调研了一下五子棋的AI算法。发现它和计算网页内容的readablity一样，通过计算下在各个位置所获得的分值，得分最高的即是最优解。这里需要注意几个地方：

1. 这是一个对战游戏，自己要下子获胜，也要堵别人子防止别人获胜。因此计算权重时两种情况都要考虑
2. 下过五子棋的都知道，如果成了一列（无论方向），两头都没有被堵子肯定要比被堵了一头要强，因此这个是否被堵也要加到考虑当中
3. 连着的越多，越靠近胜利
4. 放在棋盘较为中间的位置比较好（如果棋盘是固定大小的话）

##双人对战
既然涉及到双人互动的话，就会涉及到协议了。就算是一个简单的五子棋对战也有协议，这里直接用json好了。由于Peertc帮我们实现了链接和数据传输，A下的子的位置直接传给B就行了。

这里与AI不同的一个地方就是，AI反应快的一笔，不是玩家下子的时候，不做屏蔽也没太大关系。但是玩家需要思考，网络有延迟，所以在上面的黑色落子和白色落子阶段都需要加上对应的屏蔽，保证不会出现该白色落子，黑色依然能下的情况。

那么，需要哪些信令呢？

###开一局
开局，这个开局由一方先行发起，发起的一方将自己所持的颜色保存，并将对方应持的颜色和开局指令交给对方，至于颜色怎么来，可以随机或者固定：

```javascript
selfColor = 'black';
connector.send({
    type: 'new',
    data: {
        color: 'white'
    }
});
```

###落子
开局之后，双方都将开始游戏，各自会有自己的游戏数据和状态机。他们的状态应当完全同步。其实可以把对方想象成一个有延迟的AI。落子的关键就在于位置和颜色，位置一般不会有太大问题，而颜色如果错误麻烦就大了
```javascript
connector.send({
    type: 'drop',
    data: {
        color: fiveChess.state,
        x: x,
        y: y
    }
});
```
这里使用的是五子棋内部的状态表明的颜色，而不是使用当前持有的颜色，就是为了防止状态机不同步导致错误。

###结束
双方在自己或对方落子后可以自行计算是否获胜游戏结束。真正需要传输的游戏结束的信令应当表征有一方认输。

```javascript
connector.send({
    type: 'end'
});
```

通过这三个信令，一个对战的五子棋就完成了

##结语
五子棋属于逻辑比较简单的游戏，因此实现起来很好理解，难度不大。写一个这种基于网络对战游戏，设计好自动机、设计好相互交互的信令是非常重要的。

希望以后Canvas学好了，能够写出像《魂斗罗》，《雪人兄弟》，《拳皇》这样的游戏。