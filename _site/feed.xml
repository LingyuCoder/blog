<?xml version="1.0" encoding="utf-8" ?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" version="2.0">
    <channel>
        <title>天镶的博客 SkyInlayer`s Blog</title>
        <atom:link href="http://skyinlayer.com/rss.xml" rel="self" type="application/rss+xml"/>
        <link>http://skyinlayer.com/</link>
        <description>天镶SkyInlayer的个人博客</description>
        <language>zh-CN</language>
        
            <item>
                <title><![CDATA[ Good Good Study, Day Day Upward！ ]]></title>
                <link>http://skyinlayer.com/blog/2014/04/06/play-fish</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 06 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>上周过得特别累，好不容易有个三天假期闲暇下来了。没有了看书和总结之前题目的欲望，于是乎就跑去逛<a href="http://codepen.io/">codepen</a>。看着国外各种大牛在上面发布的效果，就想自己也写一些类似的小效果玩一玩。搭好了grunt环境（autoprefixer+watch），两天的摸鱼旅程就这样开始了</p>

<h3 id="">第一条鱼</h3>

<p>之前做阿里的在线笔试的时候有遇到让写一个下拉菜单。之前就有考虑有没有方法不使用js去写（世界上没有叫IE的浏览器）。尝试着用纯CSS写了一个，加了些简单的动画效果，丢到codepen上去了</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://cdpn.io/hDbrd' style='width: 100%; height: 600px'>&nbsp;</iframe>
<h3 id="_2">第二条鱼</h3>

<p>摸完第一条鱼，感觉不够尽兴。于是开始考虑摸第二条，但不知道弄点什么。正好逛codepen有个人实现了一个圆形confirm框，就决定自己实现一个。实现完成之后，加了些动画，于是就有了下面这个</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://cdpn.io/mvdcH' style='width: 100%; height: 600px'>&nbsp;</iframe>
<h3 id="_3">第三条鱼</h3>

<p>显然前面两个小玩意还是不能满足我摸鱼的欲望。看到codepen上有个人画了个脸，于是就决定自己画一个更复杂一点的。颜色都是用的别人的配色，不过自己加上了头发的实现以及眼睛和嘴巴的动画。弄出了这么一个快乐的小逗逼</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://cdpn.io/ktcFB' style='width: 100%; height: 800px'>&nbsp;</iframe>
<h3 id="_4">第四条鱼</h3>

<p>今天起床也是啥也不想干，于是就考虑摸第四条鱼。看到网上的自行车照片，觉得画一个简单的卡通自行车也不算难，就开始动手画自行车了。这样就有了最后一条鱼：一个破烂自行车。摸鱼之旅也就告一段落了</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' src='http://cdpn.io/EDwsf' style='width: 100%; height: 500px'>&nbsp;</iframe>
<h3 id="_5">总结</h3>

<p>摸完鱼心情舒畅，该回归正轨了，之前说的总结阿里在线笔试题的工作还没做完呢。等有看到一些其他的我能力范围之内的动画效果时，再继续摸鱼吧</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/04/06/play-fish</guid>
            </item>
        
            <item>
                <title><![CDATA[ 阿里巴巴前端笔试题（1-10） ]]></title>
                <link>http://skyinlayer.com/blog/2014/04/04/alibaba-fe-1</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 04 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">第一题</h2>

<h3 id="_2">题面</h3>

<p>说出以下函数的作用是？空白区域应该填写什么？</p>

<pre class="javascript"><code class="javascript">// define  
(function (window) {  
    function fn(str) {  
        this.str = str;  
    }  
    fn.prototype.format = function () {  
        var arg = ______;  
        return this.str.replace(_______, function (a, b) {  
            return arg[b] || &#39;&#39;;  
        });  
    }  
    window.fn = fn;  
})(window);  
// use  
(function(){  
    var t = new fn(&#39;&lt;p&gt;&lt;a href=&quot;{0}&quot;&gt;{1}&lt;/a&gt;&lt;span&gt;{2}&lt;/span&gt;&lt;/p&gt;&#39;);
    console.log( t.format(&#39;http://www.alibaba.com&#39;, &#39;Alibaba&#39;, &#39;Welcome&#39;) );  
})();  </code></pre>

<h3 id="_3">解答</h3>

<p>看题面就是，类似于写一个模板引擎。将模板里的<code>{1}</code>之类的占位符替换成传给它的参数。所以arg应该就是arguments。但是由于arg不是数组，而是一个类数组对象。所以需要进行一些转换，比较常规的转换方式如下：</p>

<pre class="javascript"><code class="javascript">var arg = Array.prototype.slice.call(arguments, 0);</code></pre>

<p>等号右边也就是第一空的答案了</p>

<p>第二空则是要通过正则找出占位符，并根据占位符内的数字将其替换成arg数组内的字符串，说实话replace方法的第二个参数为函数的情况很少遇到，这里就是考的这个，最初想法是直接用全局正则匹配一下：</p>

<pre class="javascript"><code class="javascript">return this.str.replace(/\{\d+\}/g, function (a, b) {  
    return arg[b] || &#39;&#39;;  
}); </code></pre>

<p>这样，但是穿进去之后发现不太对，因为b参数是正则匹配到的字符串在完整字符串中的位置。于是去查了一下W3C：</p>

<blockquote>
<p>该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。</p>
</blockquote>

<p>这里显然是因为没有子表达式，所以直接b成了声明的匹配在stringObject中出现的位置。这样就好说了，与模式中字表达式匹配，那加一个子表达式进去，变成这样：</p>

<pre class="javascript"><code class="javascript">return this.str.replace(/\{(\d+)\}/g, function (a, b) {  
    return arg[b] || &#39;&#39;;  
}); </code></pre>

<p>跑一下，齐活，输出<code>&lt;p&gt;&lt;a href=&quot;http://www.alibaba.com&quot;&gt;Alibaba&lt;/a&gt;&lt;span&gt;Welcome&lt;/span&gt;&lt;/p&gt; </code></p>

<h2 id="_4">第二题</h2>

<h3 id="_5">题面</h3>

<p><img src="http://skyinlayer.com/images/fe_interview/9.png" alt="第二题题面" /></p>

<h3 id="_6">解答</h3>

<p>这题由于时间不太够，就没有写可执行代码，主要是涉及cookie操作。可以分成用户第一次进入检测，用户点击我知道了检测两个行为来分别处理：</p>

<p>第一次进入的时候，首先判断cookie中是否有今天已来过标记，没有记录就写进一个标记，同时由于同一天不显示，所以这个写入带标记的cookie的过期时间应该为1天，这里标记为visited：</p>

<pre class="javascript"><code class="javascript">if(document.cookie.indexOf(visited) === -1){
    document.cookie = &#39;visited=&#39; + escape(&#39;1&#39;) + &#39;;expires=&#39; + new Date((new Date().getTime() + 24 * 3600 * 1000)).toGMTString();
    showTips();
}</code></pre>

<p>点不再访问的时候，应该运行如下代码：</p>

<pre class="javascript"><code class="javascript">document.cookie = &#39;visited=&#39; + escape(&#39;1&#39;) + &#39;;expires=&#39; + new Date((new Date().getTime() +  100 * 365 * 24 * 3600 * 1000)).toGMTString();</code></pre>

<p>这样设定一个100年才过期的cookie，就相当于永久不显示了</p>

<h2 id="_7">第三题</h2>

<h3 id="_8">题面</h3>

<p><img src="http://skyinlayer.com/images/fe_interview/10.png" alt="第3题题面" /></p>

<h3 id="_9">解答</h3>

<p>在ul的li上绑点击事件，典型的事件代理的题，要输出index，所以需要提前进行一些提前处理：</p>

<pre class="javascript"><code class="javascript">(function(){
    var nav = document.getElementById(&quot;nav&quot;);
    var liList = nav.children;

    function bindEvent(ele, event, callback) {
        if (ele.attachEvent) {
            ele.attachEvent(&quot;on&quot; + event, function(event) {
                event = event || window.event;
                event.target = event.target || event.srcElement;
                callback(event);
            });
        } else {
            ele.addEventListener(event, callback, false);
        }
    };

    bindEvent(nav, &quot;click&quot;, function(event) {
        var target = event.target;
        var a;
        var i, m;
        if (target.tagName.toLowerCase() === &quot;li&quot;) {
            a = target.children[0];
            for (i = 0, m = liList.length; i &lt; m; i++) {
                if (liList[i] === event.target) {
                    console.log(i + 1);
                    console.log(a.getAttribute(&quot;href&quot;));
                    console.log(a.innerText);
                }
            }
        }
    });
}());</code></pre>

<p>这个事件代理的思想就是，在ul上采用冒泡机制绑定点击事件，在回调函数中使用event.target(IE底下会说)判断是否是li节点，如果是，则输出需要的数字</p>

<p>这里说要支持（该死的）IE，于是多了好几个点：</p>

<ul>
<li>IE的事件绑定需要用attachEvent，而不能直接用addEventListener，所以需要额外处理</li>

<li>老版本的event不是又函数传入，而是写在window里面，所以也需要做一个兼容</li>

<li>老版本的IE中，并没有event.target，所以取而代之的是event.srcElement</li>

<li>IE6、7、8使用数组的slice方法会报错，同时也无法使用indexOf，所以要么把这两个方法重新实现，要么直接通过遍历的方式来处理，我这里直接采用遍历的方式（因为重新实现代码加长很多）</li>

<li>去死吧IE</li>
</ul>

<h2 id="_10">第四题</h2>

<h3 id="_11">题面</h3>

<p><img src="http://skyinlayer.com/images/fe_interview/11.png" alt="第4题题面" /></p>

<h3 id="_12">解答</h3>

<p>妈蛋被坑了，没看到还要写出其框内内容，写了个绝对定位就交了，呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵</p>

<p>及其简单的绝对定位题，里面的内容分成两块，一块是左边的二维码，一块是右边的文字部分。左边浮动，右边触发bfc</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/27hGA/1/embedded/result,html,css' width='100%'>&nbsp;</iframe>
<h2 id="_13">第五题</h2>

<h3 id="_14">题面</h3>

<p><img src="http://skyinlayer.com/images/fe_interview/12.png" alt="第5题题面" /></p>

<h3 id="_15">解答</h3>

<p>这题是作文…完全答不全，这里的答案不一定对，都是网上摘抄的</p>

<p>可以分成两个部分进行阐述： 1. http连接建立 2.对网页及其资源进行请求</p>

<p>http建立经过如下步骤：</p>

<ol>
<li>浏览器获得url后，对其通过DNS进行解析，转换成ip地址，以及添加上响应的端口（如果没有显式指定，默认80）</li>

<li>浏览器通过三步握手与这个服务器建立TCP连接</li>

<li>在连接建立后，发送一个HTTP请求报文，里面包含了请求的资源的URL，请求方法，参数等等信息</li>

<li>服务器接收到请求报文后进行处理，返回一个包含请求资源内容的响应报文</li>

<li>浏览器关闭这个TCP连接（在HTTP1.1中不会进行关闭，除非进行显式的connection=close，而HTTP1.0中，则会关闭，可以通过keepAlive指定不关闭）</li>
</ol>

<p>对网页的资源请求：</p>

<ol>
<li>浏览器的url框获得url后，通过上述的方式获得HTML文档，获得完成后触发document.onload事件</li>

<li>解析HTML文档，然后按照HTML文档结构从上往下开始请求资源（批量4-8）</li>

<li>请求CSS样式表，当样式表到来的时候，将会拿它和之前已经到来的样式表进行合并和解析，修改渲染树，对页面进行回流和重绘</li>

<li><code>&lt;scirpt&gt;</code>所添加的脚本在执行完成之前，会阻塞后续的HTML进行解析。而如果通过src添加外链的方式来引入js脚本，那么在请求、下载、解析、运行所有过程完成之前，都不会进行后续HTML的解析</li>

<li>如果通过javascript添加script标签的方式加载，将会异步进行加载</li>
</ol>

<h2 id="_16">第六题</h2>

<h3 id="_17">题面</h3>

<p><img src="http://skyinlayer.com/images/fe_interview/13.png" alt="第6题题面" /></p>

<h3 id="_18">解答</h3>

<p>这题本来不难，一个下拉框，可以只用html+css实现，活用一下css的伪类就行了，至于那个小箭头用after伪元素画一下问题不大，代码如下，测试了一下能到IE7：</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/ZQ5Jd/1/embedded/result,css,html' width='100%'>&nbsp;</iframe>
<p>但是底下的要求，直接让我吐血，支持IE6+…就这一句话得加多少乱七八糟的兼容….IE6不支持子元素选择器，去掉之。IE6没hover，去掉之。另外小箭头肯定不能用border画了，懒得弄图片了，补上js代码。结果如下：</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/ZQ5Jd/4/embedded/result,css,html' width='100%'>&nbsp;</iframe>
<h2 id="_19">第七题</h2>

<h3 id="_20">题面</h3>

<p><img src="http://skyinlayer.com/images/fe_interview/14.png" alt="第7题题面" /></p>

<h3 id="_21">解答</h3>

<p>表单序列化，获取表单中的元素然后获取他们的值，拼接成字符串，挺有意思的一道题</p>

<p>通过form.elements可以获得所有的元素，顺序遍历一遍就好，需要注意的是checkbox和radio的checked状态，另外除了input以外，还有select和textarea（这里可能考虑不全）</p>

<pre class="javascript"><code class="javascript">function serialize(form) {
    var params = [];
    var elements = form.elements;
    var i, m;
    var input;
    for (i = 0, m = elements.length; i &lt; m; i++) {
        input = elements[i];
        if (input.tagName.toLowerCase() === &quot;input&quot;) {
            switch (input.type) {
                case &quot;radio&quot;:
                case &quot;checkbox&quot;:
                    if (!input.checked) {
                        break;
                    }
                default:
                    if (input.disabled == false &amp;&amp; input.name.length) {
                        params.push(encodeURI(input.name) + &quot;=&quot; + encodeURI(input.value));
                    }
            }
        } else if (input.tagName.toLowerCase() === &quot;textarea&quot; || input.tagName.toLowerCase() === &quot;select&quot;) {
            if (input.disabled == false &amp;&amp; input.name.length) {
                params.push(encodeURI(input.name) + &quot;=&quot; + encodeURI(input.value));
            }
        }
    }
    return params.join(&quot;&amp;&quot;);
};</code></pre>

<h2 id="_22">第八题</h2>

<h3 id="_23">题面</h3>

<p><img src="http://skyinlayer.com/images/fe_interview/15.png" alt="第8题题面" /></p>

<h3 id="_24">解答</h3>

<p>数组去重…这还只是扁平数组，不难，去哪儿那题是嵌套数组。不过它竟然要自己构造数组。去重的话直接用一个Object做标记就行。也可以考虑直接用indexOf判断，不过效率会降低</p>

<pre class="javascript"><code class="javascript">var array = [];
var i;

function getRandomNumberString() {
    return Math.floor(Math.random() * 100) + &#39;&#39;;
};

for (i = 0; i &lt; 100; i++) {
    array.push(getRandomNumberString());
}

function unique(array) {
    var result = [];
    var uniObj = {};
    var i, tmp;
    for (i = array.length; i--;) {
        tmp = parseInt(array[i]);
        if (!uniObj[tmp]) {
            result.push(tmp);
            uniObj[tmp] = 1;
        }
    }
    return result;
}

console.log(unique(array));</code></pre>

<h2 id="_25">第九题</h2>

<h3 id="_26">题面</h3>

<p><img src="http://skyinlayer.com/images/fe_interview/16.png" alt="第9题题面" /></p>

<h3 id="_27">解答</h3>

<p>竟然会有这种题，好吧</p>

<p>第一个地方是浏览器嗅探。这里使用了无关属性<code>document.all</code>来嗅探IE，这样并不好。应该直接使用方法来嗅探，所以将其改为<code>window.attachEvent</code></p>

<p>第二个地方是事件对象未处理，我也是后来才知道的，自己只写了第一条就交了。这里由于老式IE对event和event.target不支持，所以需要进行兼容</p>

<p>第三个地方，记得提升变量申明</p>

<p>总体修改代码如下：</p>

<pre class="javascript"><code class="javascript">var addListener;
if (window.addEventListener) {
    addListener = function(el, type, listener, useCapture) {
        el.addEventListener(type, listener, useCapture);
    };
} else if (window.attachEvent) {
    addListener = function(el, type, listener) {
        el.attachEvent(&quot;on&quot; + type, function(event) {
            event = event || window.event;
            event.target = event.target || event.srcElement;
            listener.apply(el, [event]);
        });
    };
}</code></pre>

<h2 id="_28">第十题</h2>

<h3 id="_29">题面</h3>

<p><img src="http://skyinlayer.com/images/fe_interview/17.png" alt="第10题题面" /></p>

<h3 id="_30">解答</h3>

<p>呵呵，还能不能愉快的答题了<code>(╯‵□′)╯︵┻━┻</code></p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/04/04/alibaba-fe-1</guid>
            </item>
        
            <item>
                <title><![CDATA[ CSS布局相关基础知识 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/31/css-layout</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 31 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="containing_block">包含块（containing block）的定义</h2>

<p>元素盒子的位置和大小通常需要通过一个确定的矩形来计算，这个矩形就是包含块，其定义如下：</p>

<ol>
<li>根元素的包含块是一个被称为原始包含块（initial containing block）的矩形。它由视口确定，对于分页媒体来说就是页区域。它的direction属性时和根元素的一样</li>

<li>对于其他元素，如果元素的position是relative或static，包含块由其最近的块级祖先的内边距（content edge）来确定</li>

<li>如果元素时position:fixed，那么包含块就是连续媒体的视口或是分页媒体的页区域</li>

<li>如果元素的position属性时absolute，包含那块将根据最近的position属性为非static的祖先元素来确定，有如下规则
<ul>
<li>当那个祖先元素是一个内联元素时，包含块需要根据祖先元素的direction属性来确定
<ul>
<li>如果direction是ltr，那么包含块的左上顶点将是祖先元素的第一个盒子的左上顶点，而包含块的右下顶点将是祖先元素最后一个盒子的右下顶点</li>

<li>如果direction是rtl，那么包含块的右上顶点将是祖先元素的第一个盒子的右上顶点，而包含块的左下顶点将是祖先元素最后一个盒子的左下顶点</li>
</ul>
</li>

<li>如果祖先元素是块状元素，那么它的包含块将是这个祖先元素的padding edge</li>

<li>如果没有这么一个祖先元素，则包含块就是原始包含块</li>
</ul>
</li>
</ol>

<p>分页媒体中，绝对定位元素会被定位在其自己的包含块中，而无视任何分页（就好像整个文档是连续的）。这可能导致元素被分开到多页中</p>

<h2 id="">浮动</h2>

<p>一个浮动的盒子首先会根据文档流定位，然后尽可能的往左移或者往右移，直到它的外边界（margin边界）碰到了包含块边界或其他浮动元素的外边界。如果在一个line box中，浮动盒子的顶部外边界将与当前的line box的顶部对齐</p>

<p>如果水平方向上没有足够的空间以容纳浮动元素，它将向下移动，直到它能被容纳或没有更多的浮动元素（If there is not enough horizontal room for the float, it is shifted downward until either it fits or there are no more floats present.不知如何翻译）</p>

<p>由于浮动元素不在文档流内，其前后的未定位的元素将当做它不存在（脱离文档流）。但是，当前的line box和其后面被浮动元素缩短的line box将会为这个浮动的元素创建空间</p>

<p>一个line box在垂直位置满足如下四个条件时，被定义为紧邻着浮动元素，line box会被缩短：</p>

<ol>
<li>在linx box的顶部边界位置或其下方</li>

<li>在line box的底部边界位置或其上方</li>

<li>在浮动元素的上margin边界之下</li>

<li>在浮动元素的下margin边界之上</li>
</ol>

<p>如果一个被缩短的line box太小而不足以容纳任何内容，那么这个line box将会被向下移动（它的宽度也将重新计算），直到某些内容能够展现或不再被浮动影响。任何与浮动元素在一行的元素将会在浮动元素的另外一边重新排列。也就是说，如果内联盒子被放置在一个float：left元素的左边，那么它将移动到float元素的右边。而rtl模式和float:right则相反</p>

<p>一个触发了BFC的元素不能与同一BFC下的任何浮动元素重叠。如果有必要，这些元素可以被实现为清除浮动，但如果有足够的空间，可以被放置在浮动元素之后。他们甚至能被浮动元素挤压变得更窄</p>

<p>浮动元素的margin不会和相邻盒子的margin重叠。一个浮动元素能与正常流中的其他元素重叠。当这种情况发生时，浮动元素将被渲染在未定位的文档流内的块状元素之前，文档流的内联元素之后</p>

<p>clear清除浮动，意思是确定当前元素不能与哪个方向的浮动元素相邻。触发了BFC的元素和浮动元素本身的clear属性将无效</p>

<p>另外使用clear清除浮动或由于被挤压而到下面时，设置margin-top是无效的，需要先使用一个div清除浮动，或是在上面一个元素设定margin-bottom</p>

<p><img src="http://skyinlayer.com/images/layout/1.png" alt="清除浮动元素margin-top无效的解释1" /></p>

<p><img src="http://skyinlayer.com/images/layout/2.png" alt="清除浮动元素margin-top无效的解释2" /></p>

<p><img src="http://skyinlayer.com/images/layout/3.png" alt="清除浮动元素margin-top无效的解释3" /></p>

<h2 id="_2">定位</h2>

<p>CSS中一个盒子的定位可以通过如下三种定位模式：</p>

<ol>
<li>文档流：文档流包括块级元素的块级格式和内联元素的内联格式，以及relative和sticky定位</li>

<li>浮动：浮动模式下，一个盒子起初定位在文档流中，然后被从文档流中拿出向左或向右移动。内容会包围在浮动元素的边上</li>

<li>绝对定位：在绝对定位模式下，一个盒子会从文档流中完全脱离，并根据定位所属的包含块进行定位</li>
</ol>

<p>当一个元素时浮动的，或者绝对定位或者是根元素，那么就称它脱离文档流。一个元素没脱离文档流的话就被称为流内元素（in-flow）</p>

<h2 id="relative_positioning">相对定位（relative positioning）</h2>

<p>当一个盒子通过文档流或浮动定位，那么它能通过position:relative设定一个相对的偏移。这就是相对定位。为一个相对定位的盒子设定偏移不会影响到其他盒子。这也意味着相对定位的盒子会和其他盒子重叠。然而，当一个父元素设定了overflow的值为auto和scroll，而其中的子元素设定了相对偏移而溢出父元素，那么父元素应当扩张滚动条，让用户能通过滚动条看到设定相对偏移的子元素的内容。</p>

<p>一个相对定位的盒子保持它在文档流之中的大小，包括它的换行以及原本为它保留的空间</p>

<p>一个相对定位的盒子建立一个新的包含块，这个可以为其内部的绝对定位元素创建一个包含块</p>

<p>使用left和right属性能够水平方向移动盒子，而不用改变其大小。left将盒子右移，而right将盒子左移。left = -right</p>

<ul>
<li>如果left和right都是auto，那么他们的值都是0</li>

<li>如果left是auto，将使用-right值</li>

<li>如果rifht是auto，将使用-left值</li>

<li>如果都不是auto，就会形成一个过渡约束，那么就有一个值必须被忽略。如果direction属性为ltr，left将优先于left被使用。如果direction是rtl，那么right将优先</li>
</ul>

<p>top和bottom属性上下移动盒子而不改变其大小。top将盒子向下移，而bottom将盒子向上移。top=-bottom</p>

<ul>
<li>如果都是auto，那么值都是0</li>

<li>如果有一个是auto，那么它的值将是另外一个的负数</li>

<li>如果都不是auto，那么bottom将被忽略</li>
</ul>

<h2 id="_3">绝对定位</h2>

<p>在绝对定位模型中，一个盒子根据它所在的包含块（containing block）计算偏移。绝对定位的元素将完全从文档流中脱离而不会影响到其他元素。同时它自身也会为其内部的绝对定位元素（absolute）子孙元素和文档流元素建立一个包含块。但是一个绝对定位元素的内容不会受其他盒子的影响。他们会根据盒子所具有的的堆叠等级（z-index）来掩盖其他盒子（或者被其他盒子所掩盖）</p>

<h3 id="absolute">非替换元素的绝对定位（absolute，</h3>

<p>page，fixed）宽度计算 对所有能使用的影响宽度的值有如下限制：</p>

<blockquote>
<p>‘left’ + ‘margin-left’ + ‘border-left-width’ + ‘padding-left’ + width + ‘padding-right’ + ‘border-right-width’ + ‘margin-right’ + ‘right’ = 包含块的宽度</p>
</blockquote>

<p>如果left、width和right都是auto，那么将把margin-left和margin-right中值为auto的替换成0。如果建立包含块属性的direction属性为ltr，那么设定left属性为静态定位时的值，然后根据下面的3号规则来确定。如果direction属性为rtl，那么设定right属性为静态定位时的值，然后根据下面的1号规则来确定。</p>

<p>如果left、width和right都不是auto：如果margin-left和margin-right为auto，会根据如下规则解析整个等式计算出两个margin的值，margin-left和margin-right的值相等。如果他们都是负数，当包含块的direction为ltr时，设定margin-left为0，然后计算margin-right，若包含块的direction为rtl时，设定margin-right为0，然后计算margin-left。如果margin-left和margin-right只有一个是auto，那么可以根据等式计算出为auto的margin的值。如果值被过度约束，在direction为ltr时忽略right值，在为rtl时忽略left值。</p>

<p>否则，将margin-left和margin-right中为auto的值替换成0，并选则如下6条中的一条执行：</p>

<ol>
<li>如果left和width都是auto，而right不是auto，那么width将会扩展尽可能收缩，然后计算left值</li>

<li>如果left和right为auto，而width不是auto，那么如果创建包含块的元素direction属性为ltr，设定left为静态定位时的值然后计算出right，如果direction属性为rtl，设定right为静态定位时的值然后计算出left。</li>

<li>如果width和right都是auto，而left不是auto，那么width会背尽可能收缩，然后计算出right</li>

<li>如果left是auto，width和right都不是auto，直接算出left</li>

<li>如果width是auto，left和right都说不是auto，直接算出width</li>

<li>如果right是auto，width和left都不是auto，直接算出right</li>
</ol>

<h3 id="absolute_2">非替换元素的绝对定位（absolute，</h3>

<p>page，fixed）高度计算 对所有能够使用的影响高度的值有如下限制：</p>

<blockquote>
<p>‘top’ + ‘margin-top’ + ‘border-top-width’ + ‘padding-top’ + ‘height’ + ‘padding-bottom’ + ‘border-bottom-width’ + ‘margin-bottom’ + ‘bottom’ = 包含块的高度</p>
</blockquote>

<p>如果top、height、bottom都是auto，首先将margin-top和margin-bottom中为auto的替换为0，然后设定top为静态定位中的值，然后使用下面的3号规定来确定</p>

<p>如果top、height、bottom都不是auto，如果margin-top和margin-bottom都是auto，那么根据等式计算出margin-top和margin-bottom的值，他们俩相等。如果margin-top和margin-bottom只有一个是auto，解析等式直接算出为auto的值即可。如果出现了过度限制，那么忽略bottom的值，然后计算得到bottom值</p>

<p>否则，替换margin-top和margin-bottom中的auto为0，按照下面的规则计算：</p>

<ol>
<li>如果top、height都是auto，而bottom不是auto，高度将根据元素内部高度计算得出（<a href="http://dev.w3.org/csswg/css-position/#root-height">计算规则在这里</a>），然后算出top</li>

<li>如果top、bottom都是auto，而height不是auto，那么设定top为静态定位时的初始值，然后计算出bottom</li>

<li>如果height和bottom都是auto，而top不是auto，高度将根据元素内部高度计算得出（<a href="http://dev.w3.org/csswg/css-position/#root-height">计算规则在这里</a>），然后算出top</li>

<li>如果top是auto，而height和bottom不是auto，那么直接算出top</li>

<li>如果height是auto，top和bottom不是auto，那么直接算出height</li>

<li>如果bottom是auto，top和height不是auto，那么直接算出bottom</li>
</ol>

<h2 id="normal_flow">Normal flow（文档流）</h2>

<p>在文档流中的盒子属于一个格式上下文，可以是BFC（块级格式上下文）或是IFC（内联格式上下文）。</p>

<h3 id="bfcblock_formatting_context">BFC（Block formatting context）</h3>

<p>浮动元素，绝对定位元素，一些块容器元素（display为inline-block，table-celss，table-captions等），或设定了overflow不为visible的元素都会创建BFC</p>

<p>BFC中，盒子将被垂直的一个接一个的从父元素的包含块（containing block）的顶部向下排列。盒子之间的垂直距离由盒子的垂直margin来确定。而相邻的块级元素元元素的margin会发生重叠（collapse）</p>

<p>BFC中，每个盒子的做外边界（左margin边界）触碰到父元素的包含块的左边界（如果是从右往左，则反过来）。就算表现浮动时也是一样，除非盒子建立一个新的BFC。</p>

<h3 id="ifcinline_formatting_context">IFC（Inline formatting context）</h3>

<p>在IFC中，盒子一个接一个的在父元素的包含块中水平布局。水平margin、border、padding将会影响布局，而纵向的则不会。盒子在纵向布局上采用了完全不同的方式：他们的底部或顶部可以相互对齐，或他们内部的文本可以以一个基准线进行对齐。这个包含了一行的多个盒子的矩形区域成为一个行盒子（line box）。</p>

<p>line box的宽度足以包含其内部所有元素。而它的高度则可能比它所包含的最高的盒子还要高。如果一个盒子高度不足以达到line box的高度，我们就可以使用vertical-align来确定它的位置。当很多内联盒子无法被一个line box水平包裹时，它们将分布在两个或者多个垂直堆叠的line box中。这样一个段落实际上就被分成了很多垂直方向分布的line box了。line box在垂直方向上没有间隔，也不会重叠</p>

<p>一般情况下，一个line box的宽度与父元素包含块的宽度相同，line box会顶在父元素包含块的左边界和右边界。一般情况下，在同一个内联格式上下文中，所有的line box的宽度是一样的。但如果出现了浮动的话，水平宽度也会由于浮动而变化。在同一个内联格式上下文中的line box的高度经常很多样，其根据line box内部包含的子元素来确定的（如果都是文字的话没什么区别，但是又是偶会包含一些图片）</p>

<p>当一个内联盒子超出了line box的宽度，那么它被分割到多个盒子中，而这些盒子将被分配到多个line box中。如果一个内敛盒子不能被分割，那么这个内联盒子将溢出其所在的line box</p>

<p>当一个内联盒子被拆分，margin、border、padding在分割的地方不会有视觉效果</p>

<p>内联盒子也可以由于unicode-bidi和direction的设定被拆分到多个统一line box中。</p>

<p>line box的创建是根据需要的内容大小来的。line box不包含文字，也没有留白，没有margin、padding、border，并且不以一个保留的0高度的（被当做不存在）line box而结束</p>

<p>line box的高度有如下计算方式：</p>

<ol>
<li>计算出line box内部的每个内联盒子的高度。对于替换元素、inline-block元素和inline-table元素，他们的高度是整个margin box的高度。而对于内联盒子，值是他们的line-height属性。</li>

<li>内联盒子在垂直方向上根据他们的vertival-align属性来分布。当值为top或bottom时，他们必须以最小化line box高度的方式排布。如果那个盒子足够高，就会撑开line box</li>

<li>line box的height属性是最上面盒子的顶端到最下面盒子的底端的值</li>
</ol>

<p>空的inline元素元素会生成空的内联盒子。但这些盒子一样有自己的margin、padding、border以及一个line heihgt，一样会影响行盒的计算</p>

<h2 id="displaypositionfloat">display，position和float相互关系</h2>

<p>这桑格元素都会影响盒子的生成和布局，他们有如下相互影响的规则：</p>

<ol>
<li>如果display是none，那么position和float不会起作用。这个元素压根就不会生成盒子</li>

<li>如果display不是none，如果position的值为absolute，page或者fixed，而float值为left或right，那么盒子会绝对定位同时float值将被设为none。display属性将根据下面这张表来确定。由于使用了绝对定位，盒子的位置由其top、right、botton、left属性和盒子所属的包含块确定</li>

<li>否则，如果float不是none。那么盒子将是浮动定位，而且display属性将按照如下表格确定</li>

<li>否则，如果盒子是根元素，display属性将按照如下表格确定</li>

<li>否则，将运用display属性</li>
</ol>

<p><img src="http://skyinlayer.com/images/layout/4.png" alt="display属性转换表" /></p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/31/css-layout</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript隐式类型转换 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/30/js-type-convert</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 30 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">对象转原始值</h2>

<h3 id="_2">对象转布尔</h3>

<p>对象转Boolean很简单，所有对象都是true</p>

<p>举个栗子：</p>

<pre class="javascript"><code class="javascript">&gt; !!new Boolean(false)
true

&gt; if(new Boolean(false)){
    console.log(true);
  } else {
    console.log(false);
  }
true</code></pre>

<h3 id="_3">对象转字符串</h3>

<p>对象转字符串经过如下步骤：</p>

<ul>
<li>如果对象有toString()方法，则调用toString()。如果toString()返回一个原始值，那么将这个值转为字符串（如果它不是字符串的话），并返回</li>

<li>如果对象没有toString()方法，或者调用toString()方法返回的不是一个原始值，那么调用valueOf()方法。 如果valueOf()方法返回的是原始值，那么将它转换为字符串，并返回</li>

<li>如果无法从toString()或valueOf()获得一个原始值，那么将抛出一个类型错误异常</li>
</ul>

<p>来个栗子：</p>

<pre class="javascript"><code class="javascript">function Obj(){}
Obj.prototype.toString = function(){return &quot;callToString&quot;}
Obj.prototype.valueOf = function(){return &quot;callValueOf&quot;}
var data = {
    &quot;callToString&quot; : &quot;callToString&quot;,
    &quot;callValueOf&quot; : &quot;callValueOf&quot;
};

console.log(data[new Obj()]);//输出&quot;callToString&quot;

Obj.prototype.toString = function(){return {};}

console.log(data[new Obj()]);//输出&quot;callValueOf&quot;</code></pre>

<h3 id="_4">对象转数字</h3>

<p>对象转数字经过如下步骤：</p>

<ul>
<li>如果对象有valueOf()方法，后者返回一个原始值，那么将这个原始值转换为数字并返回</li>

<li>如果对象没有valueOf()方法，或返的不是一个原始值，尝试toString()方法。如果有toString()方法，且返回一个原始值，那么将其转换成数字并返回</li>

<li>如果无法从valueOf()或toString()获得一个原始值，那么将抛出一个类型错误异常</li>
</ul>

<pre class="javascript"><code class="javascript">function Obj() {}
Obj.prototype.toString = function() {
    return &quot;20&quot;
};

console.log(new Obj() * 1);//输出20

Obj.prototype.valueOf = function() {
    return &quot;10&quot;
};

console.log(new Obj() * 1);//输出10</code></pre>

<p>由这个栗子可以看到，转数字时会优先尝试valueOf()方法，然后尝试toString()方法，虽然获得的原始类型都是字符串，但会将字符串转换为数字</p>

<h2 id="_5">运算符与隐式类型转换</h2>

<h3 id="_6">“+”运算符</h3>

<p>“+”运算符的行为如下：</p>

<ul>
<li>如果其中一个操作数是对象，那么会将对象转换为原始值类型（Date通过toString方法，其他对象依次尝试valueOf和toString()）</li>

<li>如果对象转换到原始值后，其中一个是字符串，那么另一个也被转成字符串，进行字符串连接</li>

<li>否则两个操作数都将转换为数字（或NaN），然后想加</li>
</ul>

<pre class="javascript"><code class="javascript">function Obj(){}
Obj.prototype.valueOf = function(){
    return &quot;234&quot;;
};

console.log(123 + new Obj());//输出&quot;123234&quot;

Obj.prototype.valueOf = function(){
    return 234;
};

console.log(123 + new Obj());//输出&quot;357&quot;

Obj.prototype.valueOf = function(){
    return true;
};

console.log(123 + new Obj());//输出&quot;124&quot;

console.log(123 + new Date());//输出&quot;123Sun Mar 30 2014 12:53:02 GMT+0800 (中国标准时间)&quot;</code></pre>

<h3 id="_7">其他算数运算符</h3>

<p>乘法(*)，除法(/)，取模(%)，减法(-)，以及一元算数运算符（+，-，++，–）都是在需要的时候将操作数转化为数字，就是根据上面先尝试valueOf，后尝试toString的方式来转换。如果有一个操作数是NaN，那么运算结果也是NaN</p>

<h3 id="_8">位运算符</h3>

<p>位运算符需要它的操作数是整数，这些整数表示32位整型而不是64位浮点数，所以在进行位运算之前，首先将操作数转换为数字，然后转换为32位整型，之后进行操作。而NaN，Infinity和-Infinity都转换成0。</p>

<h3 id="_9">关系表达式</h3>

<p>严格相等（===）不会进行类型转换，而使用相等（==）会进行隐式的类型转换。严格相等会比较类型和值，类型不一致的两个值肯定不相等，具体规则如下：- 两个值类型不同，他们不相等</p>

<ul>
<li>都是null或都是undefined，他们不相等</li>

<li>都是布尔true或布尔false，他们相等</li>

<li>有一个值是NaN，那么不相等，NaN也不等于自身</li>

<li>都位数字时，且他们值相等，那么相等，0与-0相等</li>

<li>两个值都为字符串，如果他们长度或内容不同，则不相等</li>

<li>两个值都引用对象、数组或函数，如果它们引用同一个对象，他们相等，否则不相等</li>
</ul>

<p>举一些栗子来验证一下：</p>

<pre class="javascript"><code class="javascript">&gt; ({}) === ({})
false

&gt; [] === []
false

&gt; var a, b;
&gt; a = b = {};
&gt; a === b
true

&gt; NaN === NaN
false

&gt; null === undefined
false

&gt; 0 === -0
true

&gt; Infinity === Infinity
true

&gt; Infinity === -Infinity
false</code></pre>

<p>相等运算符（==）会进行隐式类型转换，规则如下：</p>

<ul>
<li>如果两个操作数类型相等，则和上面严格相等的比较规则一样</li>

<li>如果其中一个值是null，另一个是undefined，他们相等</li>

<li>如果一个是数字，另一个是字符串，则会先将字符串转为数字再比较</li>

<li>如果其中一个是布尔类型，也会将其转换为数字，然后在比较，true转换为1，false转换为0</li>

<li>如果一个值为对象，另一个值为数字或字符串，那么像将其转换为原始值。JavaScript语言核心的内置类会优先尝试valueOf，然后尝试toString。但Date类只是用toString转换</li>

<li>其他不同类型之间的比较均不相等</li>
</ul>

<p>举一些栗子：</p>

<pre class="javascript"><code class="javascript">&gt; null == undefined
true

&gt; ({}) == ({})
false

&gt; [] == []
false

&gt; &quot;123&quot; == 123
true

&gt; true == &quot;1&quot;
true

&gt; NaN == NaN
false

&gt; function Obj(){}
&gt; Obj.prototype.toString = function(){return &quot;tostring&quot;;}
&gt; Obj.prototype.valueOf = function(){return &quot;valueof&quot;;}
&gt; new Obj() == &quot;valueof&quot;
true

&gt; Infinity == Infinity
true

&gt; Infinity == -Infinity
false</code></pre>

<h2 id="_10">比较运算符</h2>

<p>小于、大于，小于等于、大于等于这些比较运算符的操作数可能是任意类型，但只有数字和字符串才能真正进行比较操作，所以会对其进行转换：</p>

<ul>
<li>如果操作数是对象，那么这个对象会转换为原始值，同样有限使用valueOf，然后使用toString</li>

<li>对象转换为原始值后，如果都是字符串，按照字典序比较</li>

<li>如果至少有一个操作数不是字符串，那么两个操作数都将转换为数字进行比较，0与-0相等，Infinity比任何数字都大（除了Infinity本身），-Infinity比任何数字都小，如果其中一个操作数是NaN，比较操作符返回false</li>
</ul>

<p>举几个栗子：</p>

<pre class="javascript"><code class="javascript">&gt; NaN &lt; 1
false

&gt; NaN &gt; 1
false

&gt; Infinity &lt; Infinity
fasle

&gt; Infinity &gt; Infinity
false

&gt; Infinity &gt; -Infinity
true

&gt; &quot;a&quot; &lt; &quot;b&quot;
true

&gt; &quot;abcd&quot; &lt; &quot;abce&quot;
true</code></pre>

<h3 id="in">in运算符</h3>

<p>in运算符永远期望左操作数是字符串，右操作数是一个对象，所以左操作数会隐式类型转换：</p>

<pre class="javascript"><code class="javascript">function Obj(){}
Obj.prototype.toString = function(){return &quot;callToString&quot;}
Obj.prototype.valueOf = function(){return &quot;callValueOf&quot;}
var data = {
    &quot;callToString&quot; : &quot;callToString&quot;
};

console.log(new Obj() in data);//输出true

Obj.prototype.toString = function(){return {};}

console.log(new Obj() in data);//输出false

data.callValueOf = &quot;callValueOf&quot;;

console.log(new Obj() in data);//输出true</code></pre>

<p>第一个console时，首先将<code>new Obj()</code>创建的对象转换为字符串，先尝试toString方法，获得callToString字符串，而它在data对象中存在，所以输出true</p>

<p>第二个console时，首先将<code>new Obj()</code>创建的对象转换为字符串，先尝试toString方法，获得一个对象，不是原始值，于是尝试valueOf方法，获得callValueOf字符串，而它在data对象中不存在，所以输出false</p>

<p>第三个console和第二个console过程一样，不过这一次data中存在callValueOf字符串，所以输出true</p>

<h3 id="instanceof">instanceof运算符</h3>

<p>instanceof运算符总是希望左操作数是一个对象，右操作数是一个函数。instanceof一次检查左操作数的对象的原型链的VO，如果存在右操作数函数的prototype存在于左操作数对象的原型链上，那么返回true，否则返回false</p>

<h3 id="_11">逻辑表达式</h3>

<p>逻辑操作符实际上并不总是作用于Boolean类型，它是根据左右操作数是真值还是假值来判定的</p>

<p>假值包括：</p>

<ul>
<li>false</li>

<li>null</li>

<li>undefined</li>

<li>0</li>

<li>-0</li>

<li>NaN</li>

<li>””</li>
</ul>

<p>除了假值以外的所有值都是真值</p>

<p>逻辑&amp;&amp;运算符中，如果左操作数是假值，那么不计算右操作数，直接返回左操作数（短路）。如果左操作符是真值，返回右操作数</p>

<pre class="javascript"><code class="javascript">var a,b;
a = null;
b = &quot;something&quot;;
console.log(a &amp;&amp; b);//输出null

a = &quot;something&quot;;
b = null;
console.log(a &amp;&amp; b);//输出null

a = &quot;something&quot;;
b = &quot;otherthing&quot;;
console.log(a &amp;&amp; b);//输出&quot;otherthing&quot;</code></pre>

<p>逻辑||运算符也是一样会出现短路，不过短路的条件时左值为真值。所以当左操作数为真值时，不计算右操作数而直接返回左操作数，否则返回右操作数</p>

<pre class="javascript"><code class="javascript">var a,b;
a = &quot;something&quot;;
b = null;
console.log(a || b);//输出&quot;something&quot;

a = null;
b = null;
console.log(a || b);//输出null

a = null;
b = &quot;something&quot;;
console.log(a || b);//输出&quot;something&quot;</code></pre>

<p>逻辑非（!）是一元运算符，它会先将操作数转换为布尔值（真值转true，假值转false）：</p>

<pre class="javascript"><code class="javascript">&gt; !&quot;&quot;
true

&gt; !NaN
true

&gt; !&quot;a&quot;
false</code></pre>

<p>一般我们需要将任意类型根据其真假值转换为Boolean时，可以使用如下方式：</p>

<pre class="javascript"><code class="javascript">result = !!param;</code></pre> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/30/js-type-convert</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（JavaScript补充篇） ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/28/performance-3</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 28 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h1 id="javascript">JavaScript性能优化补充篇</h1>

<p>来自《高性能JavaScript》</p>

<h2 id="javascript_2">JavaScript文件加载</h2>

<p>管理浏览器中的JavaScript代码是一个棘手的问题，因为代码执行会阻塞浏览器，比如界面绘制。每次遇到<code>&lt;script&gt;</code>标签，浏览器都会停下来等待代码下载并执行，然偶再继续处理其他部分。我们可以通过如下几种方法来减少JavaScript文件对性能的影响</p>

<h3 id="js">将JS文件放在页面底部</h3>

<p>将所有<code>&lt;script&gt;</code>标签放置在页面的底部，紧靠body关闭标签<code>&lt;/body&gt;</code>的上方。这样可以保证页面在脚本运行之前完成解析</p>

<h3 id="js_2">将JS文件打包</h3>

<p>将JS文件打包，页面的<code>&lt;script&gt;</code>标签越少，页面的加载速度越快，响应也越迅速。无论外部脚本文件还是内敛代码都是如此</p>

<h3 id="">使用非阻塞方式下载</h3>

<ol>
<li>在<code>&lt;script&gt;</code>标签中添加<code>defer</code>属性</li>

<li>动态创建<code>&lt;script&gt;</code>元素，用它下载并执行代码</li>

<li>用XHR对象下载代码，并注入到页面中</li>
</ol>

<h2 id="_2">数据访问</h2>

<h3 id="_3">四种访问方式</h3>

<p>在JavaScript中，数据存储位置可以对代码整体性能产生重要影响，有四种数据访问类型：直接量，变量，数组项，对象成员，这些访问方式性能不同</p>

<p>直接量和局部变量访问速度很快，而数组项和对象成员需要更长的时间</p>

<h3 id="_4">作用域链和闭包的访问速度</h3>

<p>在函数内部访问变量时，会顺着作用域链向上查找，直到找到为止，这也意味着作用域链越长，平均的查找时间也就越长。而像with和try-catch会增加作用域链的长度，所以也会降低性能。由此可以得知，访问全局变量很慢，因为他们在作用域链的最后一环</p>

<h3 id="_5">原型链访问</h3>

<p>访问对象的属性的时候，我们有时候会需要遍历原型链，这也意味着原型链越长，查找元素的平均效率就越低，变量所在的原型在原型链中越深，访问越慢</p>

<h2 id="dom">DOM</h2>

<p>当浏览器下载完所有的HTML、JavaScript、CSS、图片之后，它会解析文件并创建两个内部数据结构：一棵DOM树和一棵渲染树</p>

<p>每个需要被显示的DOM树节点在渲染树中至少有一个节点（隐藏的DOM节点自然在渲染树中没有节点），渲染树上的点被称为框或者盒，根据CSS模型定义，将页面元素看做一个具有填充、边距、边框和位置的盒。一旦DOM树和渲染树构造完毕，浏览器就可以绘制页面上的元素了。</p>

<p>当DOM改变影响到元素的几何属性（宽和高），浏览器就需要重新计算元素的几何属性。如果这个元素的改变影响到其他元素，浏览器会使渲染树上收到影响的部分失效，然后重构渲染树。这就是回流（也叫重排版）。重排版完成时，浏览器在一个重绘进程中重新绘制屏幕上受影响的部分</p>

<p>当然并不是所有DOM改变都会影响到几何属性，比如改变背景颜色之类的，这种情况下就只会触发重绘</p>

<p>回流和重绘都是负担很重的操作，会导致浏览器阻塞，所以需要尽可能避免</p>

<h3 id="_6">何时触发回流</h3>

<ol>
<li>添加或删除可见的DOM元素</li>

<li>元素位置的改变</li>

<li>元素尺寸的改变（border、padding、margin、height、width）</li>

<li>内容改变</li>

<li>最初页面渲染</li>

<li>浏览器窗口改变尺寸</li>
</ol>

<h3 id="_7">查询并刷新渲染树的改变</h3>

<p>因为计算量与每次回流有关，大多数浏览器会通过一个渲染队列来进行优化。但是用JavaScript获取一些DOM属性时，会（不由自主地）强迫队列中的所有渲染事件前不完成。比如获取如下属性：</p>

<ul>
<li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li>

<li>scrollTop, scrollLeft, scrollWidth, scrollHeight</li>

<li>clientTop, clientLeft, clientWidth, clientHeight</li>

<li>getComputedStyle() （在IE中为currentStyle）</li>
</ul>

<p>为了让这些属性返回正确的值，浏览器不得不运行渲染队列中所有的渲染事件，这样才能保证值的正确。所以尽量减少这些属性的访问</p>

<h2 id="_8">判断</h2>

<h3 id="ifelse">if-else</h3>

<p>多个if-else执行的时候，其会顺序检索每一个条件，直到所有条件检索完或检索到匹配的条件。所以我们可以通过树的形式组织if语句，如下面代码：</p>

<pre class="javascript"><code class="javascript">if(con === 1) {return result1;}
else if(con === 2) {return result2;}
else if(con === 3) {return result3;}
else if(con === 4) {return result4;}
else if(con === 5) {return result5;}
else if(con === 6) {return result6;}
else if(con === 7) {return result7;}
else if(con === 8) {return result8;}
else if(con === 9) {return result9;}</code></pre>

<p>这段代码就会依次判断con是否等于1,2,3,4,5,6,7,8,9，如果是9的话，就会判断9次，我们可以将其改为：</p>

<pre class="javascript"><code class="javascript">if (con &lt;= 3){
    if(con === 1) {return result1;}
    else if(con === 2) {return result2;}
    else {return result3;}
} else if(con &gt; 3 &amp;&amp; con &lt;= 6){
    if(con === 4) {return result4;}
    else if(con === 5) {return result5;}
    else {return result6;}
} else if(con &lt;= 9){
    if(con === 7) {return result7;}
    else if(con === 8) {return result8;}
    else {return result9;}
}</code></pre>

<p>这样我们通过三叉树的形式，就可以减少查找次数了，比如这里查找9次，分别判断 0~3,3~6,6~9,7,8,9，只需要6次</p>

<p>if-else除了通过这种树形组织编码以外，还有一个优化的地方。由于其顺序判断的逻辑，我们可以根据概率来，将概率比较大的判断放在前面，概率较小的放在后面，这样也可以减少平均查找长度</p>

<h3 id="switch">switch</h3>

<p>事实证明，大多数情况下switch比if-else更快，但是只有条件题数量很大的时候，才能明显更快。if-else在条件增加时，所带来的性能负担要高于switch，因此建议使用switch。不过switch只是用来判断几个不同的离散值，并没有if-else能判断离散值或值域那样的灵活性</p>

<h3 id="_9">打表法</h3>

<p>可以使用打表的形式来做，把所有的处理函数放在一个数组中，然后将条件作为键，这种方法比switch和if-else都要快，而且在新增条件时，不会带来额外的性能开销</p>

<h2 id="_10">递归</h2>

<p>很多算法都是递归实现，由于递归会多次触发函数调用，而函数调用也是需要开销的（比如创建运行期上下文、压运行期栈、创建AO、复制作用域链、销毁AO、弾栈等等），所以尽量将递归转变为循环。而运行期栈在很多浏览器中也有深度限制，当到达运行期栈的最大深度时，浏览器有各自的处理方式，但都是按照错误进行处理</p>

<h2 id="_11">字符串</h2>

<h3 id="_12">不同的拼接方法</h3>

<p>字符串拼接有很多不同的方法：</p>

<ol>
<li>使用<code>+</code>直接拼接</li>

<li>使用<code>+=</code>拼接</li>

<li>使用<code>Array.join()</code>拼接</li>

<li>使用<code>String.concat()</code>拼接</li>
</ol>

<h3 id="_13">使用加号拼接</h3>

<p>使用<code>+</code>和<code>+=</code>时，不同的浏览器会做不同程度的优化，如果在IE7和他之前的浏览器，优化做的不好，比如如下操作：</p>

<pre class="javascript"><code class="javascript">str += &quot;one&quot; + &quot;two&quot;</code></pre>

<p>实际上会执行如下步骤：</p>

<ol>
<li>内存中创建一个临时变量</li>

<li>将这个临时变量赋值成”onetow”</li>

<li>临时字符串与str拼接</li>

<li>将结果赋予str</li>
</ol>

<p>而如果改成如下这样：</p>

<pre class="javascript"><code class="javascript">str += &quot;one&quot;
str += &quot;two&quot;</code></pre>

<p>这样就可以避免创建临时字符串，可一定程度加快性能</p>

<p>或者使用如下方式：</p>

<pre class="javascript"><code class="javascript">str = str + &quot;one&quot; + &quot;two&quot;</code></pre>

<p>但是如果使用下面这种方式：</p>

<pre class="javascript"><code class="javascript">str = &quot;one&quot; + str + &quot;two&quot;</code></pre>

<p>则无法确定是否有优化。不同的浏览器分配内存方式不一样，IE以外的浏览器，会尝试扩展表达式左端字符串的内存，然后简单的将第二个字符串拷到它的尾部，这样就会创建一个临时字符串存放<code>one{str原本内容}</code>,导致性能降低</p>

<h3 id="_14">浏览器优化</h3>

<p>很多浏览器会在编译时对连续相加的字符串进行拼接，以此来对运行时优化，比如：</p>

<pre class="javascript"><code class="javascript">str += &quot;one&quot; + &quot;two&quot;</code></pre>

<p>会被优化成</p>

<pre class="javascript"><code class="javascript">str += &quot;onetwo&quot;</code></pre>

<h3 id="ie7">IE7-中的字符串连接</h3>

<p>IE7-中使用<code>+</code>和<code>+=</code>连接很慢，而使用<code>Array.join()</code>方式则快得多，这也是IE7-浏览器中唯一高效的连接大量字符串的途径</p>

<h3 id="stringconcat">String.concat</h3>

<p>这种方法很慢，尽量不要使用</p>

<h2 id="_15">正则表达式优化</h2>

<h3 id="_16">正则表达式的工作原理</h3>

<p>正则表达式处理经过如下几个步骤：</p>

<ol>
<li>编译</li>

<li>设置起始位置</li>

<li>匹配每个正则表达式的字元</li>

<li>匹配成功或失败</li>
</ol>

<p>正则表达式实现中，回溯是基本组成部分。它代价昂贵，且容易失控。回溯是正则表达式性能的唯一因素</p>

<p>正则表达式在匹配时，会在一个有多个分支的地方建立标记点，然后从左到右遍历所有的分支，如果分支符合，就会前进道下一个标记点，如果所有分支都不符合，就会回溯到上一个标记点，尝试上一标记点的其他分支。在尝试上一标记点的其它分支时，这一标记点如果需要，还会全部重新尝试</p>

<h3 id="_17">回溯失控</h3>

<p>当一个正则表达式占用浏览器上秒，或者更长时间，很有肯那个就是回溯失控了，原因很有可能是出现了<code>.*?</code>这种非贪婪匹配，导致几乎每一个字符都会被作为标记点进行尝试</p>

<p>此类问题的解决办法是尽可能具体地指出分隔符之间的字符匹配形式，或者使用前瞻表达式</p>

<h3 id="_18">嵌套量词导致性能下降</h3>

<p>嵌套量词可能极大的加大分支的数量，比如一个正则表达式<code>A+A+B</code>显然没有<code>AA+B</code>好，比如匹配<code>AAAAAAAAAAAAAAB</code>时，前者产生的分支要比后者多得多</p>

<h3 id="_19">一些建议</h3>

<ol>
<li>关注如何让匹配更快失败：正则表达式慢往往不是因为成功慢，而是失败慢，因为失败会查找所有的情况</li>

<li>以简单的，必须的字元开始：这样可以加快失败的匹配，如果这个开始字元都不匹配，后面的标记点就不会被匹配了</li>

<li>编写两次模板，使他们后面的资源互相排斥：当字元与邻近的子表达式能够重叠匹配时，路径将显著正价，所以需要将其具体化</li>

<li>减少分之数量，缩小它们的范围：直接使用正则表达式中已有的类（如<code>\w</code>,<code>\d</code>）比使用<code>|</code>要快</li>

<li>使用非捕获分组：捕获分组花费时间和内存用于记录后向引用，而使用后非捕获性分组则避免这种开销</li>

<li>将正则表达式分层，先捕获感兴趣的文字，然后再使用新的正则表达式处理</li>

<li>暴露所需的字元，尽量简单地判断出那些必须的字元</li>

<li>使用适当的量词，贪婪量词和懒惰量词在匹配同样字符串时过程是不同的，在确保正确的前提下，选择回溯次数更少的量词可以提高性能</li>

<li>将正则表达式赋给变量，以重用他们。正则表达式创建时，需要对他们进行编译，这个编译也会有额外的开销</li>

<li>将复杂的正则表达式拆分成简单的片段，避免使用一个表达式做太多的工作，可以通过两个或多个正则表达式来解决</li>
</ol>

<h2 id="ui">UI线程相关</h2>

<p>建议的一次JavaScript执行时间不超过100ms（最好在50ms）以内，可以通过setTimeout和setInterval来将任务进行分解，加入到UI线程中。其实这个思想和JavaScript引擎的垃圾回收器的迭代处理相似</p>

<h2 id="ajax">AJAX</h2>

<p>AJAX获取数据时，可以使用POST或者GET方法</p>

<p>如果请求不改变服务器状态指示返回数据，应该使用GET。GET请求会被缓存，如果多次提取相同的数据会提高性能</p>

<p>而当URL和请求的参数长度超过2048个字符的时候才使用POST提取数据</p>

<h3 id="xhrmxhr">多部分XHR（MXHR）</h3>

<p>多部分XHR允许使用一个HTTP请求获取多个资源，我们可以将资源打包成一个特定分隔符定界的大字符串，从服务器发送到客户端，JavaScript处理这些大字符串，然后根据它自身的类型和信息解析出每个资源</p>

<p>需要注意的是AJAX不会在浏览器中进行缓存，自然使用MXHR也不会缓存，在一些静态资源上使用这种方式其实并不太好。但是如果每次都确实需要去获取，分多个请求发送会更慢。</p>

<h3 id="img">IMG灯标</h3>

<p>我们可以通过创建一个Image对象，将src设为一个脚本文件的URL，img元素我们并不需要插入到DOM中，这种形式称为IMG灯标</p>

<p>这种方式适用于GET请求，且服务器获得数据后不必返回数据给浏览器的情况</p>

<p>同时我们可以在Image的load事件中监听服务端是否成功接受了数据</p>

<h3 id="_20">数据格式</h3>

<ul>
<li>XML：支持广泛但解析效率低，而且相当冗长</li>

<li>JSON： 小巧，轻便，解析速度较快</li>

<li>JSONP：使用JavaScript解释器进行解析，解析速度极快，数据量只比JSON多一点点（函数名称和括号）</li>

<li>HTML：无需解析，数据冗长</li>

<li>自定义格式：自己解析，慢而易出错，数据长度可以很短</li>
</ul>

<h2 id="_21">其他</h2>

<ul>
<li>不要使用eval以及其类似</li>

<li>使用字面量</li>

<li>避免重复工作，检测浏览器时，保存首次检测结果即可</li>

<li>考虑位操作</li>

<li>使用原声方法，因为他们是C++写的</li>

<li>文件预处理，压缩（gzip）、合并、uglify</li>

<li>尝试CDN</li>
</ul> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/28/performance-3</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript一些基础知识简介 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/28/js-basis</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 28 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">作用域链基础知识</h2>

<h3 id="_2">作用域链</h3>

<p>每一个JavaScript函数都会被表示为一个函数对象，它和其他对象一样，拥有自己的属性，其中有一些是JavaScript引擎所使用的内部属性，不允许外部访问，<code>[[scope]]</code>就是其中一个</p>

<h3 id="scope">scope属性</h3>

<p>内部<code>[[scope]]</code>属性包含一个函数被创建的作用域对象的集合，被称为作用域链。它决定函数可以访问哪些属性。作用域链中的每个对象都被称为一个VO（Variable Object），每个VO都以“键值对”的形式存在。当一个函数创建以后，它的作用域链就会被填充，这些对象代表创建此函数的环境中可访问的数据。</p>

<h3 id="_3">创建运行期上下文</h3>

<p>在函数运行时，会创建一个内部对象，称为运行期上下文（Execution Context，也叫EC），这个运行期上下文在创建后回访制在“运行期栈”中，和其他语言的函数调用的栈类似。一个运行期上下文定义了一个函数运行时的环境。函数的每次运行都会创建一个运行期上下文，每次创建的运行期上下文相互独立。当函数执行完毕时，运行期上下文就会被销毁</p>

<h3 id="_4">复制作用域链</h3>

<p>一个运行期上下文有自己的作用域链，用于标识符解析。当运行期上下文被创建时，它的作用域链被初始化，并将所运行函数的<code>[[scope]]</code>中的VO对象按照顺序复制到运行期上下文自己的作用域链中</p>

<h3 id="ao">AO对象的创建</h3>

<p>在复制完函数的作用域链之后，就会创建一个被称为AO（Activation Object）的对象，这个对象包含了以下内容：</p>

<ol>
<li>this</li>

<li>局部变量</li>

<li>命名参数</li>

<li>arguments集合</li>
</ol>

<p>创建完成AO对象后，它江北推入作用域链的最前端。作用域链被销毁时，AO也会一并销毁</p>

<h3 id="_5">标示符解析</h3>

<p>函数运行过程中，每遇到一个变量，标识符都需要决定需要从哪里获得数据。这个搜索过程会顺着运行期上下文的作用域链来查找。大致上流程如下：</p>

<ol>
<li>索引一个AO或VO</li>

<li>查找其中的局部变量</li>

<li>查找其中的命名参数</li>

<li>如果没找到，查找下一个AO或VO，如果有则转到1，否则转到5</li>

<li>输出标识符未定义</li>
</ol>

<h3 id="withtrycatch">with和try-catch改变作用域链</h3>

<p>一般来说，运行期上下文的作用域链是不会被改变的。但是使用<code>with</code>和<code>try-catch</code>可以对作用域链进行临时改变。</p>

<p>with所做的就是在作用域链前端再插入一个VO，with所指定的对象的所有属性，都会被插入到这个VO中。由此，访问with所指定的对象的属性速度将会加快，但由于增长了作用域链的长度，访问其他属性将会减慢。所以使用with不如直接使用一个变量来暂存with所指定的对象</p>

<p>try-catch中的catch块也有相同的效果，在catch块中，会将异常对象构造成一个VO，插入到运行时上下文的作用域链的最前端。同样会加长作用域链，导致性能下降。解决办法就是在catch块中调用一个处理函数，所有的逻辑放在处理函数之中。</p>

<h2 id="_6">闭包</h2>

<p>闭包的强大在于它允许函数访问局部范围之外的数据。当一个函数被执行时，会创建一个AO，而如果在函数执行时创建了闭包，当前运行期上下文的作用域链将复制到闭包的作用域链中</p>

<p>由于闭包的作用域链与运行期上下文作用域链中的引用相同，这也就是说在函数的AO与运行期上下文一同销毁时，由于闭包的存在，AO中的对象依旧早闭包的作用域链中被引用，导致JavaScript的垃圾回收器认为AO中的对象已然是活对象，而不会对其进行垃圾回收。所以闭包将会导致更多的内存开销</p>

<h2 id="_7">原型链</h2>

<h3 id="_8">原型</h3>

<p>我们都知道JavaScript是基于对象的语言，原型是对象的基础。一个对象通过内部属性绑定到它的原型，在一些浏览器如FF，Safari，Chrome中可以使用<code>__proto__</code>来访问对象的原型。当创建一个内置类型的实例时，这些实例自动拥有一个Object作为它们的原型</p>

<h3 id="_9">创建对象</h3>

<p>在对象被创建时，对象的<code>__proto__</code>属性指向其构造函数的<code>prototype</code>属性，而如果一个函数没有指定prototype属性，那么这个属性将默认为一个空的<code>Object</code>，而<code>Object.prototype.__proto__</code>为<code>null</code></p>

<p>比如如下情况：</p>

<pre class="javascript"><code class="javascript">&gt; function A(){}
&gt; new A().__proto__ === A.prototype
true
&gt; A.prototype.__proto__
Object {}
&gt; A.prototype.__proto__.__proto__
null</code></pre>

<h3 id="_10">原型链</h3>

<p>由此，我们可以将一个构造好的对象传递给另一个需要构造的对象的构造函数的<code>prototype</code>属性，这样新构造函数所构造的对象的<code>__proto__</code>自然就指向之前构造好的对象了。这就是原型链</p>

<p>当查找一个对象的属性的时候，如果遍历对象当前的所有属性，如果不存在，就会顺着原型链一层一层遍历原型链上的对象，直到查找成功</p>

<p>比如如下实例：</p>

<pre class="javascript"><code class="javascript">&gt; function A(){this.a = &quot;In A&quot;}
&gt; A.prototype = {ap : &quot;In A.prototype&quot;};
&gt; function B(){this.b = &quot;In B&quot;}
&gt; B.prototype = new A()
&gt; var b = new B()
&gt; console.log(b.a)
&quot;In A&quot;
&gt; console.log(b.ap)
&quot;In A.prototype&quot;
&gt; console.log(b.b)
&quot;In B&quot;</code></pre>

<p>这里由于将A的实例复制给了B构造函数的<code>prototype</code>属性，所以B的实例的<code>__proto__</code>就指向这个A的实例</p>

<p>在查找a属性的时候，首先在这个B的实例中查找，发现没有，顺着原型链到达A实例，发现了这个属性，输出，所以为<code>&quot;In A&quot;</code></p>

<p>在查找ap属性的时候，首先在B的实例中查找，发现没有，顺着原型链到达A实例，发现没有，顺着原型链达到A.prototype的对象，发现属性，所以输出<code>&quot;In A.prototype&quot;</code></p>

<p>在查找b属性的时候，在B的实例中查找，找到了，所以直接输出<code>&quot;In B&quot;</code></p>

<h3 id="_11">基于原型的继承</h3>

<p>上面可以看到，其实就是一种继承的方式。JavaScript中的继承就是使用这种原型继承方式来实现的。上例中B继承了A，一般情况下我们希望使用<code>instanceof</code>来确定对象是哪种对象。比如使用<code>instanceof</code>检测B的实例时，无论是检测B还是A还是Object，都应该返回true</p>

<p><code>object instanceof constructor</code>的实际行为是检测<code>constructor.prototype</code>是否存在于<code>object</code>的原型链上</p>

<pre class="javascript"><code class="javascript">&gt; function A(){};
&gt; function B(){};
&gt; B.prototype = new A();
&gt; var b = new B();
&gt; b instanceof A
true
&gt; b instanceof B
true
&gt; b instanceof Object
true</code></pre>

<h3 id="constructor">constructor属性</h3>

<p>上例可以看到使用<code>instanceof</code>属性可以进行检测，而对象中还有一个constructor属性，指向其构造函数</p>

<pre class="javascript"><code class="javascript">&gt; function A (){}
&gt; new A().__proto__.constructor === A
true</code></pre>

<p>constructor这个属性是在创建构造函数时赋值到构造函数的prototype属性中的。而这时，这个constructor指向这个构造函数本身</p>

<pre class="javascript"><code class="javascript">&gt; function A(){}
&gt; A === A.prototype.constructor
true</code></pre>

<p>而上面我们说了，在使用构造函数创建实例的时候，会将构造函数的<code>prototype</code>属性传递给实例的<code>__proto__</code>属性，所以实例的constructor属性就能指向自己的构造函数了</p>

<p>然而，当我们使用了如上面A和B的继承方式时，就变化了：</p>

<pre class="javascript"><code class="javascript">&gt; function A(){}
&gt; function B(){}
&gt; B.prototype = new A();
&gt; var b = new B();
&gt; b.constructor
function A(){}</code></pre>

<p>输出的是构造函数A而不是构造函数B</p>

<p>这是因为B的prototype属性已经被覆盖成<code>new A()</code>所创建的A的实例，A的实例中，constructor属性指向的自然是A构造函数。具体的索引过程如下：</p>

<ol>
<li>查找b对象的constructor属性，没找到</li>

<li>查找<code>b.__proto__</code>对象，也就是<code>new A()</code>所创建的A实例，没有找到</li>

<li>查找A实例的<code>__proto__</code>对象，也就是<code>A.prototype</code>，找到了constructor属性，返回</li>
</ol>

<p>如果这样继承，就容易出现错误，所以我们需要手动将B构造函数赋值给它自己的<code>prototype</code>属性，将上面的继承改成如下这样：</p>

<pre class="javascript"><code class="javascript">&gt; function A(){}
&gt; function B(){}
&gt; B.prototype = new A();
&gt; B.prototype.constructor = B;
&gt; var b = new B();
&gt; b.constructor
function B(){}</code></pre>

<p>这样就是我们想要的结果了</p>

<h3 id="_12">一些其他的乱七八糟</h3>

<p>JavaScript除了该死的constructor以外，还有一些坑，比如Array.prototype其实是个数组实例：</p>

<pre class="javascript"><code class="javascript">&gt; Array.prototype
[]</code></pre>

<h2 id="ui">UI线程</h2>

<h3 id="_13">基础概念</h3>

<p>大多数浏览器只有一个单独的处理线程，它由两个任务共享：JavaScript任务和用户界面更新任务，每个时刻只有一个操作得以执行。当JavaScript代码执行时，用户界面就会被“锁定”，反过来也是一样。他们所共享的这个线程就被称为UI线程</p>

<p>比如一次按钮点击，会依次将按钮样式改变、按钮点击时需要运行的JavaScript代码、代码中的UI改变依次加入到UI线程中</p>

<h3 id="_14">浏览器的限制</h3>

<p>浏览器除了会限制运行期栈的深度以外，还会限制长时间执行脚本。不同的浏览器判断脚本执行时间过长的方法不一样，有的是通过时间来判断，有的是通过运行语句的条数判断</p>

<h3 id="_15">应当运行多久</h3>

<p>一个单一的JavaScript操作所使用的最大时间应该是100ms，如果用户100ms之内无法收到接口呃响应，用户就会认为自己与接口断开了</p>

<h3 id="_16">定时相关</h3>

<p>JavaScript中有两种定时器，<code>setTimeout</code>和<code>setInterval</code>，使用它们能将较长的任务分解成较短的任务</p>

<p>使用定时器时，比如如下代码：</p>

<pre class="javascript"><code class="javascript">setTimeout(function(){
    //do something
}, 250);</code></pre>

<p>在这句<code>setTimeout</code>指令执行后的250ms（不一定精确），将函数加入到UI线程中。需要注意的是，这里不是立刻加入UI线程中，而是到了时间才加入。</p>

<blockquote>
<p>另外我曾看过一篇文章，讲述的是setTimeout和setInterval执行后，会将其内设定到时需要执行的代码放入一个红黑树中，而每次执行时会从红黑树中挑选出当前最先需要执行的代码，放入UI线程中，同时维护红黑树。这个概念不太明确，有待考证</p>
</blockquote>

<p>这样我们可以看到，只有当前任务执行完之后，才有可能去执行UI队列中的其他任务，所以如下代码：</p>

<pre class="javascript"><code class="javascript">console.log(1);
setTimeout(function() {
    console.log(2);
}, 0);
console.log(3);</code></pre>

<p>输出的结果实际上是132</p>

<h3 id="_17">定时器的精度问题</h3>

<p>JavaScript的定时器往往不太准确（当然requestAnimationFrame要精确得多），快慢大约几毫秒。而此外最小定时器延时的设定也会影响运行，在IE中建议的最小值为25ms</p>

<h3 id="_18">定时器分解任务</h3>

<p>我们可以将任务分解成一系列子任务，然后将其分别通过定时器加入到UI线程中，以此来保证每个子任务运行时间不超过100ms（最好是不超过50ms），让UI更新和响应任务也能够及时处理。其实这个思想和JavaScript引擎的垃圾回收器的迭代处理相似</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/28/js-basis</guid>
            </item>
        
            <item>
                <title><![CDATA[ 漫谈前端开发中的SEO ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/27/seo</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 27 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="seo">什么是SEO</h2>

<p>SEO全称是搜索引擎优化，是一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的排名的方式。SEO为了从搜索引擎获得更多的免费流量，从网站结构、内容建设方案、用户活动传播、页面结构等进行合理规划，使网站更适合搜索引擎检索。</p>

<h2 id="seohtml">SEO相关的HTML标签</h2>

<h3 id="title">title</h3>

<p><code>&lt;title&gt;页面的标题&lt;/title&gt;</code>，必须有的东西，非常之重要</p>

<h3 id="keyrowds">keyrowds</h3>

<p><code>&lt;meta name=&quot;keywords&quot; content=&quot;keyWord1,keyWord2&quot;/&gt;</code>，定义为搜索引擎提供的关键字列表，页面的呃主关键词都可以列举在这里</p>

<h3 id="description">description</h3>

<p><code>&lt;meta name=&quot;description&quot; content=&quot;页面描述&quot;&gt;</code>。这一部分告诉搜索引擎当前网页的主要内容，对有些搜索引擎的排名影响不大（如百度）但是对用户体验方面还是很有用的</p>

<h3 id="robots">robots</h3>

<p><code>&lt;meta name=&quot;Robots&quot; content=&quot;nofollow&quot;/&gt;</code>，告诉搜索引擎哪些页面需要索引，哪些页面则不需要，它对页面上的所有标签生效，包括站内站外。比如nofollow属性，如果在a标签上加上了nofollow，如<code>&lt;a rel=&quot;external nofollow&quot; href=&quot;&quot;&gt;锚文本&lt;/a&gt;</code>，搜索引擎将不会抓取这个连接，这样可以防止权重分散到一些无关页面。</p>

<p>content中的参数可以设定为<code>all</code>,<code>none</code>,<code>index</code>,<code>noindex</code>,<code>follow</code>,<code>nofollow</code>，默认为all。</p>

<h3 id="h1">H1</h3>

<p><code>&lt;h1&gt;标题&lt;/h1&gt;</code>，告诉搜索引擎一段文字的标题，h1标题的权重较大，而h2、h3、h4对搜索引擎没有多大价值，加上可以增加用户体验</p>

<h3 id="alttitle">alt和title</h3>

<p>尽量在img标签中加入alt属性如<code>&lt;img src=&quot;&quot; alt=&quot;这里加上关键词&quot;/&gt;</code>，alt会影响搜索排名</p>

<p>而a标签中的title也是一样，虽然效果微弱</p>

<h3 id="html">语义化HTML</h3>

<p>在HTML5中新增了很多语义化的HTML5元素，如<code>&lt;header&gt;</code>,<code>&lt;section&gt;</code>,<code>&lt;footer&gt;</code>,<code>&lt;article&gt;</code>,<code>&lt;aside&gt;</code>,<code>&lt;nav&gt;</code>等等，这些语义化元素能帮助搜索引擎快速过滤掉不重要的信息，而从中快速提取出网页的主题内容，同时语义化的HTML也能够有较强的可访问性</p>

<h2 id="">对搜索引擎不友好的示例</h2>

<ol>
<li>网页中大量采用图片或者Flash等富媒体形式，没有可以检索的文本信息</li>

<li>网页没有标题，或者标题中不包含有效关键字</li>

<li>正文中有效关键词比较少（小于文章的2%~8%）</li>

<li>网站导航系统让搜索引擎看不懂</li>

<li>大量动态网页让搜索引擎无法检索</li>

<li>没有被其他已经被搜索引擎收录的网站所链接</li>

<li>网站中充值大量欺骗搜索引擎的垃圾信息，如过渡页，桥页、颜色与背景色相同的文字</li>

<li>网站中缺少原创内容，完全照搬别人的内容</li>
</ol>

<h2 id="_2">一些好的建议</h2>

<h3 id="_3">保持文章原创性</h3>

<p>保持文章的原创性才不会被网络蜘蛛所唾弃，由于搜索引擎中已经保存了大量的数据，经过比对后，如果当前页面与已存在搜索引擎中的页面的相似度过高，将降低当前页面的权重。所以我们需要保持网页内文章的原创性。一般情况下至少要保持与其他文章的30%的不同</p>

<h3 id="_4">关键字的堆砌</h3>

<p>众所周知，在网页中的<code>meta</code>标签中定义<code>keywors</code>对搜索引擎来说非常重要。而搜索中的关键词也应当堆砌在标题和正文中。其中标题由于字数有限，应当尽可能的出现较多的关键词，而正文中关键词也应当占有一定比重（2%~8%）。另外在文章中应当保持关键词的统一性，一个名称有多种叫法的时候尽量只是用其中的一种。同时出现在正文中的关键词应当加粗或家斜体来进行区分，让搜索引擎优先考虑</p>

<h3 id="_5">标题</h3>

<p>标题不应当太长，最好不超过15个汉字，其中尽量多的堆砌关键词，同时保证标题新颖，符合用户的搜索习惯。尽量将主关键词放在标题的前半部分</p>

<h3 id="_6">文章摘要</h3>

<p>在文章摘要中必须包含关键词，尽可能的重复页面的关键词，但是不要堆积，一般来说重复三遍没有问题。同时文章摘要的文字没有严格的字数要求，但一般以80-100字为宜</p>

<h3 id="_7">正文内容</h3>

<p>正文内容需要保持原创性，同时在前100字中（或是首段）最好能出现关键词。同时需要保持文章的长度，如果文章过长，应当采用分页的方式，一般一页的长度在1000字以下。短的文章有助于搜索引擎提取和分析。在正文中需要一定的关键词堆叠（2%~8%）</p>

<h3 id="ajaxflash">AJAX和FLASH</h3>

<p>在开发中经常会使用Flash创建绚丽的导航，但实际上Flash导航中的链接是无法被网络蜘蛛抓取到的。而AJAX也是一样，因为AJAX是动态加载的，所以它不易被搜索引擎所抓取。所以尽量避免过度使用AJAX和FLASH，尤其不要将重要的内容通过AJAX和FLASH加载。如果网站有较多AJAX加载的内容话，可以提供一个非AJAX加载的静态替代网页</p>

<h3 id="_8">图片和链接</h3>

<p>我们可以把网络蜘蛛看做一个基于文字的浏览器，它无法获取到图片内部的信息。因此，如果需要通过图片传达比较重要的信息的话，需要将信息写在<code>alt</code>属性中，传达给搜索引擎。链接也可以通过类似的<code>title</code>属性来添加相应的说明。在<code>alt</code>和<code>title</code>中给与精确的描述，并尽可能的输入关键词，这样能告诉搜索引擎图片和链接是做什么的</p>

<h2 id="_9">参考文章</h2>

<p><a href="http://baike.baidu.com/link?url=RtgwJhMXAZh7_7BWXlvu9CXZV4JnoytnMWXlyAhLfgAKgPPoG6-vAooSYfFIBuM-">百度百科：SEO</a></p>

<p><a href="http://www.daqianduan.com/1808.html">站内SEO规范</a></p>

<p><a href="http://www.yangzblog.com/internet/webfeSEO.html">网页前端制作中的SEO</a></p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/27/seo</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（JavaScript篇） ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/25/performance-2</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 25 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">优化循环</h2>

<p>如果现在有个一个<code>data[]</code>数组，需要对其进行遍历，应当怎么做？最简单的代码是：</p>

<pre class="javascript"><code class="javascript">for (var i = 0; i &lt; data.length; i++) {
    //do someting
}</code></pre>

<p>这里每次循环开始前都需要判断i是否小于<code>data.length</code>，JavaScript并不会对<code>data.length</code>进行缓存，而是每次比较都会进行一次取值。如我们所知，JavaScript数组其实是一个对象，里面有个length属性，所以这里实际上就是取得对象的属性。如果直接使用变量的话就会少一次索引对象，如果数组的元素很多，效率提升还是很可观的。所以我们通常将代码改成如下所示：</p>

<pre class="javascript"><code class="javascript">for(var i = 0, m = data.length; i &lt; m; i++) {
    //do someting
}</code></pre>

<p>这里多加了一个变量m用于存放<code>data.length</code>属性，这样就可以在每次循环时，减少一次索引对象，但是代价是增加了一个变量的空间，如果遍历不要求顺序，我们甚至可以不用m这个变量存储长度，在不要求顺序的时候可以使用如下代码：</p>

<pre class="javascript"><code class="javascript">for(var i = data.length; i--; ) {
    //do someting
}</code></pre>

<p>当然我们可以使用while来替代：</p>

<pre class="javascript"><code class="javascript">var i = data.length;
while(i--) {
    //do someting
}</code></pre>

<p>这样就可只使用一个变量了</p>

<h2 id="_2">运算结果缓存</h2>

<p>由于JavaScript中的函数也是对象（JavaScript中一切都是对象），所以我们可以给函数添加任意的属性。这也就为我们提供符合备忘录模式的缓存运算结果的功能，比如我们有一个需要大量运算才能得出结果的函数如下：</p>

<pre class="javascript"><code class="javascript">function calculator(params) {
    //大量的耗时的计算 
    return result;
}</code></pre>

<p>如果其中不涉及随机，参数一样时所返回的结果一致，我们就可以将运算结果进行缓存从而避免重复的计算：</p>

<pre class="javascript"><code class="javascript">function calculator(params) {
    var cacheKey = JSON.stringify(params);
    var cache = calculator.cache = calculator.cache || {};
    if(typeof cache[cacheKey] !== &#39;undefined&#39;) {
        return cache[cacheKey];
    }
    //大量耗时的计算
    cache[cacheKey] = result;
    return result;
}</code></pre>

<p>这里将参数转化为JSON字符串作为key，如果这个参数已经被计算过，那么就直接返回，否则进行计算。计算完毕后再添加入cache中，如果需要，可以直接查看cache的内容：<code>calculator.cache</code></p>

<p>这是一种典型的空间换时间的方式，由于浏览器的页面存活时间一般不会很长，占用的内存会很快被释放（当然也有例外，比如一些WEB应用），所以可以通过这种空间换时间的方式来减少响应时间，提升用户体验。这种方式并不适用于如下场合：</p>

<ol>
<li>相同参数可能产生不同结果的情况（包含随机数之类的）</li>

<li>运算结果占用特别多内存的情况</li>
</ol>

<h2 id="_3">不要在循环中创建函数</h2>

<p>这个很好理解，每创建一个函数对象是需要大批量空间的。所以在一个循环中创建函数是很不明智的，尽量将函数移动到循环之前创建，比如如下代码：</p>

<pre class="javascript"><code class="javascript">for(var i = 0, m = data.length; i &lt; m; i++) {
    handlerData(data[i], function(data){
        //do something
    });
}</code></pre>

<p>就可以修改为：</p>

<pre class="javascript"><code class="javascript">var handler = function(data){
    //do something
};
for(var i = 0, m = data.length; i &lt; m; i++) {
    handlerData(data[i], handler);
}</code></pre>

<h2 id="_4">让垃圾回收器回收那些不再需要的对象</h2>

<p>之前我曾在 <a href="http://skyinlayer.com/blog/2014/03/19/v8-gc/">浅谈V8引擎中的垃圾回收机制</a> 中讲到了V8引擎如何进行垃圾回收。可以从中看到，如果长时间保存对象，老生代中占用的空间将增大，每次在老生代中的垃圾回收过程将会相当漫长。而垃圾回收器判断一个对象为活对象还是死对象，是按照是否有活对象或根对象含有对它的引用来判定的。如果有根对象或者活对象引用了这个对象，它将被判定为活对象。所以我们需要通过手动消除这些引用来让垃圾回收器对回收这些对象。</p>

<h3 id="delete">delete</h3>

<p>一种方式是通过<code>delete</code>方式来消除对象中的键值对，从而消除引用。但这种方式并不提倡，它会改变对象的结构，可能导致引擎中对对象的存储方式变更，降级为字典方式进行存储（详细请见<a href="http://newhtml.net/v8-object-representation/">V8 之旅：对象表示</a>），不利于JavaScript引擎的优化，所以尽量减少使用</p>

<h3 id="null">null</h3>

<p>另一种方式是通过将值设为null来消除引用。通过将变量或对象的属性设为null，可以消除引用，使原本引用的对象成为一个“孤岛”，然后在垃圾回收的时候对其进行回收。这种方式不会改变对象的结构，比使用<code>delete</code>要好</p>

<h3 id="_5">全局对象</h3>

<p>另外需要注意的是，垃圾回收器认为根对象永远是活对象，永远不会对其进行垃圾回收。而全局对象就是根对象，所以全局作用域中的变量将会一直存在</p>

<h3 id="_6">事件处理器的回收</h3>

<p>在平常写代码的时候，我们经常会给一个DOM节点绑定事件处理器，但有时候我们不需要这些事件处理器后，就不管它们了，它们默默的在内存中保存着。所以在某些DOM节点绑定的事件处理器不需要后，我们应当销毁它们。同时绑定的时候也尽量使用事件代理的方式进行绑定，以免造成多次重复的绑定导致内存空间的浪费，事件代理可见<a href="http://skyinlayer.com/blog/2014/03/25/performance-1/">前端性能优化（DOM操作篇）</a></p>

<h3 id="_7">闭包导致的内存泄露</h3>

<p>JavaScript的闭包可以说即是“天使”又是“魔鬼”，它“天使”的一面是我们可以通过它突破作用域的限制，而其魔鬼的一面就是和容易导致内存泄露，比如如下情况：</p>

<pre class="javascript"><code class="javascript">var result = (function() {
    var small = {};
    var big = new Array(10000000);
    //do something
    return function(){
        if(big.indexOf(&quot;someValue&quot;) !== -1) {
            return null;
        } else {
            return small;
        }
    }
})();</code></pre>

<p>这里，创建了一个闭包。使得返回的函数存储在result中，而result函数能够访问其作用域内的small对象和big对象。由于big对象和small对象都可能被访问，所以垃圾回收器不会去碰这两个对象，它们不会被回收。我们将上述代码改成如下形式：</p>

<pre class="javascript"><code class="javascript">var result = (function() {
    var small = {};
    var big = new Array(10000000);
    var hasSomeValue;
    //do something
    hasSomeValue = big.indexOf(&quot;someValue&quot;) !== -1;
    return function(){
        if(hasSomeValue) {
            return null;
        } else {
            return small;
        }
    }
})();</code></pre>

<p>这样，函数内部只能够访问到hasSomeValue变量和small变量了，big没有办法通过任何形式被访问到，垃圾回收器将会对其进行回收，节省了大量的内存。</p>

<h2 id="evalwith">慎用eval和with</h2>

<p>Douglas Crockford将eval比作魔鬼，确实在很多方面我们可以找到更好地替代方式。使用它时需要在运行时调用解释引擎对<code>eval()</code>函数内部的字符串进行解释运行，这需要消耗大量的时间。像<code>Function</code>、<code>setInterval</code>、<code>setTimeout</code>也是类似的</p>

<p>Douglas Crockford也不建议使用with，with会降低性能，通过with包裹的代码块，作用域链将会额外增加一层，降低索引效率</p>

<h2 id="_8">对象的优化</h2>

<h3 id="_9">缓存需要被使用的对象</h3>

<p>JavaScript获取数据的性能有如下顺序（从快到慢）：变量获取 &gt; 数组下标获取（对象的整数索引获取） &gt; 对象属性获取（对象非整数索引获取）。我们可以通过最快的方式代替最慢的方式：</p>

<pre class="javascript"><code class="javascript">var body = document.body;
var maxLength = someArray.length;
//...</code></pre>

<p>需要考虑，作用域链和原型链中的对象索引。如果作用域链和原型链较长，也需要对所需要的变量继续缓存，否则沿着作用域链和原型链向上查找时也会额外消耗时间</p>

<h3 id="_10">缓存正则表达式对象</h3>

<p>需要注意，正则表达式对象的创建非常消耗时间，尽量不要在循环中创建正则表达式，尽可能多的对正则表达式对象进行复用</p>

<h3 id="_11">考虑对象和数组</h3>

<p>在JavaScript中我们可以使用两种存放数据：对象和数组。由于JavaScript数组可以存放任意类型数据这样的灵活性，导致我们经常需要考虑何时使用数组，何时使用对象。我们应当在如下情况下做出考虑：</p>

<ol>
<li>存储一串相同类型的对象，应当使用数组</li>

<li>存储一堆键值对，值的类型多样，应当使用对象</li>

<li>所有值都是通过整数索引，应当使用数组</li>
</ol>

<h3 id="_12">数组使用时的优化</h3>

<ol>
<li>往数组中插入混合类型很容易降低数组使用的效率，尽量保持数组中元素的类型一致</li>

<li>如果使用稀疏数组，它的元素访问将远慢于满数组的元素访问。因为V8为了节省空间，会将稀疏数组通过字典方式保存在内存中，节约了空间，但增加了访问时间</li>
</ol>

<h3 id="_13">对象的拷贝</h3>

<p>需要注意的是，JavaScript遍历对象和数组时，使用<code>for...in</code>的效率相当低，所以在拷贝对象时，如果已知需要被拷贝的对象的属性，通过直接赋值的方式比使用<code>for...in</code>方式要来得快，我们可以通过定一个拷贝构造函数来实现，比如如下代码：</p>

<pre class="javascript"><code class="javascript">function copy(source){
    var result = {};
    var item;
    for(item in source) {
        result[item] = source[item];
    }
    return result;
}
var backup = copy(source);</code></pre>

<p>可修改为：</p>

<pre class="javascript"><code class="javascript">function copy(source){
    this.property1 = source.property1;
    this.property2 = source.property2;
    this.property3 = source.property3;
    //...
}
var backup = new copy(source);</code></pre>

<h3 id="_14">字面量代替构造函数</h3>

<p>JavaScript可以通过字面量来构造对象，比如通过<code>[]</code>构造一个数组，<code>{}</code>构造一个对象，<code>/regexp/</code>构造一个正则表达式，我们应当尽力使用字面量来构造对象，因为字面量是引擎直接解释执行的，而如果使用构造函数的话，需要调用一个内部构造器，所以字面量略微要快一点点。</p>

<h2 id="ajax">缓存AJAX</h2>

<p>曾经听过一个访问时间比较（当然不精确）：</p>

<ul>
<li>cpu cache ≈ 100 * 寄存器</li>

<li>内存 ≈ 100 * cpu cache</li>

<li>外存 ≈ 100 * 内存</li>

<li>网络 ≈ 100 * 外存</li>
</ul>

<p>可看到访问网络资源是相当慢的，而AJAX就是JavaScript访问网络资源的方式，所以对一些AJAX结果进行缓存，可以大大减少响应时间。那么如何缓存AJAX结果呢</p>

<h3 id="_15">函数缓存</h3>

<p>我们可以使用前面缓存复杂计算函数结果的方式进行缓存，通过在函数对象上构造cache对象，原理一样，这里略过。这种方式是精确到函数，而不精确到请求</p>

<h3 id="_16">本地缓存</h3>

<p>HTML5提供了本地缓存sessionStorage和localStorage，区别就是前者在浏览器关闭后会自动释放，而后者则是永久的，不会被释放。它提供的缓存大小以MB为单位，比cookie（4KB）要大得多，所以我们可以根据AJAX数据的存活时间来判断是存放在sessionStorage还是localStorage当中，在这里以存储到sessionStorage中为例(localStorage只需把第一行的<code>window.sessionStorage</code>修改为<code>window.localStorage</code>)：</p>

<pre class="javascript"><code class="javascript">function(data, url, type, callback){
    var storage = window.sessionStorage;
    var key = JSON.stringify({
        url : url,
        type : type,
        data : data
    });
    var result = storage.getItem(key);
    var xhr;
    if (result) {
        callback.call(null, result);
    } else {
        xhr.onreadystatechange = function(){
            if(xhr.readyState === 4){
                if(xhr.status === 200){
                    storage.setItem(key, xhr.responseText);
                    callback.call(null, xhr.responseText);
                } else {
                }
            }
        };
        xhr.open(type, url, async);
        xhr.send(data);
    }
};</code></pre>

<h2 id="_17">使用布尔表达式的短路</h2>

<p>在很多语言中，如果bool表达式的值已经能通过前面的条件确定，那么后面的判断条件将不再会执行，比如如下代码</p>

<pre class="javascript"><code class="javascript">function calCondition(params) {
    var result;
    //do lots of work
    return !!result;
}

if(otherCondition &amp;&amp; calCondition(someParams)) {
    console.log(true);
} else {
    console.log(false);
}</code></pre>

<p>这里首先会计算<code>otherCondition</code>的值，如果它为false，那么整个正则表达式就为false了，后续的需要消耗大量时间的<code>calCondition()</code>函数就不会被调用和计算了，节省了时间</p>

<h2 id="_18">使用原生方法</h2>

<p>在JavaScript中，大多数原生方法是使用C++编写的，比js写的方法要快得多，所以尽量使用诸如<code>Math</code>之类的原生对象和方法</p>

<h2 id="_19">字符串拼接</h2>

<p>在IE和FF下，使用直接<code>+=</code>的方式或是<code>+</code>的方式进行字符串拼接，将会很慢。我们可以通过Array的<code>join()</code>方法进行字符串拼接。不过并不是所有浏览器都是这样，现在很多浏览器使用<code>+=</code>比join()方法还要快</p>

<h2 id="web_worker">使用web worker</h2>

<p>web worker是HTML5提出的一项新技术，通过多线程的方式为JavaScript提供并行计算的能力，通过message的方式进行相互之间的信息传递，我还没有仔细研究过</p>

<h2 id="javascript">JavaScript文件的优化</h2>

<h3 id="cdn">使用CDN</h3>

<p>在编写JavaScript代码中，我们经常会使用库（jQuery等等），这些JS库通常不会对其进行更改，我们可以将这些库文件放在CDN（内容分发网络上），这样能大大减少响应时间</p>

<h3 id="javascript_2">压缩与合并JavaScript文件</h3>

<p>在网络中传输JS文件，文件越长，需要的时间越多。所以在上线前，通常都会对JS文件进行压缩，去掉其中的注释、回车、不必要的空格等多余内容，如果通过uglify的算法，还可以缩减变量名和函数名，从而将JS代码压缩，节约传输时的带宽。另外经常也会将JavaScript代码合并，使所有代码在一个文件之中，这样就能够减少HTTP的请求次数。合并的原理和sprite技术相同</p>

<h3 id="application_cache">使用Application Cache缓存</h3>

<p>这个在之前的文章<a href="http://skyinlayer.com/blog/2014/02/20/application-cache/">前端性能优化（Application Cache篇）</a>中已有描述，就不赘述了</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/25/performance-2</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（DOM操作篇） ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/25/performance-1</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 25 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="dom">缓存DOM对象</h2>

<p>JavaScript的DOM操作可以说是JavaScript最重要的功能，我们经常要根据用户的操作来动态的增加和删除元素，或是通过AJAX返回的数据动态生成元素。比如我们获得了一个很多元素的数组<code>data[]</code>，需要将其每个值生成一个li元素插入到一个id为container的ul元素中，最简单（最慢）的方式是：</p>

<pre class="javascript"><code class="javascript">var liNode, i, m;
for (i = 0, m = data.length; i &lt; m; i++) {
    liNode = document.createElement(&quot;li&quot;);
    liNode.innerText = data[i];
    document.getElementById(&quot;container&quot;).appendChild(liNode);
}</code></pre>

<p>这里每一次循环都会去查找id为container的元素，效率自然非常低，所以我们需要将元素在循环前查询完毕，在循环中仅仅是引用就行了，修改代码为：</p>

<pre class="javascript"><code class="javascript">var ulNode = document.getElementById(&quot;container&quot;);
var liNode, i, m;
for (i = 0, m = data.length; i &lt; m; i++) {
    liNode = document.createElement(&quot;li&quot;);
    liNode.innerText = data[i];
    ulNode.appendChild(liNode);
}</code></pre>

<p>缓存DOM对象的方式也经常被用在元素的查找中，查找元素应该是DOM操作中最频繁的操作了，其效率优化也是大头。在一般情况下，我们会根据需要，将一些频繁被查找的元素缓存起来，在查找它或查找它的子孙元素时，以它为起点进行查找，就能提高查找效率了。</p>

<h2 id="">在内存中操作元素</h2>

<p>由于DOM操作会导致浏览器的回流，回流需要花费大量的时间进行样式计算和节点重绘与渲染，所以应当尽量减少回流次数。一种可靠的方法就是加入元素时不要修改页面上已经存在的元素，而是在内存中的节点进行大量的操作，最后再一并将修改运用到页面上。DOM操作本身提供一个创建内存节点片段的功能:<code>document.createDocumentFragment()</code>，我们可以将其运用于上述代码中：</p>

<pre class="javascript"><code class="javascript">var ulNode = document.getElementById(&quot;container&quot;);
var liNode, i, m;
var fragment = document.createDocumentFragment();
for (i = 0, m = data.length; i &lt; m; i++) {
    liNode = document.createElement(&quot;li&quot;);
    liNode.innerText = data[i];
    fragment.appendChild(liNode);
}
ulNode.appendChild(fragment);</code></pre>

<p>这样就只会触发一次回流，效率会得到很大的提升。如果需要对一个元素进行复杂的操作（删减、添加子节点），那么我们应当先将元素从页面中移除，然后再对其进行操作，或者将其复制一个（<code>cloneNode()</code>），在内存中进行操作后再替换原来的节点</p>

<h2 id="dom_2">一次性DOM节点生成</h2>

<p>在这里我们每次都需要生成节点（<code>document.createElement(&quot;li&quot;)</code>），然后将其加入到内存片段中，我们可以通过<code>innerHTML</code>属性来一次性生成节点，具体的思路就是使用字符串拼接的方式，先生成相应的HTML字符串，最后一次性写入到ul的innerHTML中。修改代码为：</p>

<pre class="javascript"><code class="javascript">var ulNode = document.getElementById(&quot;container&quot;);
var fragmentHtml = &quot;&quot;, i, m;
for (i = 0, m = data.length; i &lt; m; i++) {
    fragmentHtml += &quot;&lt;li&gt;&quot; + data[i] + &quot;&lt;/li&gt;&quot;;
}
ulNode.innerHTML = fragmentHtml;</code></pre>

<p>这样效率也会有提升，不过手动拼写字符串是相当麻烦的一件事</p>

<h2 id="_2">通过类修改样式</h2>

<p>有时候我们需要通过JavaScript给元素增加样式，比如如下代码：</p>

<pre class="javascript"><code class="javascript">element.style.fontWeight = &#39;bold&#39;;
element.style.backgroundImage = &#39;url(back.gif)&#39;;
element.style.backgroundColor = &#39;white&#39;;
element.style.color = &#39;white&#39;;
//...</code></pre>

<p>这样效率很低，每次修改style属性后都会触发元素的重绘，如果修改了的属性涉及大小和位置，将会导致回流。所以我们应当尽量避免多次为一个元素设置style属性，应当通过给其添加新的CSS类，来修改其CSS</p>

<pre class="css21"><code class="css21">.element {
    background-image: url(back.gif);
    background-color: #fff;
    color: #fff;
    font-weight: &#39;bold&#39;;
    /*...*/
}</code></pre>

<pre class="javascript"><code class="javascript">element.className += &quot; element&quot;;</code></pre>

<h2 id="_3">通过事件代理批量操作事件</h2>

<p>还是之前那个ul和添加li，如果我们需要给每个li都绑定一个click事件，就可能写出类似如下代码：</p>

<pre class="javascript"><code class="javascript">var ulNode = document.getElementById(&quot;container&quot;);
var fragment = document.createDocumentFragment();
var liNode, i, m;
var liFnCb = function(evt){
    //do something
};
for (i = 0, m = data.length; i &lt; m; i++) {
    liNode = document.createElement(&quot;li&quot;);
    liNode.innerText = data[i];
    liNode.addEventListener(&quot;click&quot;, liFnCb, false);
    fragment.appendChild(liNode);
}
ulNode.appendChild(fragment);</code></pre>

<p>这里每个li元素都需要执行一次<code>addEventListener()</code>方法，如果li元素数量一多，就会降低效率。所以我们可以通过事件代理的方式，将事件绑定在ul上，然后通过<code>event.target</code>来确定被点击的元素是否是li元素，同时我们也可以使用<code>innerHTML</code>属性一次性创建节点了，修改代码为：</p>

<pre class="javascript"><code class="javascript">var ulNode = document.getElementById(&quot;container&quot;);
var fragmentHtml = &quot;&quot;, i, m;
var liFnCb = function(evt){
    //do something
};
for (i = 0, m = data.length; i &lt; m; i++) {
    fragmentHtml += &quot;&lt;li&gt;&quot; + data[i] + &quot;&lt;/li&gt;&quot;;
}
ulNode.innerHTML = fragmentHtml;
ulNode.addEventListener(&quot;click&quot;, function(evt){
    if(evt.target.tagName.toLowerCase() === &#39;li&#39;) {
        liFnCb.call(evt.target, evt);
    }
}, false);</code></pre>

<p>这样事件绑定的代码就只要执行一次，可以监听所有li元素的事件了。当然如果需要移除事件回调函数，我们也不需要循环遍历所有的li元素，只需要移除ul元素上的事件处理就行了</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/25/performance-1</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端面试题（26-35） ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/24/js-interview-3</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 24 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">第二十六题</h2>

<p>简述一下什么是JSONP？它与AJAX有什么不同？</p>

<h3 id="jsonp">JSONP是什么</h3>

<p>JSONP看似和JSON很像，但实际上完全不同，JSON是一种数据交换格式，而JSONP则是一种非官方跨域数据交互协议。由于在页面中，Ajax直接请求存在跨域无权限访问的问题，但使用拥有<code>src</code>属性的标签（<code>&lt;script&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;iframe&gt;</code>）能不受跨域影响，所以一种比较普遍的方式就是通过<code>&lt;script&gt;</code>标签包裹可执行的JavaScript代码，代码内部包含请求所需要的数据和请求响应后需要被触发的回调函数。为了便于客户端使用数据，逐渐就形成了JSONP。它的一个要点就是允许用户传递一个回调函数的参数给服务端，然后服务端将JSON数据包裹在这个回调函数中，这样客户端就可以随意定制自己的函数来自动处理返回的数据了</p>

<h3 id="jsonp_2">简单的JSONP实现</h3>

<p>一个简单的实现：</p>

<pre class="javascript"><code class="javascript">function getComments(data){
    console.log(data);
}

function getJSON(url){
    var script = document.createElement(&#39;script&#39;);
    script.setAttribute(&#39;src&#39;, url);
    document.head.appendChild(script);
}

getJSON(&quot;http://api.duoshuo.com/threads/counts.jsonp?short_name=skyinlayer&amp;threads=/blog/2014/03/20/js-interview-2&amp;callback=getComments&quot;);</code></pre>

<p>这里通过JSONP去获取我在多说中的一篇文章下的所有评论，并通过<code>getComments()</code>方法显示出来，由于JSONP返回的数据一定是一段可执行的JavaScript代码，所以通过将其包裹在<code>&lt;script&gt;</code>标签中，在获取后执行。可以看一下获取到的实际内容：</p>

<pre class="javascript"><code class="javascript">getComments({&quot;response&quot;:{&quot;\/blog\/2014\/03\/20\/js-interview-2&quot;:{&quot;thread_id&quot;:&quot;1158950126861942862&quot;,&quot;channel_key&quot;:null,&quot;thread_key&quot;:&quot;\/blog\/2014\/03\/20\/js-interview-2&quot;,&quot;comments&quot;:0,&quot;reposts&quot;:0,&quot;likes&quot;:0,&quot;weibo_reposts&quot;:0,&quot;qqt_reposts&quot;:0}},&quot;options&quot;:{&quot;comments_zero&quot;:&quot;暂无评论&quot;,&quot;comments_one&quot;:&quot;1&quot;,&quot;comments_multiple&quot;:&quot;{num}&quot;},&quot;code&quot;:0});</code></pre>

<p>不是很好看，格式化一下：</p>

<pre class="javascript"><code class="javascript">getComments({
    &quot;response&quot;: {
        &quot;\/blog\/2014\/03\/20\/js-interview-2&quot;: {
            &quot;thread_id&quot;: &quot;1158950126861942862&quot;,
            &quot;channel_key&quot;: null,
            &quot;thread_key&quot;: &quot;\/blog\/2014\/03\/20\/js-interview-2&quot;,
            &quot;comments&quot;: 0,
            &quot;reposts&quot;: 0,
            &quot;likes&quot;: 0,
            &quot;weibo_reposts&quot;: 0,
            &quot;qqt_reposts&quot;: 0
        }
    },
    &quot;options&quot;: {
        &quot;comments_zero&quot;: &quot;暂无评论&quot;,
        &quot;comments_one&quot;: &quot;1&quot;,
        &quot;comments_multiple&quot;: &quot;{num}&quot;
    },
    &quot;code&quot;: 0
});</code></pre>

<p>这样就一目了然了，其实JSONP返回的就是一个函数调用，具体调用的函数名称就是我们传递给服务器的callback方法，由于我们自己定义了处理函数，只需要将数据作为参数，调用这个函数就行了</p>

<h3 id="jqueryjsonp">jQuery中的JSONP</h3>

<p>jQuery中可以使用<code>.getJSON()</code>方法来使用JSONP，如果在url中出现了类似<code>callback=?</code>字段，jQuery将会使用JSONP的方式进行处理</p>

<p>jQuery还提供了<code>.ajax</code>方法，将其<code>dataType</code>设置成<code>jsonp</code>就能按照JSONP方式获取数据，但实际上JSONP和ajax是两码事，jQuery只是为了方便使用将其包裹在一起，这也是很多人（包括我）误以为JSONP就是Ajax的原因</p>

<p>jQuery的JSONP实现机制一样，不过它做了一层封装，生成了一个随机的函数名进行JSONP请求，生成的JSONP回调函数名称大致如下<code>jQuery200001010612421669066_1395458842940</code>,它内部会定义一个同名函数，在其内部调用我们传给jQuery的回调函数</p>

<h2 id="_2">第二十七题</h2>

<p>JavaScript中的null、undefined、undeclared的区别</p>

<p>解答：首先需要明确的是，<code>null</code>、<code>undefined</code>是JavaScript中的两个值类型，而<code>undeclared</code>则是语法错误，表明变量未定义。<code>typeof null</code>的值是<code>&#39;object&#39;</code>，这也就说明了null的意思是变量是一个不存在的对象（但它还是对象），而undefined则代表着变量已经声明，但未赋值</p>

<h2 id="_3">第二十八题</h2>

<p>实现一个如下的数组复制方法：<code>[1,2,3,4,5].duplicator()</code>，返回结果<code>[1,2,3,4,5,1,2,3,4,5]</code></p>

<p>解答： 这题看似很简单，但是数组内部的元素并没有确定，所以完全可能是对象甚至是数组，所以这题实际上是考的深度复制，相当复杂：</p>

<pre class="javascript"><code class="javascript">Object.prototype.deepClone = function() {
    var result = Object.prototype.toString.call(this) === &#39;[object Array]&#39; ? [] : {},
        hasOwnProperty = Object.prototype.hasOwnProperty,
        deepClone = Object.prototype.deepClone,
        item,
        tmp;
    for (item in this) {
        tmp = this[item];
        if(typeof item === &#39;object&#39;){
            result[item] = tmp.deepClone();
        } else {
            result[item] = tmp;
        }
    }
    return result;
};

Array.prototype.duplicator = function(){
    return this.concat(this.deepClone());
};

var arr = [1,2,3,4,5];
console.log(arr.duplicator());</code></pre>

<h2 id="_4">第二十九题</h2>

<p>谈谈你对Web标准的理解</p>

<p>参考资料： <a href="http://www.alibuybuy.com/posts/55190.html">浅谈web标准、可用性、可访问性</a></p>

<h3 id="web">什么是Web标准</h3>

<p>Web标准不是一个标准，而是一系列标准的集合。网页主要由三部分组成：结构、表现和行为。对应的标准也分为三个方面：结构化标准语言（XHTML、XML），表现标准语言（CSS），行为标准主要包括对象模型（W3C DOM）、ECMAScript等</p>

<h3 id="web_2">为什么要遵循Web标准</h3>

<p>遵循Web标准有如下优点：</p>

<ol>
<li>代码的效率：在HTML文件中使用最精简的代码，而把样式也页面布局信息包含进CSS文件中。放在服务器上的文件会变小，下载文件需要时间短。同时CSS文件支持缓存，加载速度更快</li>

<li>易于维护：页面的样式和布局信息保存在单独的CSS文件中，可在多个页面中引入相同的CSS文件达到网站的一致性，同时需要修改时也仅仅需要修改单独的CSS文件中内容，更加易于维护</li>

<li>可访问性：对于那些视力受损（盲人、色盲、色弱等等）的用户，通过屏幕阅读器使用键盘命令将网页的内容读给他们听。以语义化的HTML（结构和表现相分离的HTML）编写的网页文件，就可以让此类用户更容易导航，且网页文件中的总要信息也更有可能被这些用户找到</li>

<li>设备兼容性：纯HTML，无附加样式信息，可以针对具有不同特点的设备而被重新格式胡，只需要引入另外一套样式表即可。同时CSS本身也可以让你为不同的呈现方式和媒体类型规定不同而样式表</li>

<li>网络爬虫/搜索引擎：搜索引擎使用“爬虫”，解析网页。语义化的HTML能更加快速的被解析，从而知道哪些才是重要的内容，会极大的影响网页在搜索结果中排名</li>
</ol>

<h2 id="_5">第三十题</h2>

<p>简述XMLHttpRequest对象，并说明其如何使用</p>

<h3 id="xmlhttprequst">什么是XMLHttpRequst对象</h3>

<p>XMLHttpRequest对象是Ajax的核心，用于在后台与服务器中交换数据，使用它能够：</p>

<ol>
<li>在不重新加载页面的情况下更新网页</li>

<li>在页面已加载后从服务器请求数据</li>

<li>在页面已加载后从服务器接收数据</li>

<li>在后台服务器发送数据</li>
</ol>

<p>需要注意的是所有现代浏览器都支持XMLHttpRequest，但它并不再W3C标准的定义之中</p>

<h3 id="_6">如何使用</h3>

<pre class="javascript"><code class="javascript">//创建一个XMLHttpRequest对象
var xhr = new XMLHttpRequest();
//定义请求方法
var type = &quot;GET&quot;;
//定义获取数据的URL
var url = &quot;/someAction&quot;
//定义异步执行还是同步执行
var aysnc = true;
//定义需要发送的数据
var data = JSON.stringify({
    param : &quot;someProperty&quot;
});
//确定XMLHttpRequest状态变换时的回调函数
xhr.onreadystatechange = function(){
    if(xhr.readyState === 4){
        //loaded
        if(xhr.status === 200){
            //200 成功
        } else {
            //失败
        }
    }
};
//确定XMLHttpRequest执行的参数
xhr.open(type, url, async);
//发送请求
xhr.send(data);</code></pre>

<h2 id="_7">第三十一题</h2>

<p>简述网页的可用性、可访问性</p>

<h3 id="_8">什么是可用性？</h3>

<p>可用性（Usability）指的是产品对用户来说有效、易学、高效、好记、少错和令人满意程度，是交互式产品额重要质量指标，是产品竞争力的核心</p>

<h3 id="_9">什么是可访问性？</h3>

<p>可访问性（Acessibility）指的是：Web内容对于残障用户的可阅读和可理解性。同时提升可访问性也可以让普通用户更容易理解Web内容</p>

<h2 id="_10">第三十二题</h2>

<p>DOM操作，如何添加、移除、移动、复制、创建和查找节点</p>

<p>创建节点：</p>

<ol>
<li>createDocumentFragment()</li>

<li>createElement()</li>

<li>createTextNode()</li>

<li>cloneNode() （可传入bool型参数表明是否复制所有子节点）</li>
</ol>

<p>添加： 1. appendChild()</p>

<p>移除： 1. removeChild()</p>

<p>替换： 1. replaceChild()</p>

<p>插入： 1. insertBefore()将新元素做为父元素的最后一个子元素进行添加</p>

<p>查找：</p>

<ol>
<li>getElementsByTagName()：通过标签查找，返回一个类似数组的Object对象</li>

<li>getElementsByName(): 通过Name属性查找，返回一个类似数组的Object对象</li>

<li>getElementById()：通过元素id查找，返回一个DOM对象，否则返回null</li>
</ol>

<p>修改：</p>

<ol>
<li>innerHTML改变节点内部结构</li>

<li>style.property改变样式</li>
</ol>

<p>遍历： 1. childNodes 获取所有子元素的列表</p>

<p>属性</p>

<ol>
<li>getAttribute()</li>

<li>setAttribute()</li>
</ol>

<h2 id="_11">第三十三题</h2>

<p>简介HMTL5中的语义元素</p>

<h3 id="_12">语义化元素的优点</h3>

<ol>
<li>使网页结构更清晰</li>

<li>使代码可读性增强，便于修改和维护</li>

<li>可访问性</li>

<li>搜索引擎优化</li>
</ol>

<h3 id="article">article</h3>

<p>代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。article通常有自己的标题（一般放在一个header元素里面），有时候还会有自己的脚注（放在其footer元素中）</p>

<h3 id="section">section</h3>

<p>用于对网站或应用程序中页面上的内容进行分块。一个section元素通常由内容及其标题组成。如果一个容器只是为了被定义样式或通过脚本定义行为时，建议使用div。需要给section增加一个标题，不建议给没有标题的内容区块使用section元素</p>

<p>不要将secion和article混淆使用，article元素可以看成一种特殊种类的section元素，它比section元素更强调独立性。即section元素强调分段或分块，而artcle强调独立性，具体来说，如果一块内容相对来说比较独立、完整的时候，应该使用article，如果想将一块内容分成几段，应该使用section</p>

<h3 id="nav">nav</h3>

<p>一个可以用作页面导航的链接组，其中的导航元素链接到其他页面或当前页面的其他部分。一般只将主要的、基本的链接组元素放进nav元素即可</p>

<h3 id="aside">aside</h3>

<p>用来表示当前页面或文章的附属信息部分，它可以包含当前页面或主要内容相关的引用、侧边栏、广告、导航条，以及其他类似的有别于主要内容的部分。它主要由两种用法</p>

<ol>
<li>被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的参考资料、名词解释等等</li>

<li>在article元素之外使用，作为页面或站点全局的附属信息部分</li>
</ol>

<h3 id="time">time与微格式</h3>

<p>微格式，是一个利用HTML的class属性来网页添加附加信息的方法</p>

<p>time用来无歧义地、明确地对机器的日期和时间进行编码，并且让人易读的方式来展现他，它有一个pubdate可选属性（boolean值），用于表示这个time元素代表了文章（存在于article元素中时）或整个网页的发布日期</p>

<h3 id="header">header</h3>

<p>一种具有引导和导航作用的结构元素，通常用来防止整个页面或页面内的一个内容区块的标题，但也可以包含其他内容。一个网页并未限制header元素的个数，可以拥有多个，可以为每个内容区块（article、section）增加一个header元素。HTML5中，一个header元素至少要包含一个heading元素（h1~h6），也可以包括一个hgroup元素，最新的W3C HTML5标准，它还可以包括nav元素</p>

<h3 id="hgroup">hgroup</h3>

<p>将标题及其子标题进行分组的元素，通常会将h1~h6元素进行分组</p>

<h3 id="footer">footer</h3>

<p>作为其上层父级内容区块或是一个根区块的脚注，通常包括其相关区块的脚注信息。页面中也未限制footer元素的个数，也可以为article元素或section元素添加footer元素</p>

<h3 id="address">address</h3>

<p>用来呈现联系信息，包括文档作者或文档维护者的名字、他们的网站链接、电子邮箱、真实地址、电话号码等</p>

<h3 id="_13">兼容性</h3>

<p>也可以通过js插件的形式为不支持HTML5语义化元素的浏览器添加HTML5元素支持，一般是使用<code>html5shiv</code></p>

<pre class="xml"><code class="xml">&lt;!--[if lt IE 9]&gt;
&lt;script src=&quot;dist/html5shiv.js&quot;&gt;&lt;/script&gt;
&lt;![endif]--&gt;</code></pre>

<h2 id="_14">第三十四题</h2>

<p>什么是事件的冒泡？如何阻止冒泡？如何阻止事件的默认行为？什么是事件代理？</p>

<h3 id="_15">事件的冒泡</h3>

<p>在某个元素上触发某类事件，这个事件会向元素的父级元素传播，由里到外，直至它被处理或者它到达了元素层次的最顶层</p>

<p>另外关于事件的几个需要注意的地方：</p>

<ol>
<li>事件冒泡只是事件处理方式的一种，一共有两种事件处理的方式 1) 从里到外的冒泡型事件 2) 从外到里的捕获型事件</li>

<li>不是所有时间都能冒泡，有很多事件不冒泡：<code>blur</code>、<code>focus</code>、<code>load</code>、<code>unload</code></li>

<li>阻止冒泡不能阻止对象的默认行为</li>
</ol>

<h3 id="_16">阻止冒泡</h3>

<p>可以使用<code>event.stopPropagation()</code>来阻止冒泡</p>

<p>比如如下HTML结构：</p>

<pre class="xml"><code class="xml">&lt;div id=&quot;parent&quot;&gt;
    &lt;p&gt;这是父元素&lt;/p&gt;
    &lt;div id=&quot;child&quot;&gt;这是子元素&lt;/div&gt;
&lt;/div&gt;</code></pre>

<p>为其添加事件处理器：</p>

<pre class="javascript"><code class="javascript">var parent = document.getElementById(&quot;parent&quot;);
var child = document.getElementById(&quot;child&quot;);
var clickHandler = function(evt){
    console.log(this.id + &quot; is clicked&quot;);
};
//采用冒泡方式处理事件，如果要采用捕获方式处理，将第三个参数改为true
parent.addEventListener(&quot;click&quot;, clickHandler, false);
child.addEventListener(&quot;click&quot;, clickHandler, false);</code></pre>

<p>点击子元素后可以看到console框中出现如下结果</p>

<p><img src="http://skyinlayer.com/images/fe_interview/6.png" alt="console中显示parent元素和child元素都被点击了" /></p>

<p>修改处理函数，添加<code>stopPropagaton()</code>方法：</p>

<pre class="javascript"><code class="javascript">var clickHandler = function(evt){
    console.log(this.id + &quot; is clicked&quot;);
    evt.stopPropagation();
};</code></pre>

<p>再次点击子元素，console中将是如下结果</p>

<p><img src="http://skyinlayer.com/images/fe_interview/7.png" alt="console中仅显示child元素都被点击了" /></p>

<h3 id="_17">阻止事件的默认行为</h3>

<p>在平常我们经常会遇到一个表单中有个提交按钮（type为submit），用于提交表单，但是我们不希望它直接提交，而是希望将其元素值提取之后进行ajax交互，于是就需要屏蔽提交按钮默认行为</p>

<p>我们可以使用<code>event.preventDefault()</code>来阻止元素事件的默认行为</p>

<h3 id="_18">事件代理</h3>

<p>如果我们有一个ul元素，其中有100个li元素，每个点击都会触发一个相同的点击事件，那么我们可能需要为这100个li元素各绑定一个回调函数，费时费力费内存。由于事件的冒泡机制，我们可以通过事件代理的方式，只在ul元素上绑定一个click事件，然后确定其event.target对象是否是li元素就行了,如下例所示：</p>

<p>有一个ul元素，其中5个li元素：</p>

<pre class="xml"><code class="xml">&lt;ul id=&quot;ul&quot;&gt;
   &lt;li value=&#39;1&#39;&gt;1&lt;/li&gt;
   &lt;li value=&#39;2&#39;&gt;2&lt;/li&gt;
   &lt;li value=&#39;3&#39;&gt;3&lt;/li&gt;
   &lt;li value=&#39;4&#39;&gt;4&lt;/li&gt;
   &lt;li value=&#39;5&#39;&gt;5&lt;/li&gt;
&lt;/ul&gt;</code></pre>

<p>为ul元素绑定一个click事件回调函数来处理所有li元素的click事件</p>

<pre class="javascript"><code class="javascript">var ul = document.getElementById(&quot;ul&quot;);
ul.addEventListener(&quot;click&quot;, function(evt){
    if(evt.target.tagName === &#39;LI&#39;){
        console.log(&quot;li &quot; + evt.target.getAttribute(&quot;value&quot;) + &quot; is clicked&quot;);
    }
}, false);</code></pre>

<p>点击各个li查看效果：</p>

<p><img src="http://skyinlayer.com/images/fe_interview/8.png" alt="各个li元素被点击时都会触发事件并显示哪个li元素被点击" /></p>

<p>这样我们就可以通过为ul增加一个事件代理来处理所有li元素的点击事件了。同理，我们可以使用事件代理让一个元素下的不同子元素共享一个事件处理逻辑</p>

<h2 id="_19">第三十五题</h2>

<p>简述伪类和伪元素有什么异同，并写出几个常见的伪类和伪元素</p>

<p>相当多的人将伪类和伪元素相混淆</p>

<h3 id="_20">相同点</h3>

<p>他们的共同点在于，他们都属于CSS选择器的范畴，CSS引入伪类和伪元素的概念是为了实现基于文档树之外的信息的格式化造成伪类和伪元素混淆的最基本原因，就是他们俩可以使用相同的语法进行添加：</p>

<pre class="css21"><code class="css21">.someclass:before {}
.someclass:hover {}</code></pre>

<h3 id="_21">不同点</h3>

<ol>
<li>伪类时根据元素所具有的不同状态来添加相应的样式，而伪元素则是对元素中特定的内容添加相应的样式</li>

<li>伪元素和伪类使用语法可以不同，伪元素可以使用<code>::before</code>这样的双冒号来使用（当然使用单冒号也可以），而伪类不行</li>

<li>伪元素和伪类进行选择器优先级计算时不同，伪元素与标签选择器的优先级为0001，而伪类的优先级与类选择器的优先级一样为0010</li>
</ol>

<h3 id="_22">一些例子</h3>

<p><code>before</code>,<code>after</code>,<code>first-line</code>,<code>first-letter</code>都是伪元素，而像<code>link</code>,<code>visited</code>,<code>hover</code>,<code>active</code>,<code>first-child</code>,<code>lang</code>,<code>focus</code>等都是伪类</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/24/js-interview-3</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端面试题（15-25） ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/20/js-interview-2</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 20 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">第十五题</h2>

<p>绘制一个如图红色十字架，方块长150px，宽50px：</p>

<p><img src="http://skyinlayer.com/images/fe_interview/4.png" alt="一个长为150px大小的红十字架" /></p>

<p>要求：</p>

<ol>
<li>使用2个div完成</li>

<li>使用3个div完成</li>

<li>使用5个div完成</li>
</ol>

<h3 id="div">两个div实现：</h3>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='500' src='http://jsfiddle.net/skyinlayer/Nak3p/embedded/result,html,css' width='100%'>&nbsp;</iframe>
<h3 id="div_2">三个div实现</h3>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='500' src='http://jsfiddle.net/skyinlayer/Nak3p/1/embedded/result,html,css' width='100%'>&nbsp;</iframe>
<h3 id="5div">5个div实现</h3>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='500' src='http://jsfiddle.net/skyinlayer/Nak3p/2/embedded/result,html,css' width='100%'>&nbsp;</iframe>
<h3 id="div_3">（附送）一个div实现</h3>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='500' src='http://jsfiddle.net/skyinlayer/Nak3p/3/embedded/result,html,css' width='100%'>&nbsp;</iframe>
<h2 id="_2">第十六题</h2>

<p>请将优化如下CSS属性：</p>

<h3 id="border">border</h3>

<pre class="css21"><code class="css21">border-width: 1px;
border-color: #000;
border-style: solid;</code></pre>

<h3 id="background">background</h3>

<pre class="css21"><code class="css21">background-position:0 0;
background-repeat:no-repeat;
background-attachment:fixed;
background-color:#f00;
background-image:url(background.gif);</code></pre>

<h3 id="font">font</h3>

<pre class="css21"><code class="css21">font-style:italic;
font-family:&quot;Lucida Grande&quot;,sans-serif;
font-size:1em;
font-weight:bold;
font-variant:small-caps;
line-height:140%;</code></pre>

<h3 id="liststyle">list-style</h3>

<pre class="css21"><code class="css21">list-style-position:inside;
list-style-type:square;
list-style-image:url(image.gif);</code></pre>

<h3 id="color">color</h3>

<pre class="css21"><code class="css21">color:#336699;
color:#ffcc00;</code></pre>

<h3 id="_3">答案</h3>

<p>首先看border的格式：</p>

<pre class="css21"><code class="css21">border：[ border-width ] || [ border-style ] || [ border-color ]</code></pre>

<p>所以答案应该是：</p>

<pre class="css21"><code class="css21">border: 1px solid #000;</code></pre>
<hr />
<p>然后看看background：</p>

<pre class="css21"><code class="css21">background：[ &lt;bg-layer&gt;, ]* &lt;final-bg-layer&gt; 

&lt;bg-layer&gt; = [ background-image ] || [ background-position ] [ / background-size ]? || [ background-repeat ] || [ background-attachment ] || [ [ background-origin ] || [ background-clip ] ]{1,2}

&lt;final-bg-layer&gt; = [ background-color ] || [ background-image ] || [ background-position ] [ / background-size ]? || [ background-repeat ] || [ background-attachment ] || [ [ background-origin ] || [ background-clip ] ]{1,2}</code></pre>

<p>我去，这么长…可以看到如果是多重背景，除了最后一组规则以外，其他的都没有背景色，其他属性的排列顺序是：</p>

<ol>
<li>background-image</li>

<li>background-position/background-size</li>

<li>background-repeat</li>

<li>background-attachment</li>

<li>background-origin background-clip</li>
</ol>

<p>这样，可以得到答案为</p>

<pre class="css21"><code class="css21">background: #f00 url(background.gif) 0 0 no-repeat fixed;</code></pre>
<hr />
<p>然后看看font：</p>

<pre class="css21"><code class="css21">font：[ [ &lt;font-style&gt; || &lt;font-variant&gt; || &lt;font-weight&gt; ]? &lt;font-size&gt; [ / &lt;line-height&gt; ]? &lt;font-family&gt; ] | caption | icon | menu | message-box | small-caption | status-bar</code></pre>

<p>可以看到其排列顺序：</p>

<ol>
<li>font-style:</li>

<li>font-variant</li>

<li>font-weight</li>

<li>font-size/line-height</li>

<li>font-family</li>

<li>…</li>
</ol>

<p>所以可以得到的答案为：</p>

<pre class="css21"><code class="css21">font: italic bold small-caps 1em/140% &quot;Lucida Grande&quot;,sans-serif;</code></pre>
<hr />
<p>看看list-style：</p>

<pre class="css21"><code class="css21">list-style：[ list-style-image ] || [ list-style-position ] || [ list-style-type ]</code></pre>

<p>这个简单很多，而且没有什么特殊规则，所以答案是：</p>

<pre class="css21"><code class="css21">list-style: url(image.gif) inside square;</code></pre>
<hr />
<p>最后看看color，color只有当使用hex表示且形式是<code>#aabbcc</code>时可以简写，所以答案是：</p>

<pre class="css21"><code class="css21">color:#369;
color:#fc0;</code></pre>

<h2 id="_4">第十七题</h2>

<p>如何设置CSS强制不换行/不截断单词换行/截断单词换行?</p>

<p>首先明确几个相关属性：</p>

<ol>
<li>word-break: 设置或检索对象内文本的字内换行行为</li>

<li>word-wrap：设置或检索当内容超过指定容器边界时是否断行</li>

<li>white-space：设置或检索对象内空格的处理方式</li>
</ol>

<h3 id="wordbreak">word-break</h3>

<p>设置或检索对象内文本的字内换行行为</p>

<ol>
<li>normal：依照亚洲语言和非亚洲语言规则，允许在字内换行</li>

<li>keep-all：与所有非亚洲语言的normal相同，对于中文、韩文、日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。</li>

<li>break-all：与亚洲语言的normal相同，允许非亚洲语言在任意字内断开。该值适合包含一些非亚洲文本的亚洲文本，比如使连续的英文字母间断行。</li>
</ol>

<p>chrome、opera不支持keep-all</p>

<h3 id="wordwrap">word-wrap</h3>

<p>设置或检索当内容超过指定容器边界时是否断行</p>

<ol>
<li>normal：允许内容顶开或溢出指定的容器边界</li>

<li>break-word：内容将在边界内换行，如果需要，单词内部允许断行</li>
</ol>

<h3 id="whitespace">white-space</h3>

<p>设置或检索对象内空格的处理方式</p>

<ol>
<li>normal：默认处理方式</li>

<li>用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字超出边界时不换行。可查阅pre对象</li>

<li>强制在同一行内显示所有文本，合并文本间的多余空白，直到文本结束或者遭遇br对象。</li>

<li>用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字碰到边界时发生换行。</li>

<li>保持文本的换行，不保留文字间的空白距离，当文字碰到边界时发生换行。</li>
</ol>

<h3 id="_5">强制不换行</h3>

<pre class="css21"><code class="css21">.no-wrap {
    white-space: nowrap;
}</code></pre>

<h3 id="_6">不截断单词换行</h3>

<pre class="css21"><code class="css21">.wrap {
    white-space: normal;
    word-wrap: break-word;
    word-break: normal;
}</code></pre>

<h3 id="_7">强制英文单词断行</h3>

<pre class="css21"><code class="css21">.wrap-break-word {
    white-space: normal;
    word-wrap: break-wrod;
    word-break: break-all;
}</code></pre>

<h2 id="_8">第十八题</h2>

<p>如果需要给<code>&lt;a&gt;</code>设置伪类，应该按照何种顺序进行设置？</p>

<p>解答：如《CSS禅意花园》中的爱恨原则，使用<code>LoVe/HAte</code>方式来记忆，设置的顺序为：</p>

<ol>
<li>L——link: 适用于未被访问的链接</li>

<li>V——visited：适用于已经访问过的链接</li>

<li>H——hover：适用于光标（鼠标指针）指向一个元素，但还未激活它时</li>

<li>A——active：适用于一个元素被用户激活时</li>
</ol>

<p>如果还需要加入focus，规则则变为<code>LVHFA</code></p>

<h2 id="_9">第十九题</h2>

<p>媒体查询中的<code>only</code>属性是干什么的？</p>

<p>解答：<code>only</code>用来将样式应用于某种特定的媒体类型，可以用来排除不支持媒体查询的浏览器。其实<code>only</code>属性很多时候是用来对支持<code>Media Type</code>但不支持<code>Media Query</code>的设备隐藏样式表的。</p>

<p>其主要有：</p>

<ol>
<li>若设备支持媒体查询（Media Query），正常调用样式，<code>only</code>就当不存在</li>

<li>若设备不支持媒体查询（Media Query），但支持媒体类型（Media Type），样式将不会被调用</li>

<li>如果媒体查询和媒体类型都不支持，样式自然不会被调用</li>
</ol>

<h2 id="_10">第二十题</h2>

<p>HTML中的文档类型是什么？尽可能多的写出文档类型</p>

<p>解答：Web 世界中存在许多不同的文档。只有了解文档的类型，浏览器才能正确地显示文档。</p>

<pre class="xml"><code class="xml">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;</code></pre>

<h2 id="_11">第二十一题</h2>

<p><code>data-</code>属性是干什么的？</p>

<p>解答：HTML5中可以使用<code>data-</code>来为元素添加自定义的合法属性，然后我们可以通过dom节点进行取值,比如如下节点：</p>

<pre class="xml"><code class="xml">&lt;div id=&quot;some-dom&quot; data-first=&quot;asdfasdf&quot; data-second=123 data-third=true&gt;&lt;/div&gt;</code></pre>

<p>然后我们可以通过DOM的<code>dataset</code>属性取到它们：</p>

<pre class="javascript"><code class="javascript">&gt; var div = document.getElementById(&quot;some-dom&quot;);
&gt; var divDataSet = div.dataset;
&gt; console.log(divDataSet);
DOMStringMap {first: &quot;asdfasdf&quot;, second: &quot;123&quot;, third: &quot;true&quot;} </code></pre>

<p>需要注意一点事，所有的值都是字符串类型</p>

<p>当然如果我们使用<code>getAttribute()</code>方法也是同样可行的：</p>

<pre class="javascript"><code class="javascript">&gt; div.getAttribute(&quot;data-first&quot;);
&quot;asdfasdf&quot;</code></pre>

<p>在获得了dataset对象之后，我们可以利用这个对象进行CRUD操作：</p>

<pre class="javascript"><code class="javascript">//修改属性值
&gt; divDataSet.second = 999;
&gt; div.outerHTML
&#39;&lt;div id=&quot;some-dom&quot; data-first=&quot;asdfasdf&quot; data-second=&quot;999&quot; data-third=&quot;true&quot;&gt;&lt;/div&gt;&#39;
//增加新属性
&gt; divDataSet.newProperty = &quot;skyinlayer&quot;;
&gt; div.outerHTML
&#39;&lt;div id=&quot;some-dom&quot; data-first=&quot;asdfasdf&quot; data-second=&quot;999&quot; data-third=&quot;true&quot; data-new-property=&quot;skyinlayer&quot;&gt;&lt;/div&gt;&#39;
//删除属性
&gt; delete divDataSet.first
&gt; div.outerHTML
&#39;&lt;div id=&quot;some-dom&quot; data-second=&quot;999&quot; data-third=&quot;true&quot; data-new-property=&quot;skyinlayer&quot;&gt;&lt;/div&gt;&#39;</code></pre>

<h2 id="_12">第二十二题</h2>

<p>简述一下cookie，sessionStorage，localStorage的区别</p>

<h3 id="cookie">cookie</h3>

<p>标准的客户端浏览器状态保存方式，cookie每次发送请求的时候都会被带回到服务器，从而保证了服务器可以知道浏览器当前的状态，但同时也意味着其容量不能太大，最多不能超过4k</p>

<h3 id="sessionstorage">sessionStorage</h3>

<p>HTML5提供的两种客户端存储数据的新方法（localStorage、sessionStorage）之一，是针对一个session的数据进行存储，有时间限制。sessionStorage数据的存储金特定于某个绘画中，也就是说数据只会保存到浏览器关闭，但浏览器如果是刷新或重新打开页面，数据还是存在的。每在新标签或者新窗口开启一个新页面，都会初始化一个新的会话。Chrome、Safari、Android版的Webkit对其限制是2.5MB，IE8+和Opera限制是5MB</p>

<h3 id="localstroage">localStroage</h3>

<p>HTML5提供了两种客户端存储数据的新方法的另一种，它不是针对session的数据进行存储，而是用于持久化的本地存储，除非主动删除数据，否则数据永远不会过期。它的存储空间比cookie要大得多，大多数桌面浏览器会设置每个来源5MB的限制，Chrome和Safari和Android版的Wekit限制则是2.5MB</p>

<h2 id="_13">第二十三题</h2>

<p>优化以下CSS：</p>

<pre class="css21"><code class="css21">.style {
    margin-top: 4px;
    margin-right: 12px;
    padding: 10px 0px 10px 0px;
    background-color: #ff9800;
    background-image: url(/img/logo.png);
    background-size: 240px 80px;
    border-width: 2px;
    border-style: dashed;
    border-color: #ff8800;
}</code></pre>

<p>答案：</p>

<pre class="css21"><code class="css21">.style {
    margin: 4px 12px 0 0;
    padding: 10px 0;
    background: #ff9800 url(/img/logo.png) 240px 80px;
    border: 2px dashed #f80;
}</code></pre>

<h2 id="_14">第二十四题</h2>

<p>请列举出CSS中用于隐藏元素的两个属性？两者的差异？还有什么其他方式吗？</p>

<p>这题很有意思，之前曾经在禅意花园上看到过类似的隐藏元素方案</p>

<p>首先两个属性，不用说分别是<code>display: none</code>和<code>visibility: hidden</code>,区别就是前者不会在文档流中占据位置，而后者会，如下例所示</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='300' src='http://jsfiddle.net/skyinlayer/b5qPx/embedded/result,css,html' width='100%'>&nbsp;</iframe>
<p>至于还有什么其他方式，禅意花园上的一种方式就是，将元素的<code>width</code>、<code>height</code>属性设置成0（块状元素），这样自然就隐藏了</p>

<p>还有一些比较YD的方法，比如说将其移位到屏幕外</p>

<pre class="css21"><code class="css21">.hide {
    /*这样不会占据空间*/
    position: absolute;
    top: -9999em;
}
.hide {
    /*占据空间*/
    position: relative;
    top: -9999em;
}
.hide {
    /*占据空间，且可以点击*/
    opacity: 0;
}</code></pre>

<p>等等</p>

<p>另外在设置了<code>display: none</code>和<code>visibility: hidden</code>的时候，将图片放在背景中将不会加载图片，而放在<code>&lt;img&gt;</code>标签中将会加载图片：</p>

<p><img src="http://skyinlayer.com/images/fe_interview/5.png" alt="图片加载规则" /></p>

<h2 id="_15">第二十五题</h2>

<p>有两个盒子A、B，B在A盒子中，俩盒子的CSS如下：</p>

<pre class="css21"><code class="css21">#A {
    position: relative;
    width: 500px;
    height: 500px;
    background: green;
}

#B {
    position: absolute;
    max-width: 300px;
    max-height: 300px;
    background-color: blue;
}</code></pre>

<p>请实现B在A中的水平方向和垂直方向居中</p>

<p>解答：这题想简单了以为直接设置负数的<code>margin-top</code>和<code>margin-left</code>就行了，现在发现不是这么回事，因为它给的是<code>max-width</code>和<code>max-height</code>，并不能确定元素当前的大小是多少，而且B元素是绝对定位，所以用内联元素的垂直居中方式也不可能，<code>margin: auto</code>也不行…所以这里的解法应该是通过JavaScript算出当前元素的大小，然后设定相应的负数<code>margin</code></p>

<p>思路确定后就是要获取元素的<code>width</code>和<code>height</code>属性，如果有jQuery的话直接<code>$().width()</code>或<code>$().height()</code>就行了，但是一般情况下笔试都是写原生的JavaScript，所以需要通过原生的方式计算出元素的宽度和高度</p>

<p>也许会想到使用<code>dom.style.height</code>和<code>dom.style.width</code>来获取高度和宽度，但是这样只适合获取内联样式，并不适合获取计算后的样式，所以我们需要通过其他的方法：</p>

<pre class="javascript"><code class="javascript">
var B = document.getElementById(&quot;B&quot;);
var A = document.getElementById(&quot;A&quot;);
var bSize = getComputedSize(B);
B.style.marginTop = &quot;-&quot; + bSize.height/2 + &quot;px&quot;;
B.style.marginLeft = &quot;-&quot; + bSize.width/2 + &quot;px&quot;;
B.style.left = &quot;50%&quot;;
B.style.top = &quot;50%&quot;;

function getComputedSize(dom){
    var size = {},
        tmp;
    if(dom.currentStyle) {
        //IE提供currentStyle查询
        size.height = dom.currentStyle.height;
        size.width = dom.currentStyle.width;
    } else {
        //其他浏览器使用window.getComputedStyle方法
        tmp = window.getComputedStyle(dom, null);
        size.height = tmp.height;
        size.width = tmp.width;
    }
    //删除末尾的px并转换成数字
    size.height = Number(size.height.replace(&quot;px&quot;, &quot;&quot;));
    size.width = Number(size.width.replace(&quot;px&quot;, &quot;&quot;));
    return size;
}</code></pre>

<p>这样就可以了</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/20/js-interview-2</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端面试题（1-14） ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/20/js-interview-1</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 20 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">第一题</h2>

<p>下列关于浏览器对象的说法错误的是：</p>

<ul>
<li>A：location对象相当于IE浏览器中的地址栏，包含关于当前URL地址的信息</li>

<li>B: history对象记录了用户在一个李蓝旗中已经访问过的URLS</li>

<li>C: location对象是window对象的子对象</li>

<li>D：location对象是history对象的父对象</li>
</ul>

<p>这题考查的是location对象和history对象，之前并没有怎么接触过。</p>

<p>答案是D</p>

<h3 id="location">location对象</h3>

<p>location对象里面存放了当前URL的一些信息：</p>

<p><img src="http://skyinlayer.com/images/fe_interview/1.png" alt="localtion对象存放的信息" /></p>

<p>location对象同时window对象和window.document对象的子对象：</p>

<pre class="javascript"><code class="javascript">&gt; window.location === window.document.location
true</code></pre>

<p>我们可以通过修改其href实现跳转</p>

<h3 id="history">history对象</h3>

<p>history对象是window对象的子对象，里面记录了访问历史：</p>

<p><img src="http://skyinlayer.com/images/fe_interview/2.png" alt="history对象存放的信息" /></p>

<p>history与location对象不同的是，其不存在于window.document对象之中</p>

<pre class="javascript"><code class="javascript">&gt; window.document.history
undefined</code></pre>

<p>history对象有三个比较常用的跳转方法：</p>

<ul>
<li>back()：移动到当前页面的在历史记录中的上一个页面</li>

<li>forward()：移动到当前页面在历史记录中的下一个页面</li>

<li>go(n)：接收一个参数n如果参数为正整数或0，移动到当前页面后的第n个页面（0的效果为刷新），如果为负数，移动到当前页面前的第n个页面，超出范围的话将被忽略</li>
</ul>

<h2 id="_2">第二题</h2>

<p>析如下JavaScript代码，请问依次打印什么：</p>

<pre class="javascript"><code class="javascript">console.log(Function instanceof Object);
console.log(Object instanceof Function);
console.log([].constructor === Array.prototype.constructor);
console.log(new Object(1).constructor === new Number(2).constructor);</code></pre>

<p>这题考察了Function、Object以及constructor</p>

<p>首先我们要确定instanceof方法，如A instanceof B，A必须是一个合法的对象，B是一个合法的JavaScript函数。如果函数B在对象A的原型链中被发现，那么instanceof操作符将返回true，否则返回false</p>

<p>第一行<code>console.log(Function instanceof Object);</code>：</p>

<p>由于Function.prototype是一个对象，它的构造函数是Object，所以从原型链上来说，所有的函数顺着原型链查找，最后都会到达Object的构造原型的Object.prototype对象，所以答案为true。</p>

<p>由此我们可以得出另外一个结论，所有的函数instanceof Object的结果，都是true</p>

<pre class="javascript"><code class="javascript">&gt; (function(){}) instanceof Object
true</code></pre>

<p>第二行<code>console.log(Object instanceof Function);</code>：</p>

<p>因为在JavaScript中所有的构造函数（Object、Function、Array）都是函数，而所有函数都是其构造函数（Function）的实例，所以答案也是true</p>

<p>第三行<code>console.log(arr.constructor === Array.prototype.constructor);</code>：</p>

<p>首先我们需要知道constructor的概念，constructor属性始终指向创建当前对象的构造函数。所以很容易得到如下结果:</p>

<pre class="javascript"><code class="javascript">&gt; [].constructor === Array
true</code></pre>

<p>而每个函数都有一个默认的属性prototype，这个prototype的constructor默认指向这个函数：</p>

<pre class="javascript"><code class="javascript">&gt; var SomeType = function(){};
&gt; SomeType.prototype.constructor === SomeType
true</code></pre>

<p>由此可以得知：</p>

<pre class="javascript"><code class="javascript">&gt; [].constructor === Array
true
&gt; Array === Array.prototype.constructor
true
&gt; [].constructor === Array.prototype.constructor
true</code></pre>

<p>当然我们哈有另外一个比较简单的思路，其实Array.prototype这个对象比较特殊，它是集上是个数组:</p>

<pre class="javascript"><code class="javascript">&gt; Array.prototype
[]</code></pre>

<p>这样就相当于比较<code>[].constructor === [].constructor</code>了，结果自然是true</p>

<p>第四行<code>console.log(new Object(1).constructor === new Number(2).constructor);</code>：</p>

<p>说实话我被这个坑了，以为是false，后来发现<code>new Object()</code>方法如果传入一个基础类型或基础类型对象，会自动构造成基础类型对象：</p>

<pre class="javascript"><code class="javascript">&gt; new Object(123) instanceof Number
true
&gt; new Object(&quot;asdf&quot;) instanceof String
true
&gt; new Object(false) instanceof Boolean
true
&gt; typeof new Object(123)
&quot;object&quot;</code></pre>

<p>这样就很好理解了，<code>new Object()</code>如果传入一个数字，将会调用new Number()，其他类似。所以这里答案是true</p>

<h2 id="_3">第三题</h2>

<p>下列JavaScript运行完成后，x的值是多少：</p>

<pre class="javascript"><code class="javascript">var somevar;
var x = somevar === undefined;</code></pre>

<p>这题错了，囧</p>

<p>以往一直使用<code>typeof somevar === &#39;undefined&#39;</code>来检测undefined，这下被坑了</p>

<p>undefined可能出现在如下两种情况之中：</p>

<ol>
<li>变量未定义</li>

<li>定义了变量但未赋值</li>
</ol>

<p>使用<code>typeof somevar === &#39;undefined&#39;</code>进行判断：</p>

<pre class="javascript"><code class="javascript">&gt; typeof somevar === &#39;undefined&#39;
true
&gt; var someothervar;
&gt; typeof someothervar === &#39;undefined&#39;
true</code></pre>

<p>由此可见，这种方法在两种情况下都适用</p>

<p>使用<code>somevar === undefined</code>进行判断：</p>

<pre class="javascript"><code class="javascript">&gt; somevar === undefined
ReferenceError: somevar is not defined
&gt; var someothervar;
&gt; someothervar === undefined
true</code></pre>

<p>我勒个去…也就是说，这种检测方式仅仅适用于第二种情况，所以这题答案是true</p>

<h2 id="_4">第四题</h2>

<pre class="javascript"><code class="javascript">var obj = {
    toString: function() {
        return &quot;obj作用域内&quot;;
    },
    func: function() {
        alert(this);
        var innerfunc = function() {
            alert(this);
        };
        innerfunc.call(this);
    }
};
obj.func.call(window);</code></pre>

<p>弹出来的第二个对话框内容是什么</p>

<p>考this的题，没跑了</p>

<p>首先看<code>obj.func.call(window)</code>，这句使用了call方法指定this，没啥说的，this肯定指向window，所以第一个对话框的内容肯定是<code>[object window]</code>，但是它问第二个对话框，好吧，继续</p>

<p>进入到func内部，其又用call来调用，传入的还是this，也就是window对象，所以第二个对话框也是window</p>

<h2 id="_5">第五题</h2>

<p>考虑如下代码：</p>

<pre class="javascript"><code class="javascript">var message = &quot;Hello world!&quot;;
var t1 = message.substring(1, 4);
var t2 = message.substr(1,4);</code></pre>

<p>t1，t2的值各是多少？</p>

<p>通过这道题我才知道原来还有substr这么个玩意</p>

<p>首先来看substring方法，其接受两个参数，left和right，分别代表截取的起始点和终点，这是一个左闭右开的区间，right位置的字符不会被截取，所以这里会截取的是message[1], message[2], message[3]三个字符为’ell’</p>

<p>接下来看substr方法，其亦接受两个参数，left和count，分别代表截取的起始点和截取字符的个数…所以会截取message[1], message[2], message[3], message[4]四个字符，也就是’ello’</p>

<h2 id="_6">第六题</h2>

<pre class="javascript"><code class="javascript">if (a in window) {
    var a = 1;
}
console.log(a);</code></pre>

<p>看了那么多关于变量声明提升的概念，这题竟然错了，呵呵</p>

<p>这题就是考的变量的提升：提升后的代码如下：</p>

<pre class="javascript"><code class="javascript">var a;
if (a in window) {
    a = 1;
}
console.log(a);</code></pre>

<p>这样就很明显了，答案是1</p>

<h2 id="_7">第七题</h2>

<pre class="javascript"><code class="javascript">var x = 10;
var foo = {
    x: 20,
    bar: function() {
        var x = 30;
        return this.x;
    }
};

alert(foo.bar());
alert((foo.bar)());
alert((foo.bar = foo.bar)());
alert((foo.bar, foo.bar)());</code></pre>

<p>弹出的内容依次是？</p>

<p>这题也是考的不同调用方法中的this，本来挺有自信的，但发现和想的不太一样</p>

<p>第一行<code>foo.bar()</code>比较明显，对象的方法调用，this指向拥有该方法的独享，所以输出值为20</p>

<p>第二行<code>(foo.bar)()</code>和我想的不太一样，我以为这会是函数调用，结果不是，其也是对象方法调用，this值指向foo对象，所以答案是20</p>

<p>第三行<code>(foo.bar = foo.bar)()</code>有一个赋值语句，JavaScript的复制语句返回的是被赋予的值，这是函数调用，所以this指向全局对象window，答案是10</p>

<p>第四行<code>(foo.bar, foo.bar)()</code>，逗号表达式，也是函数调用，都好表达式的值默认是最后的那个值，答案是10</p>

<h2 id="_8">第八题</h2>

<p>在javascript中要改变页面文档的背景色，需要修改document对象的（）属性。</p>

<p>我凑，才知道document还有这么个神奇的属性可以改变背景颜色，而不是通过改变CSS的方式，答案是<code>bgColor</code>属性，修改完后，body会多一个<code>bgcolor</code>属性，而body的css也会加上一条<code>background-color</code>规则</p>

<h2 id="_9">第九题</h2>

<p>在通过元素的style属性修改CSS时，有横线的属性（如background-color）应该如何表示？</p>

<p>答案：将横线去掉，横线后的首字母大写，如backgroundColor</p>

<h2 id="_10">第十题</h2>

<p>JavaScript有哪些数据类型？</p>

<p>答案：一共六种，number、boolean、string、object、null、undefined</p>

<h2 id="_11">第十一题</h2>

<p>img标签的alt和title分别是什么意思</p>

<p>答案: title用于给与一些提示性文字鼠标悬停可以看到title的信息。而alt则是在图片无法显示是的替换文字</p>

<h2 id="_12">第十二题</h2>

<p>实现一个两列，左边宽度自适应，右边宽度固定200px的布局</p>

<p>答案：</p>

<pre class="xml"><code class="xml">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        .g-sd {
            float:right;
            width: 200px;
            height: 400px;
            background-color: #f0f0f0;
        }
        .g-mn {
            zoom: 1;
            overflow: hidden;
            height: 700px;
            background: #f0ffff;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&#39;g-sd&#39;&gt;&lt;/div&gt;
    &lt;div class=&#39;g-mn&#39;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

<h2 id="_13">第十三题</h2>

<p>如何对JavaScript对象进行深拷贝？</p>

<pre class="javascript"><code class="javascript">Object.prototype.deepClone = function() {
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        toString = Object.prototype.toString,
        deepClone = Object.prototype.deepClone,
        result,
        iter,
        cur,
        m;

    if (toString.call(this) === &#39;[object Array]&#39;) {
        result = [];
    } else {
        result = {};
    }
    for (iter in this) {
        cur = this[iter];
        if (hasOwnProperty.call(this, iter)) {
            if (typeof cur === &#39;object&#39;) {
                result[iter] = deepClone.call(cur);;
            } else {
                result[iter] = cur;
            }
        }
    }
    return result;
};</code></pre>

<p>测试用例：</p>

<pre class="javascript"><code class="javascript">var someObj = {
    num: 123,
    str: &quot;someString&quot;,
    bool: true,
    func: function(){},
    obj: {
        arr: [1,2,{
            num: 1
        }]
    },
    arr: [1,2,&quot;string&quot;]
};
console.log(someObj.deepClone());</code></pre>

<p>结果图：</p>

<p><img src="http://skyinlayer.com/images/fe_interview/3.png" alt="深度复制成功" /></p>

<h2 id="_14">第十四题</h2>

<p>动态打印时间，格式为yyyy-MM-dd hh:mm:ss?</p>

<pre class="javascript"><code class="javascript">Date.prototype.format = function(format) {
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        timeObj = {
            &quot;YYYY&quot;: this.getFullYear(),
            &quot;YY&quot;: this.getFullYear().toString().slice(2),
            &quot;MM&quot;: this.getMonth() + 1,
            &quot;DD&quot;: this.getDate(),
            &quot;hh&quot;: this.getHours(),
            &quot;mm&quot;: this.getMinutes(),
            &quot;ss&quot;: this.getSeconds()
        },
        item,
        value;
    for (item in timeObj){
        value = timeObj[item];
        if(hasOwnProperty.call(timeObj, item)){
            format = format.replace(item, value &lt; 10 ? &quot;0&quot; + value : value);
        }
    }
    return format;
};

setInterval(function(){
    console.log(new Date().format(&quot;YYYY-MM-DD hh:mm:ss&quot;));
},1000);</code></pre> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/20/js-interview-1</guid>
            </item>
        
            <item>
                <title><![CDATA[ 浅谈V8引擎中的垃圾回收机制 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/19/v8-gc</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 19 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>这篇文章的所有内容均来自 朴灵的《深入浅出Node.js》及<a href="http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection">A tour of V8:Garbage Collection</a>，后者还有中文翻译版<a href="http://newhtml.net/v8-garbage-collection/">V8 之旅： 垃圾回收器</a>，我在这里只是做了个记录和结合</p>

<h2 id="">垃圾回收器</h2>

<h3 id="javascript">JavaScript的垃圾回收器</h3>

<p>JavaScript使用垃圾回收机制来自动管理内存。垃圾回收是一把双刃剑，其好处是可以大幅简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄露问题。但使用了垃圾回收即意味着程序员将无法掌控内存。ECMAScript没有暴露任何垃圾回收器的接口。我们无法强迫其进行垃圾回收，更无法干预内存管理</p>

<h3 id="node">Node的内存管理问题</h3>

<p>在浏览器中，V8引擎实例的生命周期不会很长（谁没事一个页面开着几天几个月不关），而且运行在用户的机器上。如果不幸发生内存泄露等问题，仅仅会影响到一个终端用户。且无论这个V8实例占用了多少内存，最终在关闭页面时内存都会被释放，几乎没有太多管理的必要（当然并不代表一些大型Web应用不需要管理内存）。但如果使用Node作为服务器，就需要关注内存问题了，一旦内存发生泄漏，久而久之整个服务将会瘫痪（服务器不会频繁的重启）</p>

<h2 id="v8">V8的内存限制</h2>

<h3 id="_2">存在限制</h3>

<p>Node与其他语言不同的一个地方，就是其限制了JavaScript所能使用的内存（64位为1.4GB，32位为0.7GB），这也就意味着将无法直接操作一些大内存对象。这很令人匪夷所思，因为很少有其他语言会限制内存的使用</p>

<h3 id="_3">为何限制</h3>

<p>V8之所以限制了内存的大小，表面上的原因是V8最初是作为浏览器的JavaScript引擎而设计，不太可能遇到大量内存的场景，而深层次的原因则是由于V8的垃圾回收机制的限制。由于V8需要保证JavaScript应用逻辑与垃圾回收器所看到的不一样，V8在执行垃圾回收时会阻塞JavaScript应用逻辑，直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。若V8的堆内存为1.5GB，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1秒以上。这样浏览器将在1s内失去对用户的响应，造成假死现象。如果有动画效果的话，动画的展现也将显著受到影响</p>

<h3 id="_4">突破限制</h3>

<p>当然这个限制是可以打开的，类似于JVM，我们通过在启动node时可以传递–max-old-space-size或–max-new-space-size来调整内存限制的大小，前者确定老生代的大小，单位为MB，后者确定新生代的大小，单位为KB。这些配置只在V8初始化时生效，一旦生效不能再改变</p>

<h2 id="v8_2">V8的堆构成</h2>

<p>V8的堆其实并不只是由老生代和新生代两部分构成，可以将堆分为几个不同的区域： <em>　新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁</em>　老生代指针区：属于老生代，这里包含了大多数可能存在指向其他对象的指针的对象，大多数从新生代晋升的对象会被移动到这里 <em>　老生代数据区：属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针</em>　大对象区：这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象 <em>　代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区</em>　Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单</p>

<p>每个区域都是由一组内存页构成，内存页是V8申请内存的最小单位，除了大对象区的内存页较大以外，其他区的内存页都是1MB大小，而且按照1MB对齐。内存页除了存储的对象，还有一个包含元数据和标识信息的页头，以及一个用于标记哪些对象是活跃对象的位图区。另外每个内存页还有一个单独分配在另外内存区的槽缓冲区，里面放着一组对象，这些对象可能指向其他存储在该页的对象。垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收</p>

<h2 id="v8_3">V8的垃圾回收机制</h2>

<h3 id="_5">如何判断回收内容</h3>

<p>如何确定哪些内存需要回收，哪些内存不需要回收，这是垃圾回收期需要解决的最基本问题。我们可以这样假定，一个对象为活对象当且仅当它被一个根对象或另一个活对象指向。根对象永远是活对象，它是被浏览器或V8所引用的对象。被局部变量所指向的对象也属于根对象，因为它们所在的作用域对象被视为根对象。全局对象（Node中为global，浏览器中为window）自然是根对象。浏览器中的DOM元素也属于根对象</p>

<h3 id="_6">如何识别指针和数据</h3>

<p>垃圾回收器需要面临一个问题，它需要判断哪些是数据，哪些是指针。由于很多垃圾回收算法会将对象在内存中移动（紧凑，减少内存碎片），所以经常需要进行指针的改写</p>

<p>目前主要有三种方法来识别指针：</p>

<ol>
<li>保守法：将所有堆上对齐的字都认为是指针，那么有些数据就会被误认为是指针。于是某些实际是数字的假指针，会背误认为指向活跃对象，导致内存泄露（假指针指向的对象可能是死对象，但依旧有指针指向——这个假指针指向它）同时我们不能移动任何内存区域。</li>

<li>编译器提示法：如果是静态语言，编译器能够告诉我们每个类当中指针的具体位置，而一旦我们知道对象时哪个类实例化得到的，就能知道对象中所有指针。这是JVM实现垃圾回收的方式，但这种方式并不适合JS这样的动态语言</li>

<li>标记指针法：这种方法需要在每个字末位预留一位来标记这个字段是指针还是数据。这种方法需要编译器支持，但实现简单，而且性能不错。V8采用的是这种方式。V8将所有数据以32bit字宽来存储，其中最低一位保持为0，而指针的最低两位为01</li>
</ol>

<h3 id="v8_4">V8的回收策略</h3>

<p>自动垃圾回收算法的演变过程中出现了很多算法，但是由于不同对象的生存周期不同，没有一种算法适用于所有的情况。所以V8采用了一种分代回收的策略，将内存分为两个生代：新生代和老生代。新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。分别对新生代和老生代使用不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代中的对象满足某些条件（后面会有介绍）时，会被移动到老生代（晋升）</p>

<h3 id="v8_5">V8的分代内存</h3>

<p>默认情况下，64位环境下的V8引擎的新生代内存大小32MB、老生代内存大小为1400MB，而32位则减半，分别为16MB和700MB。V8内存的最大保留空间分别为1464MB（64位）和732MB（32位）。具体的计算公式是<code>4*reserved_semispace_space_ + max_old_generation_size_</code>，新生代由两块<code>reserved_semispace_space_</code>组成，每块16MB（64位）或8MB（32位）</p>

<h2 id="_7">新生代</h2>

<h3 id="_8">新生代的特点</h3>

<p>大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁。在新生代分配内存非常容易，我们只需要保存一个指向内存区的指针，不断根据新对象的大小进行递增即可。当该指针到达了新生代内存区的末尾，就会有一次清理（仅仅是清理新生代）</p>

<h3 id="_9">新生代的垃圾回收算法</h3>

<p>新生代使用Scavenge算法进行回收。在Scavenge算法的实现中，主要采用了Cheney算法。</p>

<p>Cheney算法算法是一种采用复制的方式实现的垃圾回收算法。它将内存一分为二，每一部分空间称为semispace。在这两个semispace中，一个处于使用状态，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间，当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收算法时，会检查From空间中的存活对象，这些存活对象将会被复制到To空间中（复制完成后会进行紧缩），而非活跃对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。也就是说，在垃圾回收的过程中，就是通过将存活对象在两个semispace之间进行复制。可以很容易看出来，使用Cheney算法时，总有一半的内存是空的。但是由于新生代很小，所以浪费的内存空间并不大。而且由于新生代中的对象绝大部分都是非活跃对象，需要复制的活跃对象比例很小，所以其时间效率十分理想。复制的过程采用的是BFS（广度优先遍历）的思想，从根对象出发，广度优先遍历所有能到达的对象</p>

<p>具体的执行过程大致是这样：</p>

<p>首先将From空间中所有能从根对象到达的对象复制到To区，然后维护两个To区的指针scanPtr和allocationPtr，分别指向即将扫描的活跃对象和即将为新对象分配内存的地方，开始循环。循环的每一轮会查找当前scanPtr所指向的对象，确定对象内部的每个指针指向哪里。如果指向老生代我们就不必考虑它了。如果指向From区，我们就需要把这个所指向的对象从From区复制到To区，具体复制的位置就是allocationPtr所指向的位置。复制完成后将scanPtr所指对象内的指针修改为新复制对象存放的地址，并移动allocationPtr。如果一个对象内部的所有指针都被处理完，scanPtr就会向前移动，进入下一个循环。若scanPtr和allocationPtr相遇，则说明所有的对象都已被复制完，From区剩下的都可以被视为垃圾，可以进行清理了</p>

<p>举个栗子(以及凑篇幅)，如果有类似如下的引用情况：</p>

<pre><code>          +----- A对象
          |
根对象----+----- B对象 ------ E对象
          |
          +----- C对象 ----+---- F对象 
                           |
                           +---- G对象 ----- H对象
                           
    D对象</code></pre>

<p>在执行Scavenge之前，From区长这幅模样</p>

<pre><code>+---+---+---+---+---+---+---+---+--------+
| A | B | C | D | E | F | G | H |        |
+---+---+---+---+---+---+---+---+--------+</code></pre>

<p>那么首先将根对象能到达的ABC对象复制到To区，于是乎To区就变成了这个样子：</p>

<pre><code>          allocationPtr
             ↓ 
+---+---+---+----------------------------+
| A | B | C |                            |
+---+---+---+----------------------------+
 ↑
scanPtr  </code></pre>

<p>接下来进入循环，扫描scanPtr所指的A对象，发现其没有指针，于是乎scanPtr移动，变成如下这样</p>

<pre><code>          allocationPtr
             ↓ 
+---+---+---+----------------------------+
| A | B | C |                            |
+---+---+---+----------------------------+
     ↑
  scanPtr  </code></pre>

<p>接下来扫描B对象，发现其有指向E对象的指针，且E对象在From区，那么我们需要将E对象复制到allocationPtr所指的地方并移动allocationPtr指针：</p>

<pre><code>            allocationPtr
                 ↓ 
+---+---+---+---+------------------------+
| A | B | C | E |                        |
+---+---+---+---+------------------------+
     ↑
  scanPtr  </code></pre>

<p>B对象里所有指针都已被复制完，所以移动scanPtr：</p>

<pre><code>            allocationPtr
                 ↓ 
+---+---+---+---+------------------------+
| A | B | C | E |                        |
+---+---+---+---+------------------------+
         ↑
      scanPtr  </code></pre>

<p>接下来扫描C对象，C对象中有两个指针，分别指向F对象和G对象，且都在From区，先复制F对象到To区：</p>

<pre><code>                allocationPtr
                     ↓ 
+---+---+---+---+---+--------------------+
| A | B | C | E | F |                    |
+---+---+---+---+---+--------------------+
         ↑
      scanPtr  </code></pre>

<p>然后复制G对象到To区</p>

<pre><code>                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
         ↑
      scanPtr  </code></pre>

<p>这样C对象内部的指针已经复制完成了，移动scanPtr：</p>

<pre><code>                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
             ↑
          scanPtr  </code></pre>

<p>逐个扫描E，F对象，发现其中都没有指针，移动scanPtr：</p>

<pre><code>                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
                     ↑
                  scanPtr  </code></pre>

<p>扫描G对象，发现其中有一个指向H对象的指针，且H对象在From区，复制H对象到To区，并移动allocationPtr：</p>

<pre><code>                        allocationPtr
                             ↓ 
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+
                     ↑
                  scanPtr  </code></pre>

<p>完成后由于G对象没有其他指针，且H对象没有指针移动scanPtr：</p>

<pre><code>                        allocationPtr
                             ↓ 
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+
                             ↑
                           scanPtr  </code></pre>

<p>此时scanPtr和allocationPtr重合，说明复制结束</p>

<p>可以对比一下From区和To区在复制完成后的结果：</p>

<pre><code>//From区
+---+---+---+---+---+---+---+---+--------+
| A | B | C | D | E | F | G | H |        |
+---+---+---+---+---+---+---+---+--------+
//To区
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+</code></pre>

<p>D对象没有被复制，它将被作为垃圾进行回收</p>

<h3 id="_10">写屏障</h3>

<p>如果新生代中的一个对象只有一个指向它的指针，而这个指针在老生代中，我们如何判断这个新生代的对象是否存活？为了解决这个问题，需要建立一个列表用来记录所有老生代对象指向新生代对象的情况。每当有老生代对象指向新生代对象的时候，我们就记录下来</p>

<h3 id="_11">对象的晋升</h3>

<p>当一个对象经过多次新生代的清理依旧幸存，这说明它的生存周期较长，也就会被移动到老生代，这称为对象的晋升。具体移动的标准有两种：</p>

<ol>
<li>对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理，如果是，则复制到老生代中，否则复制到To空间中</li>

<li>对象从From空间复制到To空间时，如果To空间已经被使用了超过25%，那么这个对象直接被复制到老生代</li>
</ol>

<h2 id="_12">老生代</h2>

<h3 id="_13">老生代的特点</h3>

<p>老生代所保存的对象大多数是生存周期很长的甚至是常驻内存的对象，而且老生代占用的内存较多</p>

<h3 id="_14">老生代的垃圾回收算法</h3>

<p>老生代占用内存较多（64位为1.4GB，32位为700MB），如果使用Scavenge算法，浪费一半空间不说，复制如此大块的内存消耗时间将会相当长。所以Scavenge算法显然不适合。V8在老生代中的垃圾回收策略采用Mark-Sweep和Mark-Compact相结合</p>

<h3 id="marksweep">Mark-Sweep（标记清除）</h3>

<p>标记清除分为标记和清除两个阶段。在标记阶段需要遍历堆中的所有对象，并标记那些活着的对象，然后进入清除阶段。在清除阶段总，只清除没有被标记的对象。由于标记清除只清除死亡对象，而死亡对象在老生代中占用的比例很小，所以效率较高</p>

<p>标记清除有一个问题就是进行一次标记清楚后，内存空间往往是不连续的，会出现很多的内存碎片。如果后续需要分配一个需要内存空间较多的对象时，如果所有的内存碎片都不够用，将会使得V8无法完成这次分配，提前触发垃圾回收。</p>

<h3 id="markcompact">Mark-Compact（标记整理）</h3>

<p>标记整理正是为了解决标记清除所带来的内存碎片的问题。标记整理在标记清除的基础进行修改，将其的清除阶段变为紧缩极端。在整理的过程中，将活着的对象向内存区的一段移动，移动完成后直接清理掉边界外的内存。紧缩过程涉及对象的移动，所以效率并不是太好，但是能保证不会生成内存碎片</p>

<h3 id="_15">算法思路</h3>

<p>标记清除和标记整理都分为两个阶段：标记阶段、清除或紧缩阶段</p>

<p>在标记阶段，所有堆上的活跃对象都会被标记。每个内存页有一个用来标记对象的位图，位图中的每一位对应内存页中的一个字。这个位图需要占据一定的空间（32位下为3.1%，64位为1.6%）。另外有两位用来标记对象的状态，这个状态一共有三种（所以要两位）——白，灰，黑：</p>

<ul>
<li>如果一个对象为白对象，它还没未被垃圾回收器发现</li>

<li>如果一个对象为灰对象，它已经被垃圾回收器发现，但其邻接对象尚未全部处理</li>

<li>如果一个对象为黑对象，说明他步进被垃圾回收器发现，其邻接对象也全部被处理完毕了</li>
</ul>

<p>如果将对中的对象看做由指针做边的有向图，标记算法的核心就是深度优先搜索。在初始时，位图为空，所有的对象也都是白对象。从根对象到达的对象会背染色为灰色，放入一个单独的双端队列中。标记阶段的每次循环，垃圾回收器都会从双端队列中取出一个对象并将其转变为黑对象，并将其邻接的对象转变为灰，然后把其邻接对象放入双端队列。如果双端队列为空或所有对象都变成黑对象，则结束。特别大的对象，可能会在处理时进行分片，防止双端队列溢出。如果双端队列溢出，则对象仍然会成为灰对象，但不会被放入队列中，这将导致其邻接对象无法被转变为灰对象。所以在双端队列为空时，需要扫描所有对象，如果仍有灰对象，将它们重新放入队列中进行处理。标记结束后，所有的对象都应该非黑即白，白对象将成为垃圾，等待释放</p>

<p>清除和紧缩阶段都是以内存页为单位回收内存</p>

<p>清除时垃圾回收器会扫描连续存放的死对象，将其变成空闲空间，并保存到一个空闲空间的链表中。这个链表常被scavenge算法用于分配被晋升对象的内存，但也被紧缩算法用于移动对象</p>

<p>紧缩算法会尝试将碎片页整合到一起来释放内存。由于页上的对象会被移动到新的页上，需要重新分配一些页。大致过程是，对目标碎片页中的每个活跃对象，在空闲内存链表中分配一块内存页，将该对象复制过去，并在碎片页中的该对象上写上新的内存地址。随后在迁出过程中，对象的旧地址将会被记录下来，在迁出结束后，V8会遍历所有它所记录的旧对象的地址，将其更新为新地址。由于标记过程中也记录了不同页之间的指针，这些指针在此时也会进行更新。如果一个页非常活跃，如其中有过多需要记录的指针，那么地址记录会跳过它，等到下一轮垃圾回收进行处理</p>

<h3 id="_16">结合使用标记清除和标记整理</h3>

<p>V8的老生代使用标记清除和标记整理结合的方式，主要采用标记清除算法，如果空间不足以分配从新生代晋升过来的对象时，才使用标记整理</p>

<h2 id="v8_6">V8的优化</h2>

<h3 id="incremental_marking">Incremental Marking（增量标记）</h3>

<p>由于全停顿会造成了浏览器一段时间无响应，所以V8使用了一种增量标记的方式，将完整的标记拆分成很多部分，每做完一部分就停下来，让JS的应用逻辑执行一会，这样垃圾回收与应用逻辑交替完成。经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原来的1/6左右</p>

<h3 id="_17">惰性清理</h3>

<p>由于标记完成后，所有的对象都已经被标记，不是死对象就是活对象，堆上多少空间格局已经确定。我们可以不必着急释放那些死对象所占用的空间，而延迟清理过程的执行。垃圾回收器可以根据需要逐一清理死对象所占用的内存页</p>

<h3 id="_18">其他</h3>

<p>V8后续还引入了增量式整理（incremental compaction），以及并行标记和并行清理，通过并行利用多核CPU来提升垃圾回收的性能</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/19/v8-gc</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用WebRTC搭建前端视频聊天室——信令篇 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/18/webRTC-2</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 18 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">前面的话</h2>

<p>这篇文章讲述了WebRTC中所涉及的信令交换以及聊天室中的信令交换，主要内容来自<a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/">WebRTC in the real world: STUN, TURN and signaling</a>，我在这里提取出的一些信息，并添加了自己在开发时的一些想法</p>

<h2 id="webrtc">WebRTC的服务器</h2>

<p>WebRTC提供了浏览器到浏览器（点对点）之间的通信，但并不意味着WebRTC不需要服务器。暂且不说基于服务器的一些扩展业务，WebRTC至少有两件事必须要用到服务器：</p>

<ol>
<li>浏览器之间交换建立通信的元数据（信令）必须通过服务器</li>

<li>为了穿越NAT和防火墙</li>
</ol>

<h2 id="_2">为什么需要信令？</h2>

<p>我们需要通过一系列的信令来建立浏览器之间的通信。而具体需要通过信令交换哪些内容呢？这里大概列了一下：</p>

<ol>
<li>用来控制通信开启或者关闭的连接控制消息</li>

<li>发生错误时用来彼此告知的消息</li>

<li>媒体流元数据，比如像解码器、解码器的配置、带宽、媒体类型等等</li>

<li>用来建立安全连接的关键数据</li>

<li>外界所看到的的网络上的数据，比如IP地址、端口等</li>
</ol>

<p>在建立连接之前，浏览器之间显然没有办法传递数据。所以我们需要通过服务器的中转，在浏览器之间传递这些数据，然后建立浏览器之间的点对点连接。但是WebRTC API中并没有实现这些。</p>

<h2 id="webrtc_2">为什么WebRTC不去实现信令交换？</h2>

<p>不去由WebRTC实现信令交换的原因很简单：WebRTC标准的制定者们希望能够最大限度地兼容已有的成熟技术。具体的连接建立方式由一种叫JSEP（JavaScript Session Establishment Protocol）的协议来规定，使用JSEP有两个好处：</p>

<ol>
<li>在JSEP中，需要交换的关键信息是多媒体会话描述（multimedia session description）。由于开发者在其所开发的应用程序中信令所使用的协议不同（SIP或是XMPP或是开发者自己定义的协议），WebRTC建立呼叫的思想建立在媒体流控制层面上，从而与上层信令传输相分离，防止相互之间的信令污染。只要上层信令为其提供了多媒体会话描述符这样的关键信息就可以建立连接，不管开发者用何种方式来传递。</li>

<li>JSEP的架构同时也避免了在浏览器上保存连接的状态，防止其像一个状态机一样工作。由于页面经常被频繁的刷新，如果连接的状态保存在浏览器中，每次刷新都会丢失。使用JSEP能使得状态被保存在服务器上</li>
</ol>

<p><img src="http://skyinlayer.com/images/WebRTC/2.png" alt="JSEP的架构图" /></p>

<h2 id="session_description_protocol">会话描述协议（Session Description Protocol）</h2>

<p>JSEP将客户端之间传递的信令分为两种:offer信令和answer信令。他们主要内容的格式都遵循会话描述协议（Session Description Protocal，简称SDP）。一个SDP的信令的内容大致上如下：</p>

<pre><code>v=0
o=- 7806956 075423448571 2 IN IP4 127.0.0.1
s=-
t=0 0
a=group:BUNDLE audio video data
a=msid-semantic: WMS 5UhOcZZB1uXtVbYAU5thB0SpkXbzk9FHo30g
m=audio 1 RTP/SAVPF 111 103 104 0 8 106 105 13 126
c=IN IP4 0.0.0.0
a=rtcp:1 IN IP4 0.0.0.0
a=ice-ufrag:grnpQ0BSTSnBLroq
a=ice-pwd:N5i4DZKMM2L7FEYnhO8V7Kg5
a=ice-options:google-ice
a=fingerprint:sha-256 01:A3:18:0E:36:5E:EF:24:18:8C:8B:0C:9E:B0:84:F6:34:E9:42:E3:0F:43:64:ED:EC:46:2C:3C:23:E3:78:7B
a=setup:actpass
a=mid:audio
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=recvonly
a=rtcp-mux
a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:qzcKu22ar1+lYah6o8ggzGcQ5obCttoOO2IzXwFV
a=rtpmap:111 opus/48000/2
a=fmtp:111 minptime=10
a=rtpmap:103 ISAC/16000
a=rtpmap:104 ISAC/32000
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:106 CN/32000
a=rtpmap:105 CN/16000
a=rtpmap:13 CN/8000
a=rtpmap:126 telephone-event/8000
a=maxptime:60
m=video 1 RTP/SAVPF 100 116 117
c=IN IP4 0.0.0.0
a=rtcp:1 IN IP4 0.0.0.0
a=ice-ufrag:grnpQ0BSTSnBLroq
a=ice-pwd:N5i4DZKMM2L7FEYnhO8V7Kg5
a=ice-options:google-ice
a=fingerprint:sha-256 01:A3:18:0E:36:5E:EF:24:18:8C:8B:0C:9E:B0:84:F6:34:E9:42:E3:0F:43:64:ED:EC:46:2C:3C:23:E3:78:7B
a=setup:actpass
a=mid:video
a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time
a=sendrecv
a=rtcp-mux
a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:qzcKu22ar1+lYah6o8ggzGcQ5obCttoOO2IzXwFV
a=rtpmap:100 VP8/90000
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 goog-remb
a=rtpmap:116 red/90000
a=rtpmap:117 ulpfec/90000
a=ssrc:3162115896 cname:/nERF7Ern+udqf++
a=ssrc:3162115896 msid:5UhOcZZB1uXtVbYAU5thB0SpkXbzk9FHo30g 221b204e-c9a0-4b01-b361-e17e9bf8f639
a=ssrc:3162115896 mslabel:5UhOcZZB1uXtVbYAU5thB0SpkXbzk9FHo30g
a=ssrc:3162115896 label:221b204e-c9a0-4b01-b361-e17e9bf8f639
m=application 1 DTLS/SCTP 5000
c=IN IP40.0.0.0
a=ice-ufrag:grnpQ0BSTSnBLroq
a=ice-pwd:N5i4DZKMM2L7FEYnhO8V7Kg5
a=ice-options:google-ice
a=fingerprint:sha-256 01:A3:18:0E:36:5E:EF:24:18:8C:8B:0C:9E:B0:84:F6:34:E9:42:E3:0F:43:64:ED:EC:46:2C:3C:23:E3:78:7B
a=setup:actpass
a=mid:data
a=sctpmap:5000 webrtc-datachannel 1024</code></pre>

<p>这些都什么玩意？说实话我不知道，我这里放这么一大段出来，只是为了让文章内容显得很多…如果想深入了解的话，可以参考<a href="http://datatracker.ietf.org/doc/draft-nandakumar-rtcweb-sdp/?include_text=1">SDP for the WebRTC draft-nandakumar-rtcweb-sdp-04</a>自行进行解析</p>

<p>其实可以将其简化一下，它就是一个在点对点连接中描述自己的字符串，我们可以将其封装在JSON中进行传输，在PeerConnection建立后将其通过服务器中转后，将自己的SDP描述符和对方的SDP描述符交给PeerConnection就行了</p>

<h2 id="rtcpeerconnection">信令与RTCPeerConnection建立</h2>

<p>在前一篇文章中介绍过，WebRTC使用RTCPeerConnection来在浏览器之间传递流数据，在建立RTCPeerConnection实例之后，想要使用其建立一个点对点的信道，我们需要做两件事：</p>

<ol>
<li>确定本机上的媒体流的特性，比如分辨率、编解码能力啥的（SDP描述符）</li>

<li>连接两端的主机的网络地址（ICE Candidate）</li>
</ol>

<p>需要注意的是，由于连接两端的主机都可能在内网或是在防火墙之后，我们需要一种对所有联网的计算机都通用的定位方式。这其中就涉及NAT/防火墙穿越技术，以及WebRTC用来达到这个目的所ICE框架。这一部分在上一篇文章中有介绍，这里不再赘述。</p>

<h3 id="offeranswersdp">通过offer和answer交换SDP描述符</h3>

<p>大致上在两个用户（甲和乙）之间建立点对点连接流程应该是这个样子（这里不考虑错误的情况，RTCPeerConnection简称PC）：</p>

<ol>
<li>甲和乙各自建立一个PC实例</li>

<li>甲通过PC所提供的<code>createOffer()</code>方法建立一个包含甲的SDP描述符的offer信令</li>

<li>甲通过PC所提供的<code>setLocalDescription()</code>方法，将甲的SDP描述符交给甲的PC实例</li>

<li>甲将offer信令通过服务器发送给乙</li>

<li>乙将甲的offer信令中所包含的的SDP描述符提取出来，通过PC所提供的<code>setRemoteDescription()</code>方法交给乙的PC实例</li>

<li>乙通过PC所提供的<code>createAnswer()</code>方法建立一个包含乙的SDP描述符answer信令</li>

<li>乙通过PC所提供的<code>setLocalDescription()</code>方法，将乙的SDP描述符交给乙的PC实例</li>

<li>乙将answer信令通过服务器发送给甲</li>

<li>甲接收到乙的answer信令后，将其中乙的SDP描述符提取出来，调用<code>setRemoteDescripttion()</code>方法交给甲自己的PC实例</li>
</ol>

<p>通过在这一系列的信令交换之后，甲和乙所创建的PC实例都包含甲和乙的SDP描述符了，完成了两件事的第一件。我们还需要完成第二件事——获取连接两端主机的网络地址</p>

<h3 id="icenat">通过ICE框架建立NAT/防火墙穿越的连接</h3>

<p>这个网络地址应该是能从外界直接访问，WebRTC使用ICE框架来获得这个地址。RTCPeerConnection在创立的时候可以将ICE服务器的地址传递进去，如：</p>

<pre class="javascript"><code class="javascript">var iceServer = {
    &quot;iceServers&quot;: [{
        &quot;url&quot;: &quot;stun:stun.l.google.com:19302&quot;
    }]
};
var pc = new RTCPeerConnection(iceServer);</code></pre>

<p>当然这个地址也需要交换，还是以甲乙两位为例，交换的流程如下（RTCPeerConnection简称PC）：</p>

<ol>
<li>甲、乙各创建配置了ICE服务器的PC实例，并为其添加<code>onicecandidate</code>事件回调</li>

<li>当网络候选可用时，将会调用<code>onicecandidate</code>函数</li>

<li>在回调函数内部，甲或乙将网络候选的消息封装在ICE Candidate信令中，通过服务器中转，传递给对方</li>

<li>甲或乙接收到对方通过服务器中转所发送过来ICE Candidate信令时，将其解析并获得网络候选，将其通过PC实例的<code>addIceCandidate()</code>方法加入到PC实例中</li>
</ol>

<p>这样连接就创立完成了，可以向RTCPeerConnection中通过<code>addStream()</code>加入流来传输媒体流数据。将流加入到RTCPeerConnection实例中后，对方就可以通过<code>onaddstream</code>所绑定的回调函数监听到了。调用<code>addStream()</code>可以在连接完成之前，在连接建立之后，对方一样能监听到媒体流</p>

<h2 id="_3">聊天室中的信令</h2>

<p>上面是两个用户之间的信令交换流程，但我们需要建立一个多用户在线视频聊天的聊天室。所以需要进行一些扩展，来达到这个要求</p>

<h3 id="_4">用户操作</h3>

<p>首先需要确定一个用户在聊天室中的操作大致流程：</p>

<ol>
<li>打开页面连接到服务器上</li>

<li>进入聊天室</li>

<li>与其他所有已在聊天室的用户建立点对点的连接，并输出在页面上</li>

<li>若有聊天室内的其他用户离开，应得到通知，关闭与其的连接并移除其在页面中的输出</li>

<li>若又有其他用户加入，应得到通知，建立于新加入用户的连接，并输出在页面上</li>

<li>离开页面，关闭所有连接</li>
</ol>

<p>从上面可以看出来，除了点对点连接的建立，还需要服务器至少做如下几件事：</p>

<ol>
<li>新用户加入房间时，发送新用户的信息给房间内的其他用户</li>

<li>新用户加入房间时，发送房间内的其他用户信息给新加入房间的用户</li>

<li>用户离开房间时，发送离开用户的信息给房间内的其他用户</li>
</ol>

<h3 id="_5">实现思路</h3>

<p>以使用WebSocket为例，上面用户操作的流程可以进行以下修改：</p>

<ol>
<li>浏览器与服务器建立WebSocket连接</li>

<li>发送一个加入聊天室的信令（join），信令中需要包含用户所进入的聊天室名称</li>

<li>服务器根据用户所加入的房间，发送一个其他用户信令（peers），信令中包含聊天室中其他用户的信息，浏览器根据信息来逐个构建与其他用户的点对点连接</li>

<li>若有用户离开，服务器发送一个用户离开信令（remove_peer），信令中包含离开的用户的信息，浏览器根据信息关闭与离开用户的信息，并作相应的清除操作</li>

<li>若有新用户加入，服务器发送一个用户加入信令（new_peer），信令中包含新加入的用户的信息，浏览器根据信息来建立与这个新用户的点对点连接</li>

<li>用户离开页面，关闭WebSocket连接</li>
</ol>

<h3 id="_6">服务器实现</h3>

<p>由于用户可以只是建立连接，可能还没有进入具体房间，所以首先我们需要一个容器来保存所有用户的连接，同时监听用户是否与服务器建立了WebSocket的连接：</p>

<pre class="javascript"><code class="javascript">var server = new WebSocketServer();
var sockets = [];

server.on(&#39;connection&#39;, function(socket){
    socket.on(&#39;close&#39;, function(){
        var i = sockets.indexOf(socket);
        sockets.splice(i, 1);
        //关闭连接后的其他操作
    });
    sockets.push(socket);
    //连接建立后的其他操作
});</code></pre>

<p>由于有房间的划分，所以我们需要在服务器上建立一个容器，用来保存房间内的用户信息。显然对象较为合适，键为房间名称，值为用户信息列表。</p>

<p>同时我们需要监听上面所说的用户加入房间的信令（join），新用户加入之后需要向新用户发送房间内其他用户信息（peers）和向房间内其他用户发送新用户信息（new_peer），以及用户离开时向其他用户发送离开用户的信息（remove_peer）:</p>

<p>于是乎代码大致就变成这样：</p>

<pre class="javascript"><code class="javascript">var server = new WebSocketServer();
var sockets = [];
var rooms = {};

/*
join信令所接收的格式
{
    &quot;eventName&quot;: &quot;join&quot;,
    &quot;data&quot;: {
        &quot;room&quot;: &quot;roomName&quot;
    }
}
*/
var joinRoom = function(data, socket) {
    var room = data.room || &quot;__default&quot;;
    var curRoomSockets; //当前房间的socket列表
    var socketIds = []; //房间其他用户的id

    curRoomSockets = rooms[room] = rooms[room] || [];

    //给所有房间内的其他人发送新用户的id
    for (var i = curRoomSockets.length; i--;) {
        socketIds.push(curRoomSockets[i].id);
        curRoomSockets[i].send(JSON.stringify({
            &quot;eventName&quot;: &quot;new_peer&quot;,
            &quot;data&quot;: {
                &quot;socketId&quot;: socket.id
            }
        }));
    }

    //将新用户的连接加入到房间的连接列表中
    curRoomSockets.push(socket);
    socket.room = room;

    //给新用户发送其他用户的信息，及服务器给新用户自己赋予的id
    socket.send(JSON.stringify({
        &quot;eventName&quot;: &quot;peers&quot;,
        &quot;data&quot;: {
            &quot;socketIds&quot;: socketIds,
            &quot;you&quot;: socket.id
        }
    }));
};

server.on(&#39;connection&#39;, function(socket) {
    //为socket构建一个特有的id，用来作为区分用户的标记
    socket.id = getRandomString();
    //用户关闭连接后，应做的处理
    socket.on(&#39;close&#39;, function() {
        var i = sockets.indexOf(socket);
        var room = socket.room;
        var curRoomSockets = rooms[room];
        sockets.splice(i, 1);
        //通知房间内其他用户
        if (curRoomSockets) {
            for (i = curRoomSockets.length; i--;) {
                curRoomSockets[i].send(JSON.stringify({
                    &quot;eventName&quot;: &quot;remove_peer&quot;,
                    &quot;data&quot;: {
                        &quot;socketId&quot;: socket.id
                    }
                }));
            }
        }
        //从room中删除socket
        if (room) {
            i = this.rooms[room].indexOf(socket);
            this.rooms[room].splice(i, 1);
            if (this.rooms[room].length === 0) {
                delete this.rooms[room];
            }
        }
        //关闭连接后的其他操作
    });
    //根据前台页面传递过来的信令进行解析，确定应该如何处理
    socket.on(&#39;message&#39;, function(data) {
        var json = JSON.parse(data);
        if (json.eventName) {
            if (json.eventName === &quot;join&quot;) {
                joinRoom(data, socket);
            }
        }
    });
    //将连接保存
    sockets.push(socket);
    //连接建立后的其他操作
});</code></pre>

<p>最后再加上点对点的信令转发就行了，一份完整的代码可参照我写的<a href="https://github.com/LingyuCoder/SkyRTC/blob/master/SkyRTC.js">SkyRTC项目源码</a></p>

<h2 id="_7">参考资料</h2>

<p><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/">WebRTC in the real world: STUN, TURN and signaling</a></p>

<p><a href="http://datatracker.ietf.org/doc/draft-nandakumar-rtcweb-sdp/?include_text=1">SDP for the WebRTC draft-nandakumar-rtcweb-sdp-04</a></p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/18/webRTC-2</guid>
            </item>
        
            <item>
                <title><![CDATA[ 开源WebRTC库——SkyRTC文档（服务器部分） ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/17/SkyRTC-doc</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 17 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>忙了几天终于把SkyRTC库上传到NPM上了，并写了一份详细的使用文档，标明了基本的使用方法和类，修正了几个小bug，更多的bug还需要更多的测试，把文档发一下，具体项目见<a href="https://github.com/LingyuCoder/SkyRTC">我在Github上的SkyRTC项目</a></p>

<h2 id="">简介</h2>

<p>一个Node.js编写的WebRTC服务器端库，为服务器端库，需要配合客户端库<a href="https://github.com/LingyuCoder/SkyRTC-client">SkyRTC-client</a>共同使用，用于搭建基于WebRTC和WebSocket技术的在线音频、视频聊天室</p>

<h2 id="skyrtcskyrtcclient">SkyRTC前端库SkyRTC-client</h2>

<p><a href="https://github.com/LingyuCoder/SkyRTC-client">SkyRTC-client</a></p>

<h2 id="_2">简单示例</h2>

<h3 id="npm">NPM安装</h3>

<p>执行如下命令从npm进行安装：</p>

<pre><code>$ npm install skyrtc</code></pre>

<h3 id="_3">监听服务器</h3>

<pre class="javascript"><code class="javascript">var express = require(&#39;express&#39;);
var app = express();
var server = require(&#39;http&#39;).createServer(app);
var SkyRTC = require(&#39;skyrtc&#39;).listen(server);
var port = process.env.PORT || 3000;
server.listen(port);</code></pre>

<h3 id="webrtc">监听WebRTC事件</h3>

<p>SkyRTC继承自EventEmitter, 可以通过如下语法监听事件：</p>

<pre class="javascript"><code class="javascript">SkyRTC.rtc.on(&#39;eventName&#39;, function(params) {
  //...
});</code></pre>

<h2 id="_4">内置事件</h2>

<ul>
<li>new_connect</li>

<li>new_peer</li>

<li>remove_peer</li>

<li>socket_message</li>

<li>ice_candidate</li>

<li>offer</li>

<li>answer</li>
</ul>

<h3 id="new_connect">new_connect</h3>

<p>新用户与服务器建立WebSocket连接时触发</p>

<p>参数：</p>

<ul>
<li>socket——新建立的WebSocket连接实例</li>
</ul>

<h3 id="new_peer">new_peer</h3>

<p>用户加入房间后触发</p>

<p>参数：</p>

<ul>
<li>socket——用户使用的WebSocket连接实例</li>

<li>room——房间名称</li>
</ul>

<h3 id="remove_peer">remove_peer</h3>

<p>用户关闭连接后触发</p>

<p>参数：</p>

<ul>
<li>socket——用户使用的WebSocket连接实例</li>
</ul>

<h3 id="socket_message">socket_message</h3>

<p>客户端向服务器端发送消息，且非自定义事件格式时触发</p>

<p>参数：</p>

<ul>
<li>socket——用户使用的WebSocket连接实例</li>

<li>msg——发送的消息内容</li>
</ul>

<h3 id="ice_candidate">ice_candidate</h3>

<p>接收到ice candidate信令时触发</p>

<p>参数：</p>

<ul>
<li>socket——用户使用的WebSocket连接实例</li>

<li>candidate——ice candidate信令数据</li>
</ul>

<h3 id="offer">offer</h3>

<p>接收到offer信令时触发</p>

<p>参数：</p>

<ul>
<li>socket——用户使用的WebSocket连接实例</li>

<li>offer——offer信令数据</li>
</ul>

<h3 id="answer">answer</h3>

<p>接收到answer信令时触发</p>

<p>参数：</p>

<ul>
<li>socket——用户使用的WebSocket连接实例</li>

<li>answer——answer信令数据</li>
</ul>

<h2 id="_5">接口</h2>

<ul>
<li>getRooms</li>

<li>broadcastInRoom</li>

<li>broadcast</li>

<li>getSocket</li>

<li>on</li>
</ul>

<h3 id="getrooms">getRooms</h3>

<p>用户获取当前服务器上所有房间信息</p>

<p>参数：</p>

<p>无</p>

<p>返回值：</p>

<ul>
<li>rooms——所有房间名称的数组</li>
</ul>

<h3 id="getsocket">getSocket</h3>

<p>通过socket的id获得socket实例</p>

<p>参数：</p>

<ul>
<li>id——socket的id</li>
</ul>

<p>返回值：</p>

<ul>
<li>socket——WebSocket实例</li>
</ul>

<h3 id="broadcastinroom">broadcastInRoom</h3>

<p>在房间中广播消息</p>

<p>参数：</p>

<ul>
<li>room——被广播消息的房间名称</li>

<li>data——消息的具体内容</li>

<li>errorCb——广播失败时的回调函数</li>
</ul>

<p>返回值：</p>

<p>无</p>

<h3 id="broadcast">broadcast</h3>

<p>向服务器上的所有用户广播消息</p>

<p>参数：</p>

<ul>
<li>data——消息的具体内容</li>

<li>errorCb——广播失败时的回调函数</li>
</ul>

<p>返回值：</p>

<p>无</p>

<h3 id="on">on</h3>

<p>向服务器上的事件绑定处理器</p>

<p>参数：</p>

<ul>
<li>eventName——被绑定的事件名称</li>

<li>callback——被绑定的事件触发时的回调函数</li>
</ul>

<p>返回值：</p>

<p>无</p>

<h2 id="_6">自定义事件</h2>

<p>在SkyRTC中可以自定义事件，在前端页面使用WebSocket发送信息时，以如下JSON格式发送信息：</p>

<pre class="javascript"><code class="javascript">{
    &quot;eventName&quot;: &quot;yourOwnEventName&quot;,
    &quot;data&quot;: {
        //自定义事件数据
    }
}</code></pre>

<p>在后台通过监听同名事件来进行处理：</p>

<pre class="javascript"><code class="javascript">SkyRTC.rtc.on(&quot;yourOwnEventName&quot;, function(data){
    //data将是前台所传输的数据
});</code></pre>

<p>自定义事件请不要与上述SkyRTC原生事件重名</p>

<h2 id="_7">项目完整实例</h2>

<p><a href="https://github.com/LingyuCoder/SkyRTC-demo">SkyRTC-demo</a></p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/17/SkyRTC-doc</guid>
            </item>
        
            <item>
                <title><![CDATA[ 开源WebRTC库——SkyRTC实例 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/17/SkyRTC-demo</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 17 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>忙了几天终于把SkyRTC库上传到NPM上了，并写了一份详细的使用文档，标明了基本的使用方法和类，修正了几个小bug，更多的bug还需要更多的测试，把文档发一下，具体见<a href="https://github.com/LingyuCoder/SkyRTC-demo">我在Github上的SkyRTC-demo</a></p>

<h2 id="">简介</h2>

<p>这是一个使用SkyRTC和SkyRTC-client搭建浏览器中音频、视频、文字聊天室的Demo</p>

<h2 id="_2">安装和使用</h2>

<ol>
<li>安装Node.js及npm环境</li>

<li>下载源码到本地，并解压缩</li>

<li>移动到解压后的目录下</li>

<li>使用命令<code>npm install</code>安装所需要的库</li>

<li>运行命令<code>node server.js</code>，建议配合<code>forever</code></li>

<li>访问<code>localhost:3000#roomName</code>查看效果，其中<code>roomName</code>为进入的房间名，不同房间的用户无法互相通信</li>
</ol>

<h2 id="_3">功能说明</h2>

<p>支持划分房间的在线音频、视频、文字聊天，提供房间内文件共享功能</p>

<h2 id="skyrtc">SkyRTC项目链接</h2>

<p><a href="https://github.com/LingyuCoder/SkyRTC">SkyRTC项目</a></p>

<p><a href="https://github.com/LingyuCoder/SkyRTC-client">SkyRTC-client项目</a></p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/17/SkyRTC-demo</guid>
            </item>
        
            <item>
                <title><![CDATA[ 开源WebRTC库——SkyRTC-client文档(客户端部分) ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/17/SkyRTC-client-doc</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 17 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>忙了几天终于把SkyRTC库上传到NPM上了，并写了一份详细的使用文档，标明了基本的使用方法和类，修正了几个小bug，更多的bug还需要更多的测试，把文档发一下，具体项目见<a href="https://github.com/LingyuCoder/SkyRTC-client">我在Github上的SkyRTC-client项目</a></p>

<h2 id="">简介</h2>

<p>一个Node.js编写的WebRTC浏览器端库，为客户端库，需要配合服务器端库<a href="https://github.com/LingyuCoder/SkyRTC">SkyRTC</a>共同使用，用于搭建基于WebRTC和WebSocket技术的在线音频、视频聊天室</p>

<h2 id="skyrtc">SkyRTC客户端库</h2>

<p><a href="https://github.com/LingyuCoder/SkyRTC">SkyRTC</a></p>

<p>可使用npm进行安装：</p>

<pre><code>$ npm install skyrtc</code></pre>

<h2 id="skyrtc_2">SkyRTC实例</h2>

<p><a href="https://github.com/LingyuCoder/SkyRTC-demo">SkyRTC-demo</a>是一个基于SkyRTC搭建的多房间的在线音频、视频、文字聊天室，并能够共享文件</p>

<h2 id="skyrtcclient">SkyRTC-client的使用</h2>

<p>通过在HTML中引入JavaScript文件的方式引入：</p>

<pre class="xml"><code class="xml">&lt;script type=&quot;text/javascript&quot; src=&quot;/SkyRTC-client.js&quot;&gt;&lt;/script&gt;</code></pre>

<p>可通过如下方式监听SkyRTC-client的事件：</p>

<pre class="javascript"><code class="javascript">SkyRTC.on(&#39;someEvent&#39;, function(params) {
    //...
});</code></pre>

<p>连接后台WebSocket服务器：</p>

<pre class="javascript"><code class="javascript">SkyRTC.connect(&quot;ws:&quot; + window.location.href.substring(window.location.protocol.length).split(&#39;#&#39;)[0], window.location.hash.slice(1));</code></pre>

<h2 id="_2">方法</h2>

<ul>
<li>connect</li>

<li>on</li>

<li>sendFile</li>

<li>shareFile</li>

<li>sendMessage</li>

<li>broadcast</li>

<li>sendFileAccept</li>

<li>sendFileRefuse</li>

<li>createStream</li>

<li>attachStream</li>
</ul>

<h3 id="connect">connect</h3>

<p>连接WebSocket后台服务器，建立信令交互的信道，并加入到一个房间之中</p>

<p>参数：</p>

<ul>
<li>server——服务器地址</li>

<li>room——房间名称</li>
</ul>

<p>返回值： 无</p>

<h3 id="on">on</h3>

<p>向SkyRTC-client相关事件绑定回调函数</p>

<p>参数：</p>

<ul>
<li>eventName——事件名称</li>

<li>callback——事件触发时的回调函数</li>
</ul>

<p>返回值： 无</p>

<h3 id="sendfile">sendFile</h3>

<p>向所在房间中的某个特定用户请求发送文件</p>

<p>参数：</p>

<ul>
<li>dom——包含需要被发送的文件的input[type=’file’]的id或者dom对象</li>

<li>socketId——接收文件的用户的id</li>
</ul>

<h3 id="sharefile">shareFile</h3>

<p>向所在房间中的所有其他用户请求发送文件</p>

<p>参数：</p>

<ul>
<li>dom——包含需要被发送的文件的input[type=’file’]的id或者dom对象</li>
</ul>

<p>返回值： 无</p>

<h3 id="sendmessage">sendMessage</h3>

<p>向所在房间内的某个特定用户发送消息</p>

<p>参数：</p>

<ul>
<li>message——需要被发送的消息内容</li>

<li>socketId——接收消息用户的id</li>
</ul>

<p>返回值： 无</p>

<h3 id="broadcast">broadcast</h3>

<p>向所在房间中的所有其他用户发送文字消息</p>

<p>参数：</p>

<ul>
<li>msg——需要被发送的消息字符串</li>
</ul>

<p>返回值： 无</p>

<h3 id="sendfileaccept">sendFileAccept</h3>

<p>接收到文件发送请求后，同意接收文件</p>

<p>参数：</p>

<ul>
<li>sendId——发送文件的id</li>
</ul>

<p>返回值： 无</p>

<h3 id="sendfilerefuse">sendFileRefuse</h3>

<p>接收到文件发送请求后，拒绝接收文件</p>

<p>参数：</p>

<ul>
<li>sendId——发送文件的id</li>
</ul>

<p>返回值： 无</p>

<h3 id="createstream">createStream</h3>

<p>创建本地视频流</p>

<p>参数：</p>

<ul>
<li>constraints——创建的视频流的约束对象</li>
</ul>

<p>返回值： 无</p>

<h3 id="attachstream">attachStream</h3>

<p>接收到远程视频流后，将视频流绑定到video标签上</p>

<p>参数：</p>

<ul>
<li>stream——远程视频流对象</li>

<li>domId——需要被绑定的video标签的id</li>
</ul>

<p>返回值： 无</p>

<h2 id="_3">原生事件</h2>

<h3 id="_4">连接建立</h3>

<ul>
<li>connected</li>

<li>socket_opened</li>

<li>socket_error</li>

<li>socket_closed</li>

<li>socket_receive_message</li>
</ul>

<h3 id="_5">信令交换</h3>

<ul>
<li>get_peers</li>

<li>get_ice_candidate</li>

<li>get_offer</li>

<li>get_answer</li>

<li>new_peer</li>

<li>remove_peer</li>
</ul>

<h3 id="_6">建立流</h3>

<ul>
<li>stream_created</li>

<li>stream_created_error</li>
</ul>

<h3 id="peerconnection">PeerConnection相关事件</h3>

<ul>
<li>pc_get_ice_candidate</li>

<li>pc_opened</li>

<li>pc_add_stream</li>

<li>pc_add_data_channel</li>
</ul>

<h3 id="datachannel">DataChannel相关事件</h3>

<ul>
<li>data_channel_create_error</li>

<li>data_channel_opened</li>

<li>data_channel_closed</li>

<li>data_channel_message</li>

<li>data_channel_error</li>
</ul>

<h3 id="_7">文件发送相关</h3>

<ul>
<li>send_file_error</li>

<li>send_file</li>

<li>send_file_refused</li>

<li>send_file_accepted</li>

<li>send_file_chunk</li>

<li>sended_file</li>

<li>receive_file_chunk</li>

<li>receive_file</li>

<li>receive_file_ask</li>

<li>receive_file_error</li>
</ul>

<h2 id="_8">连接建立事件详解</h2>

<h3 id="connected">connected</h3>

<p>在于后台服务器成功创立WebSocket连接后触发</p>

<p>参数：</p>

<ul>
<li>socket——与后台连接的WebSocket实例</li>
</ul>

<h3 id="socket_opened">socket_opened</h3>

<p>WebSocket连接开启后触发</p>

<p>参数：</p>

<ul>
<li>socket——与后台连接的WebSocket实例</li>
</ul>

<h3 id="socket_error">socket_error</h3>

<p>WebSocket连接发生错误后触发</p>

<p>参数：</p>

<ul>
<li>error——错误对象</li>

<li>socket——与后台连接的WebSocket实例</li>
</ul>

<h3 id="socket_closed">socket_closed</h3>

<p>WebSocket连接关闭后触发</p>

<p>参数：</p>

<ul>
<li>socket——与后台连接的WebSocket实例</li>
</ul>

<h3 id="socket_receive_message">socket_receive_message</h3>

<p>WebSocket连接接收到非自定义事件格式的信息时触发</p>

<p>参数：</p>

<ul>
<li>socket——与后台连接的WebSocket实例</li>

<li>jsonMsg——JSON格式的message</li>
</ul>

<h2 id="_9">信令交换事件详解</h2>

<h3 id="get_peers">get_peers</h3>

<p>在获取当前房间所有用户的id后调用</p>

<p>参数：</p>

<ul>
<li>socketIds——房间内其他用户的id字符串列表</li>
</ul>

<h3 id="get_ice_candidate">get_ice_candidate</h3>

<p>在获得了ICE Candidate信令后调用</p>

<p>参数：</p>

<ul>
<li>candidate——ICE Candidate信令数据</li>
</ul>

<h3 id="get_offer">get_offer</h3>

<p>在获得offer信令后调用</p>

<p>参数：</p>

<ul>
<li>offer——offer信令数据</li>
</ul>

<h3 id="get_answer">get_answer</h3>

<p>在获得answer信令后调用</p>

<p>参数：</p>

<ul>
<li>answer——answer信令数据</li>
</ul>

<h3 id="new_peer">new_peer</h3>

<p>在有新用户加入后调用</p>

<p>参数：</p>

<ul>
<li>socketId：新用户的id</li>
</ul>

<h3 id="remove_peer">remove_peer</h3>

<p>有用户断开连接后调用</p>

<p>参数：</p>

<ul>
<li>socketId：断开连接的用户的socket id</li>
</ul>

<h2 id="_10">建立流</h2>

<h3 id="stream_created">stream_created</h3>

<p>成功建立本地视频流时触发</p>

<p>参数：</p>

<ul>
<li>stream——本地视频流对象</li>
</ul>

<h3 id="stream_created_error">stream_created_error</h3>

<p>建立本地视频流失败时触发</p>

<p>参数：</p>

<ul>
<li>error——错误对象</li>
</ul>

<h2 id="peerconnection_2">PeerConnection相关事件</h2>

<h3 id="pc_opened">pc_opened</h3>

<p>PeerConnection成功开启后触发</p>

<p>参数：</p>

<ul>
<li>socketId——PeerConnection所连接用户的id</li>

<li>pc——成功开启的PeerConnection实例</li>
</ul>

<h3 id="pc_get_ice_candidate">pc_get_ice_candidate</h3>

<p>获得从ICE Candidate消息时触发</p>

<p>参数：</p>

<ul>
<li>candidate——ICE Candidate信令内容</li>

<li>socketId——PeerConnection所连接用户的id</li>

<li>pc——获得信令PeerConnection实例</li>
</ul>

<h3 id="pc_add_stream">pc_add_stream</h3>

<p>通过PeerConnection上接收到视频流后触发</p>

<p>参数：</p>

<ul>
<li>stream——添加的流对象</li>

<li>socketId——PeerConnection所连接用户的id</li>

<li>pc——增加流的PeerConnection实例</li>
</ul>

<h3 id="pc_add_data_channel">pc_add_data_channel</h3>

<p>通过PeerConnection上接收到data channel后触发</p>

<p>参数：</p>

<ul>
<li>channel——添加的data channel</li>

<li>socketId——PeerConnection所连接用户的id</li>

<li>pc——增加data channel的PeerConnection实例</li>
</ul>

<h2 id="datachannel_2">DataChannel相关事件</h2>

<h3 id="data_channel_create_error">data_channel_create_error</h3>

<p>data channel创建失败时触发</p>

<p>参数：</p>

<ul>
<li>socketId——data channel所连接用户的id</li>

<li>error——错误对象</li>
</ul>

<h3 id="data_channel_opened">data_channel_opened</h3>

<p>data channel成功开启后触发</p>

<p>参数：</p>

<ul>
<li>channel——开启的data channel实例</li>

<li>socketId——data channel所连接用户的id</li>
</ul>

<h3 id="data_channel_closed">data_channel_closed</h3>

<p>data channel关闭后触发</p>

<p>参数：</p>

<ul>
<li>channel——被关闭的data channel实例</li>

<li>socketId——data channel所连接用户的id</li>
</ul>

<h3 id="data_channel_message">data_channel_message</h3>

<p>data channel上接收到数据且非文件信令类型时触发</p>

<p>参数：</p>

<ul>
<li>channel——接收到数据的data channel实例</li>

<li>socketId——data channel所属用户的id</li>

<li>message——json格式的接收到的具体数据信息</li>
</ul>

<h3 id="data_channel_error">data_channel_error</h3>

<p>data channel发生错误时触发</p>

<p>参数：</p>

<ul>
<li>channel——发生错误的data channel实例</li>

<li>socketId——data channel所连接用户的id</li>

<li>error——错误对象</li>
</ul>

<h2 id="_11">文件发送相关</h2>

<h3 id="send_file">send_file</h3>

<p>读取需要发送的文件完毕，并请求对方接收时触发</p>

<p>参数：</p>

<ul>
<li>sendId：发送的文件id</li>

<li>socketId：接收者的id</li>

<li>file：被发送的文件对象</li>
</ul>

<h3 id="send_file_error">send_file_error</h3>

<p>发送方发送文件失败时触发</p>

<p>参数：</p>

<ul>
<li>error——错误对象</li>

<li>socketId——接收者的id</li>

<li>sendId——发送失败的文件的id，为空则表示获取文件失败</li>

<li>file——发送失败的文件对象，为空则表示获取文件失败</li>
</ul>

<h3 id="send_file_refused">send_file_refused</h3>

<p>对方拒绝接收文件时触发</p>

<p>参数：</p>

<ul>
<li>sendId——被拒绝接收的文件id</li>

<li>socketId——接收者的id</li>

<li>file——被拒绝接收的文件</li>
</ul>

<h3 id="send_file_accepted">send_file_accepted</h3>

<p>对方同意接收文件时触发</p>

<p>参数：</p>

<ul>
<li>sendId——被同意接收的文件id</li>

<li>socketId——接收者的id</li>

<li>file——被同意接收的文件</li>
</ul>

<h3 id="send_file_chunk">send_file_chunk</h3>

<p>文件碎片发送后触发</p>

<p>参数：</p>

<ul>
<li>sendId——文件碎片所属文件的id</li>

<li>socketId——接收者的id</li>

<li>percent——已发送的百分比</li>

<li>file——被发送的文件对象</li>
</ul>

<h3 id="sended_file">sended_file</h3>

<p>文件发送完成后触发</p>

<p>参数：</p>

<ul>
<li>sendId——被发送的文件Id</li>

<li>socketId——接收者的id</li>

<li>file——被发送的文件对象</li>
</ul>

<h3 id="receive_file_chunk">receive_file_chunk</h3>

<p>接收到文件碎片时触发</p>

<p>参数：</p>

<ul>
<li>sendId——接收的文件的Id</li>

<li>socketId——发送者的id</li>

<li>fileName——文件的名称</li>

<li>percent——文件接收到的百分比</li>
</ul>

<h3 id="receive_file">receive_file</h3>

<p>接收完整个文件后触发</p>

<p>参数：</p>

<ul>
<li>sendId——接收的文件的Id</li>

<li>socketId——发送者的id</li>

<li>name——接收到的文件的名称</li>
</ul>

<h3 id="receive_file_ask">receive_file_ask</h3>

<p>接收到文件发送请求后触发</p>

<p>参数：</p>

<ul>
<li>sendId——被请求接收的文件的id</li>

<li>socketId——发送者的id</li>

<li>fileName——被请求接收的文件的名称</li>

<li>fileSize——被请求接收的文件的大小</li>
</ul>

<h3 id="receive_file_error">receive_file_error</h3>

<p>接收文件错误时触发</p>

<p>参数：</p>

<ul>
<li>error——错误对象</li>

<li>sendId——接收文件的id</li>

<li>socketId——发送者的id</li>
</ul> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/17/SkyRTC-client-doc</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用WebRTC搭建前端视频聊天室——入门篇 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/15/webRTC-1</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 15 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="webrtc">什么是WebRTC？</h2>

<p>众所周知，浏览器本身不支持相互之间直接建立信道进行通信，都是通过服务器进行中转。比如现在有两个客户端，甲和乙，他们俩想要通信，首先需要甲和服务器、乙和服务器之间建立信道。甲给乙发送消息时，甲先将消息发送到服务器上，服务器对甲的消息进行中转，发送到乙处，反过来也是一样。这样甲与乙之间的一次消息要通过两段信道，通信的效率同时受制于这两段信道的带宽。同时这样的信道并不适合数据流的传输，如何建立浏览器之间的点对点传输，一直困扰着开发者。WebRTC应运而生</p>

<p>WebRTC是一个开源项目，旨在使得浏览器能为实时通信（RTC）提供简单的JavaScript接口。说的简单明了一点就是让浏览器提供JS的即时通信接口。这个接口所创立的信道并不是像WebSocket一样，打通一个浏览器与WebSocket服务器之间的通信，而是通过一系列的信令，建立一个浏览器与浏览器之间（peer-to-peer）的信道，这个信道可以发送任何数据，而不需要经过服务器。并且WebRTC通过实现MediaStream，通过浏览器调用设备的摄像头、话筒，使得浏览器之间可以传递音频和视频</p>

<h2 id="webrtc_2">WebRTC已经在我们的浏览器中</h2>

<p>这么好的功能，各大浏览器厂商自然不会置之不理。现在WebRTC已经可以在较新版的Chrome、Opera和Firefox中使用了，著名的浏览器兼容性查询网站caniuse上给出了一份详尽的浏览器兼容情况</p>

<p><img src="http://skyinlayer.com/images/WebRTC/1.png" alt="WebRTC浏览器兼容性from caniuse.com" /></p>

<p>另外根据36Kr前段时间的新闻<a href="http://www.36kr.com/p/205614.html">Google推出支持WebRTC及Web Audio的Android 版Chrome 29@36kr</a>和<a href="http://www.36kr.com/p/210209.html">Android版Opera开始支持WebRTC，允许用户在没有任何插件的情况下实现语音和视频聊天</a>，Android也开始支持WebRTC</p>

<h2 id="">三个接口</h2>

<p>WebRTC实现了三个API，分别是:</p>

<ul>
<li>MediaStream：通过MediaStream的API能够通过设备的摄像头及话筒获得视频、音频的同步流</li>

<li>RTCPeerConnection：RTCPeerConnection是WebRTC用于构建点对点之间稳定、高效的流传输的组件</li>

<li>RTCDataChannel：RTCDataChannel使得浏览器之间（点对点）建立一个高吞吐量、低延时的信道，用于传输任意数据</li>
</ul>

<p>这里大致上介绍一下这三个API</p>

<h2 id="mediastreamgetusermedia">MediaStream（getUserMedia）</h2>

<p>MediaStream API为WebRTC提供了从设备的摄像头、话筒获取视频、音频流数据的功能</p>

<h3 id="w3c">W3C标准</h3>

<p><a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html">W3C标准传送门</a></p>

<h3 id="_2">如何调用</h3>

<p>同门可以通过调用navigator.getUserMedia()，这个方法接受三个参数：</p>

<ol>
<li>一个约束对象（constraints object），这个后面会单独讲</li>

<li>一个调用成功的回调函数，如果调用成功，传递给它一个流对象</li>

<li>一个调用失败的回调函数，如果调用失败，传递给它一个错误对象</li>
</ol>

<h3 id="_3">浏览器兼容性</h3>

<p>由于浏览器实现不同，他们经常会在实现标准版本之前，在方法前面加上前缀，所以一个兼容版本就像这样</p>

<pre class="javacript"><code class="javacript">var getUserMedia = (navigator.getUserMedia || 
                    navigator.webkitGetUserMedia || 
                    navigator.mozGetUserMedia || 
                    navigator.msGetUserMedia);</code></pre>

<h3 id="_4">一个超级简单的例子</h3>

<p>这里写一个超级简单的例子，用来展现getUserMedia的效果：</p>

<pre class="xml"><code class="xml">&lt;!doctype html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;GetUserMedia实例&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;video id=&quot;video&quot; autoplay&gt;&lt;/video&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);

    getUserMedia.call(navigator, {
        video: true,
        audio: true
    }, function(localMediaStream) {
        var video = document.getElementById(&#39;video&#39;);
        video.src = window.URL.createObjectURL(localMediaStream);
        video.onloadedmetadata = function(e) {
            console.log(&quot;Label: &quot; + localMediaStream.label);
            console.log(&quot;AudioTracks&quot; , localMediaStream.getAudioTracks());
            console.log(&quot;VideoTracks&quot; , localMediaStream.getVideoTracks());
        };
    }, function(e) {
        console.log(&#39;Reeeejected!&#39;, e);
    });
&lt;/script&gt;
&lt;/html&gt;</code></pre>

<p>将这段内容保存在一个HTML文件中，放在服务器上。用较新版本的Opera、Firefox、Chrome打开，在浏览器弹出询问是否允许访问摄像头和话筒，选同意，浏览器上就会出现摄像头所拍摄到的画面了</p>

<p>注意，HTML文件要放在服务器上，否则会得到一个NavigatorUserMediaError的错误，显示PermissionDeniedError，最简单方法就是cd到HTML文件所在目录下，然后<code>python -m SimpleHTTPServer</code>（装了python的话），然后在浏览器中输入<code>http://localhost:8000/{文件名称}.html</code></p>

<p>这里使用<code>getUserMedia</code>获得流之后，需要将其输出，一般是绑定到<code>video</code>标签上输出，需要使用<code>window.URL.createObjectURL(localMediaStream)</code>来创造能在<code>video</code>中使用<code>src</code>属性播放的Blob URL，注意在<code>video</code>上加入<code>autoplay</code>属性，否则只能捕获到一张图片</p>

<p>流创建完毕后可以通过<code>label</code>属性来获得其唯一的标识，还可以通过<code>getAudioTracks()</code>和<code>getVideoTracks()</code>方法来获得流的追踪对象数组（如果没有开启某种流，它的追踪对象数组将是一个空数组）</p>

<h3 id="constraints">约束对象（Constraints）</h3>

<p>约束对象可以被设置在<code>getUserMedia()</code>和RTCPeerConnection的<code>addStream</code>方法中，这个约束对象是WebRTC用来指定接受什么样的流的，其中可以定义如下属性：</p>

<ul>
<li>video: 是否接受视频流</li>

<li>audio：是否接受音频流</li>

<li>MinWidth: 视频流的最小宽度</li>

<li>MaxWidth：视频流的最大宽度</li>

<li>MinHeight：视频流的最小高度</li>

<li>MaxHiehgt：视频流的最大高度</li>

<li>MinAspectRatio：视频流的最小宽高比</li>

<li>MaxAspectRatio：视频流的最大宽高比</li>

<li>MinFramerate：视频流的最小帧速率</li>

<li>MaxFramerate：视频流的最大帧速率</li>
</ul>

<p>详情见<a href="http://tools.ietf.org/html/draft-alvestrand-constraints-resolution-00">Resolution Constraints in Web Real Time Communications draft-alvestrand-constraints-resolution-00</a></p>

<h2 id="rtcpeerconnection">RTCPeerConnection</h2>

<p>WebRTC使用RTCPeerConnection来在浏览器之间传递流数据，这个流数据通道是点对点的，不需要经过服务器进行中转。但是这并不意味着我们能抛弃服务器，我们仍然需要它来为我们传递信令（signaling）来建立这个信道。WebRTC没有定义用于建立信道的信令的协议：信令并不是RTCPeerConnection API的一部分</p>

<h3 id="_5">信令</h3>

<p>既然没有定义具体的信令的协议，我们就可以选择任意方式（AJAX、WebSocket），采用任意的协议（SIP、XMPP）来传递信令，建立信道，比如我写的<a href="https://github.com/LingyuCoder/SkyRTC-demo">demo</a>，就是用的node的ws模块，在WebSocket上传递信令</p>

<p>需要信令来交换的信息有三种：</p>

<ul>
<li>session的信息：用来初始化通信还有报错</li>

<li>网络配置：比如IP地址和端口啥的</li>

<li>媒体适配：发送方和接收方的浏览器能够接受什么样的编码器和分辨率</li>
</ul>

<p>这些信息的交换应该在点对点的流传输之前就全部完成，一个大致的架构图如下：</p>

<p><img src="http://skyinlayer.com/images/WebRTC/2.png" alt="JSEP架构" /></p>

<h3 id="_6">通过服务器建立信道</h3>

<p>这里再次重申，就算WebRTC提供浏览器之间的点对点信道进行数据传输，但是建立这个信道，必须有服务器的参与。WebRTC需要服务器对其进行四方面的功能支持：</p>

<ol>
<li>用户发现以及通信</li>

<li>信令传输</li>

<li>NAT/防火墙穿越</li>

<li>如果点对点通信建立失败，可以作为中转服务器</li>
</ol>

<h3 id="nat">NAT/防火墙穿越技术</h3>

<p>建立点对点信道的一个常见问题，就是NAT穿越技术。在处于使用了NAT设备的私有TCP/IP网络中的主机之间需要建立连接时需要使用NAT穿越技术。以往在VoIP领域经常会遇到这个问题。目前已经有很多NAT穿越技术，但没有一项是完美的，因为NAT的行为是非标准化的。这些技术中大多使用了一个公共服务器，这个服务使用了一个从全球任何地方都能访问得到的IP地址。在RTCPeeConnection中，使用ICE框架来保证RTCPeerConnection能实现NAT穿越</p>

<p>ICE，全名叫交互式连接建立（Interactive Connectivity Establishment）,一种综合性的NAT穿越技术，它是一种框架，可以整合各种NAT穿越技术如STUN、TURN（Traversal Using Relay NAT 中继NAT实现的穿透）。ICE会先使用STUN，尝试建立一个基于UDP的连接，如果失败了，就会去TCP（先尝试HTTP，然后尝试HTTPS），如果依旧失败ICE就会使用一个中继的TURN服务器。</p>

<p>我们可以使用Google的STUN服务器：<code>stun:stun.l.google.com:19302</code>，于是乎，一个整合了ICE框架的架构应该长这个样子</p>

<p><img src="http://skyinlayer.com/images/WebRTC/3.png" alt="整合了ICE框架的WebRTC应用架构" /></p>

<h3 id="_7">浏览器兼容</h3>

<p>还是前缀不同的问题，采用和上面类似的方法：</p>

<pre class="javascript"><code class="javascript">var PeerConnection = (window.PeerConnection ||
                    window.webkitPeerConnection00 || 
                    window.webkitRTCPeerConnection || 
                    window.mozRTCPeerConnection);</code></pre>

<h3 id="_8">创建和使用</h3>

<pre class="javascript"><code class="javascript">//使用Google的stun服务器
var iceServer = {
    &quot;iceServers&quot;: [{
        &quot;url&quot;: &quot;stun:stun.l.google.com:19302&quot;
    }]
};
//兼容浏览器的getUserMedia写法
var getUserMedia = (navigator.getUserMedia ||
                    navigator.webkitGetUserMedia || 
                    navigator.mozGetUserMedia || 
                    navigator.msGetUserMedia);
//兼容浏览器的PeerConnection写法
var PeerConnection = (window.PeerConnection ||
                    window.webkitPeerConnection00 || 
                    window.webkitRTCPeerConnection || 
                    window.mozRTCPeerConnection);
//与后台服务器的WebSocket连接
var socket = __createWebSocketChannel();
//创建PeerConnection实例
var pc = new PeerConnection(iceServer);
//发送ICE候选到其他客户端
pc.onicecandidate = function(event){
    socket.send(JSON.stringify({
        &quot;event&quot;: &quot;__ice_candidate&quot;,
        &quot;data&quot;: {
            &quot;candidate&quot;: event.candidate
        }
    }));
};
//如果检测到媒体流连接到本地，将其绑定到一个video标签上输出
pc.onaddstream = function(event){
    someVideoElement.src = URL.createObjectURL(event.stream);
};
//获取本地的媒体流，并绑定到一个video标签上输出，并且发送这个媒体流给其他客户端
getUserMedia.call(navigator, {
    &quot;audio&quot;: true,
    &quot;video&quot;: true
}, function(stream){
    //发送offer和answer的函数，发送本地session描述
    var sendOfferFn = function(desc){
            pc.setLocalDescription(desc);
            socket.send(JSON.stringify({ 
                &quot;event&quot;: &quot;__offer&quot;,
                &quot;data&quot;: {
                    &quot;sdp&quot;: desc
                }
            }));
        },
        sendAnswerFn = function(desc){
            pc.setLocalDescription(desc);
            socket.send(JSON.stringify({ 
                &quot;event&quot;: &quot;__answer&quot;,
                &quot;data&quot;: {
                    &quot;sdp&quot;: desc
                }
            }));
        };
    //绑定本地媒体流到video标签用于输出
    myselfVideoElement.src = URL.createObjectURL(stream);
    //向PeerConnection中加入需要发送的流
    pc.addStream(stream);
    //如果是发送方则发送一个offer信令，否则发送一个answer信令
    if(isCaller){
        pc.createOffer(sendOfferFn);
    } else {
        pc.createAnswer(sendAnswerFn);
    }
}, function(error){
    //处理媒体流创建失败错误
});
//处理到来的信令
socket.onmessage = function(event){
    var json = JSON.parse(event.data);
    //如果是一个ICE的候选，则将其加入到PeerConnection中，否则设定对方的session描述为传递过来的描述
    if( json.event === &quot;__ice_candidate&quot; ){
        pc.addIceCandidate(new RTCIceCandidate(json.data.candidate));
    } else {
         pc.setRemoteDescription(new RTCSessionDescription(json.data.sdp));
    }
};
</code></pre>

<h3 id="_9">实例</h3>

<p>由于涉及较为复杂灵活的信令传输，故这里不做简短的实例，可以直接移步到最后</p>

<h2 id="rtcdatachannel">RTCDataChannel</h2>

<p>既然能建立点对点的信道来传递实时的视频、音频数据流，为什么不能用这个信道传一点其他数据呢？RTCDataChannel API就是用来干这个的，基于它我们可以在浏览器之间传输任意数据。DataChannel是建立在PeerConnection上的，不能单独使用</p>

<h3 id="datachannel">使用DataChannel</h3>

<p>我们可以使用<code>channel = pc.createDataCHannel(&quot;someLabel&quot;);</code>来在PeerConnection的实例上创建Data Channel，并给与它一个标签</p>

<p>DataChannel使用方式几乎和WebSocket一样，有几个事件：</p>

<ul>
<li>onopen</li>

<li>onclose</li>

<li>onmessage</li>

<li>onerror</li>
</ul>

<p>同时它有几个状态，可以通过<code>readyState</code>获取：</p>

<ul>
<li>connecting: 浏览器之间正在试图建立channel</li>

<li>open：建立成功，可以使用<code>send</code>方法发送数据了</li>

<li>closing：浏览器正在关闭channel</li>

<li>closed：channel已经被关闭了</li>
</ul>

<p>两个暴露的方法:</p>

<ul>
<li>close(): 用于关闭channel</li>

<li>send()：用于通过channel向对方发送数据</li>
</ul>

<h3 id="data_channel">通过Data Channel发送文件大致思路</h3>

<p>JavaScript已经提供了File API从<code>input[type=&#39;file&#39;]</code>的元素中提取文件，并通过FileReader来将文件的转换成DataURL，这也意味着我们可以将DataURL分成多个碎片来通过Channel来进行文件传输</p>

<h2 id="demo">一个综合的Demo</h2>

<p><a href="https://github.com/LingyuCoder/SkyRTC-demo">SkyRTC-demo</a>，这是我写的一个Demo。建立一个视频聊天室，并能够广播文件，当然也支持单对单文件传输，写得还很粗糙，后期会继续完善</p>

<h3 id="_10">使用方式</h3>

<ol>
<li>下载解压并cd到目录下</li>

<li>运行<code>npm install</code>安装依赖的库（express, ws, node-uuid）</li>

<li>运行<code>node server.js</code>，访问<code>localhost:3000</code>，允许摄像头访问</li>

<li>打开另一台电脑，在浏览器（Chrome和Opera，还未兼容Firefox）打开<code>{server所在IP}:3000</code>，允许摄像头和话筒访问</li>

<li>广播文件：在左下角选定一个文件，点击“发送文件”按钮</li>

<li>广播信息：左下角input框输入信息，点击发送</li>

<li>可能会出错，注意F12对话框，一般F5能解决</li>
</ol>

<h3 id="_11">功能</h3>

<p>视频音频聊天（连接了摄像头和话筒，至少要有摄像头），广播文件（可单独传播，提供API，广播就是基于单独传播实现的，可同时传播多个，小文件还好说，大文件坐等内存吃光），广播聊天信息</p>

<h2 id="_12">参考资料</h2>

<ul>
<li><a href="http://www.webrtc.org/">WebRTC官方网站</a></li>

<li><a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html">W3C-GetUserMedia</a></li>

<li><a href="http://dev.w3.org/2011/webrtc/editor/webrtc.html">W3C-WebRTC</a></li>

<li><a href="http://www.html5rocks.com/en/tutorials/getusermedia/intro/">Capturing Audio &amp; Video in HTML5@html5rocks</a></li>

<li><a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/">Getting Started with WebRTC@html5rocks</a></li>

<li><a href="http://caniuse.com">caniuse</a></li>

<li><a href="http://zh.wikipedia.org/wiki/%E4%BA%92%E5%8B%95%E5%BC%8F%E9%80%A3%E6%8E%A5%E5%BB%BA%E7%AB%8B">ICE交互式连接建立</a></li>
</ul> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/15/webRTC-1</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《Don`t make me think》读书笔记——大的方面和外界影响 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/12/dont-make-me-think-4</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 12 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">可用性是礼貌</h2>

<h3 id="_2">好感度存储器</h3>

<p>可以想象，我们每次进入一个网站，都从一个好感存储器开始，在网站上遇到的每个问题都会降低好感存储器的高度。这个存储器容量是有限的，如果对用户的态度恶劣，把它消耗殆尽，用户就很可能离开网站。这样的好感存储器，有以下几点值得注意：</p>

<ol>
<li>因个人的特质不同而不同，有的人有耐心，有的人脾气不好</li>

<li>根据情况而定，赶时间或者刚刚在一个另一个网站上得到糟糕的体验，那么进入网站是，好感程度已经很低了</li>

<li>可以重新填满它，即使犯了一些错误，降低了好感，可以通过一些其他事来弥补</li>

<li>有是有一个错误就能清空它</li>
</ol>

<h3 id="_3">降低好感的几种方式</h3>

<ol>
<li>隐藏用户想要的信息</li>

<li>没有按照网站的设计行事而惩罚用户，比如表单验证错误后需要重新输入</li>

<li>询问不必要的信息，用户很介意个人信息</li>

<li>敷衍用户、欺骗用户，不需要虚伪的真诚、假意的关心</li>

<li>为用户设置障碍，不得不等待一个介绍或必须看一些图片，都是为用户设置障碍</li>

<li>网站看上去不专业，网站看上去凌乱，用户会失去好感</li>
</ol>

<h3 id="_4">提高好感的几种方式</h3>

<ol>
<li>知道人们在你的网站上想做什么，并让他们明白简易</li>

<li>告诉用户他们想知道的</li>

<li>尽量减少步骤</li>

<li>花点心思</li>

<li>知道用户肯能有哪些疑问，并给与解答</li>

<li>提供协助，例如打印友好页面</li>

<li>容易从错误中回复</li>

<li>如果不确定，记得道歉</li>
</ol>

<h2 id="_5">可访问性</h2>

<p>可访问性是可用性的一部分，除非确定了哪些残障人士都不是目标用户，否则如果网站的可访问性不足，就不能说它是可用的</p>

<h3 id="_6">开发人员和设计人员所听到的</h3>

<p>大多数公司里，负责实现可访问性的人是实际上建造网站的人：开发人员和设计师</p>

<p>有很多不太可能让开发人员和设计师相信他们应该支持可访问性的理由，尤其是两点：</p>

<ol>
<li>他们的世界里主要是健全人，很难让他们相信有相当比例的人会贞德在访问网络时需要帮助</li>

<li>他们怀疑更好的访问性能否能让所有人收益</li>
</ol>

<p>事实上，支持可访问性的重要理由就是：支持可访问性才是正确的做法</p>

<h3 id="_7">开发人员和设计师们害怕的</h3>

<p>对于可访问性了解更多时，会让他们觉得害怕，因为：</p>

<ol>
<li>这意味着更大的工作量，特别是对于开发人员而言，实现可访问性就像往他们已经不可能完成的项目计划中再添加一项复杂的新任务，同时还伴随着很多费时费力的报告、评审、特别会议等等</li>

<li>设计折衷，设计师们担心对于网站的大部分目标用户而言，自己不得不让网站的手机变得不那么吸引人</li>
</ol>

<h3 id="_8">解决方案</h3>

<p>我们可以用一个Bobby那样的检查器来保证网站符合WCAG的标准</p>

<h3 id="_9">能正确实施的五件事</h3>

<ol>
<li>改正让所有人改到混淆的可用性问题，让网站对我们其他的人更好用，会让残障人士也更好用</li>

<li>读一篇文章， 网站可访问性及可用指南：屏幕阅读器用户观察。绝大多数盲人用户和正常用户一样没耐心，他们希望尽快得到自己需要的信息</li>

<li>看一本书，阅读一本关于Web可访问性的书籍</li>

<li>使用级联样式表，它有以下几个好处
<ol>
<li>灵活性</li>

<li>浏览器之间的一致性</li>

<li>序列化内容</li>

<li>允许重新定义文字大小</li>
</ol>
</li>

<li>在HTML代码中做一些具体的变更
<ol>
<li>为每张图片增加alt文本</li>

<li>让表单配合屏幕阅读器</li>

<li>在每页的最前面添加一个“跳转到主要内容”的链接</li>

<li>让所有内容都可以通过键盘访问</li>

<li>没有充分的理由，不要使用JavaScript</li>

<li>使用客户端的影像地图</li>
</ol>
</li>
</ol> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/12/dont-make-me-think-4</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《Don`t make me think》读书笔记——确定你没有做错的几件事 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/12/dont-make-me-think-3</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 12 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="web">为什么Web设计团队通论可用性是在浪费时间，如何避免这种情况</h2>

<h3 id="">每个人都有自己的喜好</h3>

<p>每个人，无论是真正的用户还是建造网站的人，自己也是Web用户，和其他所有的Web用户一样，会对网站上自己喜欢什么、不喜欢什么有着强烈的感觉。同时我们通常会认为大部分Web用户和我们一样</p>

<h3 id="_2">不同的职位，不同的目标</h3>

<p>每个职位都有自己对网站的期望，以设计师和开发人员为例，设计师通常认为，大多数人喜欢视觉上看起来有趣的网站，因为设计师们喜欢这样的网站。而另一方面，开发人员认为人们喜欢功能又多又酷的网站，因为开发人员喜欢这样的网站</p>

<h3 id="_3">没有人能代表普通用户</h3>

<p>“大部分Web用户和我们一样”这种信仰足以让通常的Web设计会议陷入僵局，在这个信仰背后还隐藏着一个更深的信仰–相信大部分Web用户是弹性的，可以随意变化。但事实上，所有Web用户多事独一无二的，所有的Web使用都是不一样的。试图用一些简单的喜好来形容用户毫无意义。好的设计自然会把这种复杂性考虑进去。</p>

<p>什么是好的设计呢？事实上对于大部分设计问题来说，没有简单的“正确”答案。良好的、一体化的设计能满足需要，也就是说，经过仔细考虑、实现和测试的设计就是好的</p>

<h3 id="_4">如何解决</h3>

<p>只有一种方式来解决，就是测试。必须使用团队的集体技巧、经验、创造力和判断力来创建一些版本，然后仔细观察人们对它的看法和使用的方法</p>

<h2 id="_5">如何测试一个网站？</h2>

<p>设计网站时，市场部门的人往往觉得自己没有什么影响力，尽管他们在研究网站的目标用户和目标用户需求方面花费的时间最多，但是设计师和开发人员往往是最有权力决定网站最后是什么样子的人</p>

<h3 id="_6">焦点小组测试</h3>

<p>在一次焦点小组研究中，一小组人（5-8人）围坐在桌子边，对展示给他们的想法和设计做出反应。主要价值来自参与成员彼此的反应。这是快速得到用户意见和感觉的一种不错的方法</p>

<p>焦点小组在抽象的确定目标用户想要什么、需要什么、喜欢什么的时候会很有用。同时也可以测试出网站的理念是否有意义，价值主张是否吸引人。同时在测试网站功能命名、发现用户对竞争对手看法等方面，也是很好的办法</p>

<h3 id="_7">可用性测试</h3>

<p>在一次可用性测试中，一次一个用户展示一些内容（不管是网站、还是网站原型、还是单个页面的草图），要求用户说出：</p>

<ol>
<li>这是什么</li>

<li>试着用它来完成一项典型的任务</li>
</ol>

<h3 id="_8">选用哪种测试？</h3>

<p>焦点小组测试不适合用来了解网站的运行情况，以及怎样改进网站</p>

<h3 id="_9">关于测试的几个事实</h3>

<ol>
<li>如果想建立一个优秀的网站，一定要测试</li>

<li>测试一个用户比不错测试好一倍</li>

<li>在项目中，早点测试已为用户好过最后测试50位用户，早做测试才能用上测试所得。事实上，一旦网站投入使用，要改变它就不是那么容易了，很多用户拒绝做出任何变化，即便很小的变更也会给他们带来深远的影响</li>

<li>人们对招募用户代表的重要性估计过高</li>

<li>测试的关键不是要证明什么或者反驳什么，而是了解自己的判断力。测试能做的就是给你提供有价值的参考，加上你的经验、专业判断和尝试能够更容易做出自信的选择</li>

<li>测试是一个迭代过程</li>

<li>没有什么比现场用户的反应更重要</li>
</ol>

<p>如果想知道软件、网站是否容易使用，那么在一些人视图使用的时候观察他们，记下他们在哪里遇到问题，然后修改这些问题，再度测试</p>

<h3 id="34">每组的测试人数（3-4个）</h3>

<p>每轮测试的理想用户数量是3-4个，前三个用户很可能会遇到几乎所有最明显的问题，并且最重要的是多做几轮测试，而不是谢谢爱每轮测试里面发现的所有问题，3-4名测试用户有助于保证很快进入下一轮测试</p>

<h3 id="_10">宽松招募，曲线上升</h3>

<p>在决定要进行测试后，团队通常会花很多时间来招募他们认为能准确反应他们目标群体的测试用户。然而，对于可用性测试的最大秘密就是，测试对象是谁并不重要，对于大部分网站而言，用只需要懂得上网基本知识的用户就可以了。推荐的方式：利用你能够找到的任何人（满足最低要求），然后曲线上升。理由如下：</p>

<ul>
<li>实际上，我们都是初学者</li>

<li>设计出的网站只有你的目标群体能使用，这不是一个好主意</li>

<li>专家通常不会介意对初学者来说很清楚的界面</li>
</ul>

<p>当然也有一些例外情况发生，比如：</p>

<ul>
<li>网站几乎只由某一类用户使用，而且招募这一类测试用户并不困难，那么就去招募</li>

<li>目标用户群体可以分成几个明显的阵营，而且这些阵营有着完全不同的兴趣和需要，那么至少要从每个阵营里选择用户进行一次测试</li>

<li>使用网站需要专门的领域知识，那么至少才一个回合的测试中招募具有该领域知识的用户</li>
</ul>

<p>在进行测试人员找牧时，需要做到如下几点：</p>

<ul>
<li>提供合理的奖励</li>

<li>邀请要简单</li>

<li>避免对网站（或网站背后的组织结构）进行预先讨论</li>

<li>别不好意思请朋友和邻居帮忙</li>
</ul>

<h3 id="_11">什么时候测试</h3>

<p>在Web开发的各个阶段尽早进行测试，甚至在开始设计之前，应该测试一下同类的网站，对于同类网站可以进行两种测试：</p>

<ol>
<li>“理解”测试：让测试用户看到网站，然后看他们是否能理解这个网站，理解网站的目标、价值主张、组织方法、运行方法</li>

<li>关键任务测试，让用户完成一些任务，然后观察他们是怎么做的</li>
</ol>

<h3 id="_12">立刻回顾测试结果</h3>

<p>测试完后的会议上，应该做两件事：</p>

<ol>
<li>给问题分类：回顾大家看到的问题，决定哪些问题需要修正</li>

<li>解决问题：找出修正这些问题的方法</li>
</ol>

<h3 id="_13">常见问题</h3>

<p>测试过程中，最有可能遇到几个问题：</p>

<ol>
<li>用户不清楚概念，他们不理解，他们看着网站或者页面，要么不知道他们说的是什么，要么他们以为自己知道，但是理解有误</li>

<li>他们找不到自己要找的字眼，这通常意味着 1) 用来组织内容的分类不符合用户的习惯 2) 分类符合他们的习惯,但没有使用他们期望的名字</li>

<li>内容太多了，我们需要 1)减少页面上的整体干扰 2)把他们需要看到的内容设置的更加醒目</li>
</ol>

<h3 id="_14">一些问题分类指南</h3>

<ol>
<li>在任何测试中，都有可能遇到这样的情况，用户暂时出现错误，然后又在没有任何帮助的情况下回到原来的轨道。这中情况可以忽略，无须在意</li>

<li>抵制添加的冲动，在测试看到人们没有理解某些内容时，大部分人会选择增加一些注释或指导说明。但正确的解决方案往往是去除某个（一些）让人混淆的东西，而不是增加另一些干扰</li>

<li>不要太看重人们对新功能的要求</li>

<li>每轮测试中，主要目标是寻找重要而不费力的收获，一般有两种，1)当大家看到第一个用户试着勉强应付的时候，问题和结局方法都很明显的情况 2)需要实现两种变更，几乎毫不费力的或者需要费一点力气，但效果很明显的</li>
</ol>

<h3 id="_15">别过火</h3>

<p>测试真正的挑战不是修正所发现的问题，而是修正问题的时候，不破坏已经正常运行的部分</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/12/dont-make-me-think-3</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《Don`t make me think》读书笔记——必须正确处理的几个方面 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/12/dont-make-me-think-2</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 12 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">设计导航</h2>

<p>如果网站上找不到方向，人们不会使用你的网站。作为一个用户，如果到了一个网站，没有找到需要的内容，或者不知道网站怎么组织的，可能还会回来</p>

<h3 id="_2">网站导航</h3>

<p>用户通常是为了寻找某个目标而来。他们会进行思考，是先询问（搜索），还是先浏览。通常用户决定是先搜索还是先浏览取决于他们的打算、匆忙程度，以及网站是否具有良好的导航机制。如果选择浏览，他们将通过标志的引导在层次结构中穿行。最后他们如果没有找到想要的东西，会离开。</p>

<h3 id="_3">无法承受的浏览之轻</h3>

<p>网络上查找东西和真实世界有很多相似之处，但也有很多不同，比如：</p>

<ul>
<li>用户无法感觉到网站本身的大小</li>

<li>用户不会有方向的感觉</li>

<li>用户感觉不到位置</li>
</ul>

<p>在真实世界中，查找过一次的货物，会和容易去。而在Web上，通过点击链接向前移动。想要再次访问网站上的某个内容，需要记住它在概念层次上的位置，然后重新顺着以往的链接过去。使用Web导航，就是为了让用户得知他们当前的位置，导航通过具体化网站的层次结构，来补偿确实的现实空间感</p>

<h3 id="_4">被忽视了的导航用途</h3>

<p>导航有两个显而易见的用途： 帮助我们找到想要的东西和告诉我们现在身在何处，其实导航的所有用途有：</p>

<ul>
<li>给了哦我们一些固定的感觉</li>

<li>告诉我们当前的位置</li>

<li>告诉我们如何使用网站</li>

<li>给了我们对网站建造者的信心</li>
</ul>

<h3 id="web">Web导航习惯用法</h3>

<p>设计得当的持久导航需要表达的意思：导航部分在这里，其中一些可能会根据您所处的位置有所变化，但它总是在这里</p>

<p>持久导航包括5个元素，这5个元素是用户一直需要的：</p>

<ol>
<li>站点ID</li>

<li>回到主页的方式</li>

<li>搜索的方式</li>

<li>实用工具</li>

<li>栏目</li>
</ol>

<h3 id="_5">我说的是每一页</h3>

<p>对于每个地方都一样的规则，有两个例外：</p>

<ul>
<li>主页，主页承担着一些不同的任务，有时候在主页内不必使用持久导航</li>

<li>表单，在需要填写表单的页面，持久导航可能会造成不必要的干扰</li>
</ul>

<p>对于这些页面，只需要站点ID，一个回到主页的链接，有助于谈些表单的实用工具这样最小规模的持久导航就可以了</p>

<h3 id="_6">知道我们还在网站里</h3>

<p>在网站里，我们移动方式是瞬移，我们需要在每个页面上见到网站的名称以保证我们还在网站中。站点的ID代表整个网站，所以站点的ID应该在页面可视层次的首要位置。通常可以让它成为本页最显眼的内容，或者让它涵盖页面所有元素。另外站点ID应该一眼看起来就像一个站点ID</p>

<h3 id="_7">栏目</h3>

<p>也称主导航条，到达站点主要栏目的链接，层次结构的最顶层。有时会包含二级导航</p>

<h3 id="_8">实用工具</h3>

<p>帮助用户使用站点，或提供网站发布者信息，例如帮助，联系我们等等，对于不同类型的万展，实用工具有所不同。通常，持久导航上只能放置4-5个实用工具</p>

<h3 id="_9">返回主页</h3>

<p>最重要的元素之一，新兴的用法就是让站点ID同时也作为一个让用户回到主页的按钮，或者用下列两种方式：</p>

<ul>
<li>在栏目中或实用工具中包含一个回到主页的链接</li>

<li>在主页之外的站点ID上加上一个Home，让大家知道可以点击它</li>
</ul>

<h3 id="_10">提供搜索</h3>

<p>除非站点规模很小而且组织得很好，否则每个页面都应该有一个搜索框或一个到搜索页面的链接。除非网站真的不太需要搜索，否则它应该是一个搜索框</p>

<p>搜索框需要注意：</p>

<ul>
<li>花哨的用词，用搜索就好，不要用查找，快速查找之类的词</li>

<li>指示说明：告诉用户搜索框的使用方式</li>

<li>选项，如果有存在任何混淆的搜索范围，需要将他们写出来。在提供时，需要谨慎思考</li>
</ul>

<h3 id="_11">多级导航</h3>

<p>Web设计中普遍存在一个问题，没有对低层次的导航给与足够的重视，在很多网站，一旦到了第二个层次一下，导航会变得支离破碎，因为：</p>

<ul>
<li>导航本身难以设计，页面空间有限</li>

<li>设计师即使在设计前两个层次时也感觉到时间不够</li>

<li>因为低级层次导航看起来不那么重要</li>
</ul>

<p>事实上用户在底层页面上花呃时间通常和花在顶层页面上的时间是相同的的</p>

<h3 id="_12">页面名称</h3>

<p>页面名称就像路牌一样： <em>　每个页面都需要一个名称</em>　页面名称应该出现在合适的位置上 <em>　名称要引人注目</em>　名称要和点击并来到这个页面的链接一致</p>

<h3 id="_13">你在这里</h3>

<p>提供你在这里指示器来告诉用户当前所在的位置，这个指示器需要突出，否则就是去了视觉线索的价值，而变成一种噪声。同时不能太过模糊</p>

<h3 id="_14">面包屑</h3>

<p>面包屑也告诉用户当前的位置，同时告诉了从主页到当前位置的路径，这是一种很重要的导航方式，能提供回退到任意层次，回到主页，提供当前位置等多个功能，有一些最佳实践：</p>

<ul>
<li>把他们放在页面最顶端，避免它和导航相混淆</li>

<li>使用”&gt;”进行层级分割</li>

<li>使用小字体：它只是补充机制</li>

<li>使用文字“你在这里”</li>

<li>最后一个元素加粗，最后一个元素时当前页面的名称，加粗可以得到应有的突出</li>

<li>没有把他们用作页面的名称</li>
</ul>

<h3 id="_15">标签页</h3>

<p>标签页是大型网站的上佳选择：</p>

<ul>
<li>标签页不言而喻，每个人都知道标签页是干什么的</li>

<li>标签页很难错过，用户都会留意到</li>

<li>他们很灵活</li>

<li>他们暗示了一个物理的空间</li>
</ul>

<p>标签页需要注意的三个要点：</p>

<ol>
<li>正确绘制，激活的标签页位于其他标签页之前</li>

<li>不是标签页功能的普通按钮，不要按照标签页的方式绘制</li>

<li>颜色编码，为每个栏目使用一种不同的颜色，吧这个颜色用在页面其他导航元素上，让他们浑然一体</li>

<li>当进入页面时，有一个标签页已经选中</li>
</ol>

<h3 id="_16">测试</h3>

<p>执行过程：</p>

<ol>
<li>任意选择一个网页，打印下来</li>

<li>拿到一手开外，或者斜过一个角度，让你不能仔细观察</li>

<li>尽快找到下面清单中的项目并画上圆圈（站点ID、页内导航、页面名称、你在这里指示器、栏目和下一级栏目、搜索）</li>
</ol>

<h2 id="_17">设计主页</h2>

<h3 id="_18">主页的任务</h3>

<p>主页要完成的任务：</p>

<ol>
<li>站点的标识和使命，告诉这是个什么网站，用来做什么的</li>

<li>站点层次，给出网站提供的服务的概貌，包括内容、功能、服务如何组织，可以交由持久导航处理</li>

<li>搜索，突出明显的搜索框</li>

<li>导读，用一些“里面有精彩内容”来吸引用户，内容推荐部分应该突出最新、最好、最流行的内容片断，功能推荐部分邀请我去访问网站更多栏目或使用一些个性化功能</li>

<li>内容更新，主页的内容应经常更新</li>

<li>友情链接</li>

<li>快捷方式，最常访问的内容片断值得将链接放在首页上</li>

<li>注册，如果网站提供注册，应为型用户和老用户登录提供了明显的链接，并用某种方式告诉他们知道自己是否已经登录</li>

<li>让我们看到正在寻找的东西</li>

<li>还有没有寻找的，主页应该让用户看到一些很精彩的，也许会感兴趣的内容</li>

<li>告诉用户从哪里开始</li>

<li>建立可信度和信任感</li>
</ol>

<h3 id="_19">主页的问题</h3>

<ul>
<li>需要推荐的内容很容易过多</li>

<li>主页十分重要，每个人都想对她发表看法</li>

<li>主页要呈现在每个访问者面前，适合所有人</li>
</ul>

<h3 id="_20">主页要传达整体形象</h3>

<p>一个主页应回答头脑里的四个问题：</p>

<ol>
<li>这是什么网站</li>

<li>我能在这里做什么</li>

<li>网站上有些什么</li>

<li>为什么我在这里，而不在别的地方</li>
</ol>

<h3 id="_21">如何传达</h3>

<p>在主页上有两个重要位置，我们希望能从这两个地方找到清除的陈述：</p>

<ol>
<li>口号，最有价值的位置之一就是靠近站点ID的地方</li>

<li>欢迎广告，在主页的首要位置显示，网站的简要描述</li>
</ol>

<p>传达信息的知道原则：</p>

<ul>
<li>需要多大空间就是用多大空间</li>

<li>不要使用过多的空间</li>

<li>不要把使命陈述当做欢迎公告</li>

<li>最重要的事件进行测试</li>
</ul>

<h3 id="_22">没有什么比得上一个好口号</h3>

<p>口号是一条精炼的短句，总结了这个企业是干什么的，为什么好。在网站中，口号可能出现在站点ID的下方、上方或旁边。选择口号时需要注意几点：</p>

<ul>
<li>口号要清楚，言之有物，不能含糊不清</li>

<li>长度适中</li>

<li>表述出网站的特点和显而易见的好处，不能听起来太笼统</li>

<li>有个性、生动、有时还很俏皮</li>
</ul>

<p>有些网站可以不需要口号，但他们也可以从口号中获益，例如</p>

<ul>
<li>家喻户晓的网站</li>

<li>品牌在网站建立之前就很有名的网站</li>
</ul>

<h3 id="_23">从哪里开始</h3>

<p>用户进入一个新网站，快速扫描主页后，应该能明白：</p>

<ul>
<li>如果我想搜索，从哪儿开始</li>

<li>如果想扫描，从哪儿开始</li>

<li>想扫描该网站最精彩的内容，从哪儿开始</li>
</ul>

<p>让每个起点看起来像起点。要清除的给他们加上文字描述</p>

<h3 id="_24">主页导航可以不一样</h3>

<p>主页独特的职责，不必使用持久导航，常见的差别包括：</p>

<ul>
<li>栏目描述，可以为栏目名称加上一个描述性短语</li>

<li>不同的方向，和其他页面布局不同</li>

<li>用于识别的空间更多</li>
</ul>

<p>主页导航和持久导航也应当保持一定程度上的一致性</p>

<h3 id="_25">下拉框的问题</h3>

<p>由于主页位置有限，经常会有使用下拉框的情况用来节约空间，但有几个问题：</p>

<ul>
<li>必须会造出下拉框，必须点击下拉框，才能看到下拉列表</li>

<li>他们难以扫描</li>

<li>不好控制，列表显示和收缩很快，影响查看效果</li>
</ul>

<p>如果用户不知道自己再找什么名称时，下拉框的效率很低</p>

<h3 id="_26">推荐的问题</h3>

<p>在主页上进行推荐因为其效果好，任何项目在主页上有一个醒目的链接，肯定会得到更多的访问量，但是在主页上增加更多的项目所得到的和所付出的不一致。任何共享的资源都会因为过度使用而遭到破坏。</p>

<h3 id="_27">测试</h3>

<p>看到一个主页，快速扫描，然后回答两个问题：</p>

<ol>
<li>这个网站是做什么的</li>

<li>从哪里开始</li>
</ol> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/12/dont-make-me-think-2</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《Don`t make me think》读书笔记——指导原则 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/12/dont-make-me-think-1</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 12 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="dont_make_me_think">Don`t make me think</h2>

<h3 id="">不言而喻、一目了然</h3>

<p>设计这应该尽量做到，当用户看到一个页面时，应该是不言而喻，一目了然，自我解释的。用户应该能明白它是什么、如何使用，而不需要花精力去思考。网页上每项内容都有可能迫使我们停下来思考，比如自以为很酷或自以为很聪明的名字、具体公司相关的名字，还有看起来不太明显的连接和按钮等等。在确定这些名字和按钮时，我们应该更倾向于显而易见，而不是需要额外的思考</p>

<h3 id="_2">用户的思考</h3>

<p>在用户访问网站时，经常会陷入下列思考中：</p>

<ul>
<li>我在什么位置</li>

<li>我该从哪儿开始</li>

<li>他们把XX放在哪儿了</li>

<li>这个页面上最重要的是什么</li>

<li>为什么叫这个名字</li>

<li>等等</li>
</ul>

<h3 id="_3">网页设计的目标</h3>

<p>网页最好是能达到一个目标，就是让普通用户只要看到它一眼，就知道是什么内容，如何使用它。因为大多数人会花比我们预计少的多的时间来浏览器网页</p>

<h2 id="web">我们实际上是如何使用Web的</h2>

<p>绝大部分用户，在大部分时间里，都只是在每个页面上行瞥一眼，扫过一些文字，点击第一个令他们感兴趣的或者大概符合他们寻找目标的链接。通常情况下，页面上有很多东西用户都不会去看，甚至当做从来没存在过。</p>

<h3 id="_4">不去阅读，而是扫描</h3>

<p>用户浏览页面，不会去阅读，而是扫描，因为：</p>

<ol>
<li>用户总是处于忙碌之中，他们使用Web是想节约时间，所以他们没有时间来阅读哪些不必要的内容</li>

<li>用户知道自己不需要阅读所有信息，他们只会对其中一小部分感兴趣，而他们也只会寻找这一部分并阅读它，扫描就是用户找到这一小部分内容的方式</li>

<li>在日常生活中，我们一直在扫描报纸、杂志、书籍，所以我们善于扫描</li>
</ol>

<h3 id="_5">不是最佳，而是满意</h3>

<p>用户不会做最佳的选择，而是满意即可。事实上，大多数时间用户都不会选择最佳选项，而是选择第一个合理的选项。因为:</p>

<ol>
<li>用户很忙，寻找最佳策略很难，需要很长时间，只是寻找满意策略效率要高得多</li>

<li>如果猜错了，不会有什么严重后果。网站上一次错误的选择，换来的不过是几次后退按钮罢了</li>

<li>对选择进行权衡并不会改善我们的机会</li>

<li>猜测更有意思，猜测不会像仔细衡量那么累，如果猜对了，速度会更快</li>
</ol>

<h3 id="_6">不问原理，只要能用</h3>

<p>用户不会追根究底，而是勉强应付。在很大程度上，人们在使用一些东西时，不会去理解他们的运作原理，甚至对他们的运作原理完全是错误的理解。在网页上也是一样，很多人完全不是以设计师设想的方式使用网络和软件，但是他们用得很好。因为：</p>

<ul>
<li>事物背后的工作机制往往对用户来说不中用，只要能正常使用它就行了</li>

<li>如果发现某个事物能用，用户就会一直用它，无论它有多难用，除非偶然发现一种更好地方法。用户不太会自己去找一种更好的方法</li>
</ul>

<p>所以，如果用户能很快的明白这个页面，那么：</p>

<ul>
<li>他们更容易找到自己所需要的东西</li>

<li>他们更容易理解网站提供哪些服务</li>

<li>你更可能引导他们去你所希望他们看到的地方</li>

<li>他们会觉得，在你的网站上，他们更能把握全局，这会让他们成为老用户</li>
</ul>

<h2 id="_7">为扫描设计，不为阅读设计</h2>

<h3 id="_8">视觉层次</h3>

<p>让页面在瞬间明白易懂的一个好办法是确保页面上所有内容的外观–所有的可视线索–清除，而且能偶准确的表达页面上内容之间的关系，也就是有清楚的视觉层次</p>

<p>视觉层次清楚的特点有：</p>

<ul>
<li>越重要的部分越突出</li>

<li>逻辑上相关的部分在视觉上也应当相关</li>

<li>逻辑上包含的部分，在视觉上应该进行嵌套</li>
</ul>

<p>用户每天都会对视觉层次进行分解，好的视觉层次通过预先处理页面，用一种我们能快速理解的方式对页面的内容进行组织并却分优先级，减少用户的对页面的思考，加快浏览页面找到所需内容的时间。如果页面没有清楚的视觉层次，用户将会被迫降低扫描页面的速度，寻找关键的文字和短语，然后拼凑出我们感觉重要的内容和内容的组织方式，加大了用户的思考内容</p>

<h3 id="_9">习惯用法</h3>

<p>由于文化的关系，用户从小会养成一种习惯用法，比如很大的短语它通常是标题，一张照片下面的文字要么是对照片的说明，要么是照片的拍摄者署名，等等。这些习惯用法根植在用户的脑海中，通过常年累月积累而来</p>

<p>关于Web上的习惯用法，有两点很重要：</p>

<ol>
<li>这些习惯用法非常有用，我们需要知道，习惯用法之所以会成为习惯，就是因为他们有用</li>

<li>设计师通常不愿意利用他们，设计师总是希望能做出一些崭新的，与众不同的设计，而不是使用那些原有的东西</li>
</ol>

<p>如果不打算使用一种已有的习惯用法，那也必须使用一种清楚地，能带来很大价值的习惯用法。所以，在清楚自己有个更好地想法时进行创新，否则尽量使用习惯用法</p>

<h3 id="_10">划分页面</h3>

<p>把页面划分成明确定义的区域很重要，因为这可以让用户很快的决定关注页面的哪些区域，或者放心的跳过哪些区域</p>

<h3 id="_11">明显标识可以点击的地方</h3>

<p>人们在网页上所做的大多数申请就是找到下一个地方点击，那么明确地标注哪些地方可以点击，哪些地方不能点击，这很重要</p>

<h3 id="_12">降低视觉噪声</h3>

<p>让页面不易理解的一个最大原因，就是视觉噪声，它分为两种：</p>

<ul>
<li>眼花缭乱</li>

<li>背景噪声</li>
</ul>

<p>在设计页面的时候，可以先假定所有内容都是视觉噪声，除非得到证明它们不是</p>

<h2 id="_13">为什么用户喜欢无需思考的选择</h2>

<p>一些站点规定，到达网页的任何页面需要点击的次数永远不能超过指定的次数（3、4、5）。但真正的问题不是到达目标之前要的点击次数（当然这里也要有个限度），而是每次点击需要多少思考。用户不介意有多少次点击，只要每次点击都毫不费力，并且能让用户坚信自己的选择正确。“三次无需思考、明确无误的点击相当于一次需要思考的点击”</p>

<h2 id="_14">省略不必要的文字</h2>

<h3 id="_15">页面到处是多余</h3>

<p>有力的文字都很简练。句子里不应该有多余的文字，段落里不应该有多余的句子。同样，画上不应该有多余的线条，机器上不应该有多余的零件。网页上大部分文字斗不过实在占地方，因为没有人打算读他们。去掉没有人看的文字，有三个好处：</p>

<ol>
<li>可以降低页面的噪声</li>

<li>让有用的内容更加突出</li>

<li>让页面更简短，用户一眼能看到更多的信息，而不用滚动屏幕</li>
</ol>

<h3 id="_16">去掉欢迎词</h3>

<p>欢迎词是一段引导性的文字，可能是欢迎我们来到这个站点，告诉这个网站有多棒，或者告诉我们在刚进入这个版面将会看到什么内容。很多欢迎词没有包括有用的信息，而是在一个劲的说自己有多好，而不是描述什么东西能让用户感觉更好。欢迎词就像闲聊，内容无所谓，主要是一种社交手段，但大部分Web用户没有时间闲聊，他们喜欢直截了当，所以尽量减少欢迎词，能减多少减多少</p>

<h3 id="_17">去掉指示说明</h3>

<p>多余文字的另一个主要来源就是指示说明，关于指示说明，没有人会细读他们，如果只是说明非常长，用户发现他们所需信息的机会就越小。我们应当让每项内容不言而喻来消除指示说明</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/12/dont-make-me-think-1</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——最佳实践 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/09/csszengarden-5</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 09 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h3 id="">若是不确信的话，就去验证</h3>

<p>在调试之前可以简单地验证一下代码，格式不正确的XHTML或CSS将会导致很多布局问题。W3C提供了XHTML和CSS的验证工具，链接<a href="http://validator.w3.org">XHTML</a>和<a href="http://jigsaw.w3.org/css-validator/">CSS</a></p>

<h3 id="css">创建并测试CSS时优先在最高级、最先进的浏览器中进行，然后考虑其他浏览器</h3>

<p>首先基于先进浏览器编写，然后再为那些非标准浏览器调整的话，代码将从一个开始就非常标准，调整的过程也将会非常容易。</p>

<h3 id="_2">若用浮动实现布局，请确保正确地清除了浮动</h3>

<h3 id="_3">为元素应用内边距或边框来避免外边距重叠</h3>

<p>现在可以通过触发BFC来防止外边距重叠</p>

<h3 id="_4">避免同时为元素制定明确的内边距/边框值与宽度/高度值</h3>

<p>兼容性问题</p>

<h3 id="ie6">避免IE6的“无样式瞬间现象”</h3>

<p>若在IE6中用<code>@import</code>引入外部样式就会出现闪烁的情况，可以通过link元素，或是在页面中添加script元素来避免这个问题</p>

<h3 id="minwidthminheight">不要依靠min-width或min-height属性</h3>

<p>兼容性问题</p>

<h3 id="_5">尝试减少百分比值</h3>

<p>适当减少百分比，让其相加稍小于100%</p>

<h3 id="_6">确保要实现的效果确实存在</h3>

<p>不同的效果在不同的浏览器中兼容性不一样，需要进行更多的测试</p>

<h3 id="lovehate">牢记“LoVe/HAte”（爱恨）连接规则</h3>

<p>在为连接元素指定伪类时，注意以下顺序：<code>link</code>、<code>visited</code>、<code>hover</code>和<code>active</code>，任何其他的声明顺序都可能会导致问题。若还要考虑<code>:focus</code>伪类，则规则修改为LVHFA</p>

<h3 id="troubled">牢记“TRouBLED”（麻烦的）边框简写顺序</h3>

<p><code>boder</code>、<code>margin</code>、<code>padding</code>的顺序都是按照时钟的顺序，<code>top</code>，<code>right</code>，<code>bottom</code>，<code>left</code>。</p>

<h3 id="_7">为非零值表明单位</h3>

<p>除了line-height以外，我们需要为非零的值标上单位</p>

<h3 id="_8">测试不同的字体大小</h3>

<p>高级浏览器会允许用户调整字体大小，所以需要调整字体大小来进行更多的测试</p>

<h3 id="htmlcss">HTML和CSS中统一大小写</h3>

<h3 id="_9">测试时使用嵌入样式，发布时再改为外部输入</h3>

<p>在测试时将样式嵌入到HTML代码中，可避免许多因浏览器缓存导致的不正常现象。对于较老的浏览器，这一点很重要。但是在发布前，记得将他们改为<code>@import</code>或<code>&lt;link&gt;</code>引入</p>

<h3 id="_10">用明显的边框辅助调试布局</h3>

<p>通过类似<code>div {border: 1px solid #f00}</code>之类的全局规则可以帮助检查很多细微的布局差错</p>

<h3 id="_11">指定图片路径是不要使用单引号</h3>

<p>设置背景图片时不需要使用引号。如果使用单引号，苹果机上的IE无法正确加载图像，所以要么使用双引号，要么不用引号</p>

<h3 id="anchor">若使用了锚点（anchor），那么在为超链接应用样式要格外小心</h3>

<h3 id="_12">不要未雨绸缪的链接至作为“占位符”的空样式表</h3>

<p>这样会加长页面的加载时间</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/09/csszengarden-5</guid>
            </item>
        
            <item>
                <title><![CDATA[ 去哪儿笔试题之我答 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/08/qunar-interview</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 08 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>题目来自： <a href="http://www.itmian4.com/forum.php?mod=forumdisplay&fid=44">IT面试论坛</a></p>

<p>之前想报去哪儿的实习，去参加参加笔试，结果因为填报的时间太晚了，没去成。今天全国统一笔试放出来了笔试题，说实话让我现场写基本上都写不出来…深刻感到了自己实力的不足，在这里借助浏览器内部的调试工具试着写了写，把握一下细节，也算是一种积累了</p>

<h2 id="">第一题</h2>

<h3 id="_2">题目</h3>

<p>输入一个有序数组和一个数，若在数组中返回索引，若不在返回应该插入的索引</p>

<h3 id="_3">想法</h3>

<p>没啥好想的，经典二分题</p>

<h3 id="_4">实现</h3>

<p>因为好久没摸java了，所以写了个JavaScript版本的：</p>

<pre class="javascript"><code class="javascript">var getPosInArray = function(arr, ele) {
    if (Object.prototype.toString.apply(arr) !== &#39;[object Array]&#39;) {
        throw Error(&quot;The first param must be an array!!!&quot;);
    }
    if (typeof ele !== &quot;number&quot;) {
        throw Error(&quot;The second param must be a number!!!&quot;);
    }
    var left = 0,
        right = arr.length - 1,
        middle;
    for (; left &lt;= right;) {
        middle = left + Math.floor((right - left) / 2);
        if (arr[middle] === ele) {
            return middle;
        } else if (arr[middle] &gt; ele) {
            right = middle - 1;
        } else {
            left = middle + 1;
        }
    }
    return left;
};</code></pre>

<p>java的也是类似的</p>

<h2 id="_5">第二题</h2>

<h3 id="_6">题目</h3>

<p>给定一个随机数组，数组可能包含数组（也就是说数组元素可能为数组）。要求用js实现一个函数，返回该数组中所有元素，重复的要求去掉。例如：数组[2,3,[4,6,[3,8]],12,10]，返回结果为：[2,3,4,6,8,12,10]</p>

<h3 id="_7">想法</h3>

<p>数组中的数组，很容易想到的一种方式就是新建一个结果数组，通过递归遍历将不同的值插入到结果数组中，JavaScript中查询结果数组中是否已有某值的时候可以用<code>arr.indexOf(ele) === -1</code>来确定，同时注意一下类型检测，使用<code>Object.prototype.toString.apply(rawArray) === &#39;[object Array]&#39;</code>来进行数组的检测，用<code>typeof</code>来检测基础类型</p>

<h3 id="_8">实现</h3>

<p>这道题是前端题，自然是JavaScript：</p>

<pre class="javascript"><code class="javascript">var getUniEle = function(rawArr) {
    if (Object.prototype.toString.apply(rawArr) !== &#39;[object Array]&#39;) {
        throw Error(&quot;The param must be an array!!!&quot;);
    }
    var result = [],
        process = function(arr) {
            var i,
                m;
            for (i = 0, m = arr.length; i &lt; m; i++) {
                if (typeof arr[i] === &#39;number&#39; &amp;&amp; result.indexOf(arr[i]) === -1) {
                    result.push(arr[i]);
                } else if (Object.prototype.toString.apply(arr[i]) === &#39;[object Array]&#39;) {
                    processCurArray(arr[i]);
                } else {
                    throw Error(&quot;Any element must be an array or a number!!!&quot;);
                }
            }
        };
    process(rawArr);
    return result;
};</code></pre>

<h2 id="_9">第三题</h2>

<h3 id="_10">题目</h3>

<p>这个题和腾讯2014校园招聘前端题目是一样的。 给定一个URL字符串，要求用js实现一个函数，返回该URL的域名、请求路径、参数和hash值、 例如：URL：<code>http://www.qunar.com/plane/queryPlane.html?startTime=xxxx&amp;endTime=xxxxx#tags</code> 返回结果为：</p>

<pre class="javascript"><code class="javascript">{
    host: &quot;www.qunar.com&quot;,
    path: &quot;plane/queryPlane.html&quot;,
    query: {
        &quot;startTime&quot;: &quot;xxxxx&quot;,
        &quot;endTime&quot;: &quot;xxxxx&quot;
    },
    hash: &quot;tags&quot;
}</code></pre>

<p>注明：xxxx为url编码后的字符串，设计函数是肯定要求把它解码过来！</p>

<h3 id="_11">想法</h3>

<p>解析url这个题目很常见，容易想到通过正则表达式提取，但是我就栽在这种常见的题目上了，正则怎么写都不对，跪了</p>

<p>首先要了解一个常规的url分为哪些内容，一个包含所有内容的url大致上长这样：<code>scheme://host:port/path?query#fragment</code>，其中：</p>

<ul>
<li>scheme: 通信协议，如http，https，ftp等</li>

<li>host：主机（域名或者是IP地址）</li>

<li>port：端口</li>

<li>path：请求的路径</li>

<li>query：请求所发送的数据</li>

<li>fragment：片段，用于指向网页中的片段</li>
</ul>

<p>需要知道其中哪些是可能被省略的，最简单的url只有主机，比如skinlayer.com，其他都是可选的。在正则匹配的时候需要使用<code>()?</code>来进行可选时的匹配</p>

<p>比如如下的url就比较完整：<code>http://www.qunar.com:8080/plane/queryPlane.html?startTime=xxxx&amp;endTime=xxxxx#tags</code></p>

<ul>
<li>
<p>将url拆分，首先匹配scheme，scheme前面都是字母，然后是<code>://</code>，所以可以写出这样的正则:<code>(?:(\w+)\:\/\/)?</code>，这里用了非捕获性匹配<code>(?:)</code>，匹配到上面的<code>http://</code>部分，但由于非捕获性分组的存在，仅仅捕获了<code>http</code></p>
</li>

<li>
<p>然后匹配主机部分，主机部分不可省略，同时其可能是字母，数字，小数点，下划线，所以可以写出这样的正则：<code>([\w\d]+(?:\.[\w\d]+)*)</code>，匹配并捕获到上面的<code>www.qunar.com</code>部分</p>
</li>

<li>
<p>然后匹配端口，同样是可选，格式为<code>:dd</code>，所以可以写出正则：<code>(?:\:[\d]+)?</code>，匹配到<code>:8080</code>部分，捕获<code>8080</code></p>
</li>

<li>
<p>然后匹配路径，从之前匹配到之后的?或者#（如果没有query部分，就可能直接碰到#），都是path部分，因此通过排除这两个字符的方式来写正则<code>(?:\/([^?#]+))?</code>，匹配到<code>/plane/queryPlane.html</code>，捕获<code>plane/queryPlane.html</code></p>
</li>

<li>
<p>接着就是query这个大头了，我们先把里面这一部分抠出来，留在以后再进行详细的处理转换为对象，这里可以看到到#之前都是这个部分<code>(?:\?([^#]*))?</code>，匹配到<code>?startTime=xxxx&amp;endTime=xxxxx</code>，捕获<code>startTime=xxxx&amp;endTime=xxxxx</code></p>
</li>

<li>
<p>最后捕获一些fragment就行了，很好弄，#后面所有的字符都是这一部分<code>(?:#(.*))?</code></p>
</li>
</ul>

<p>最后再加上起始和结束就可以生成完整的正则表达式了：</p>

<pre class="javascript"><code class="javascript">var reg = /^(?:(\w+)\:\/\/)?([\w\d]+(?:\.[\w]+)*)(?:\:(\d+))?(?:\/([^?#]+))?(?:\?([^#]*))?(?:#(.*))?$/;</code></pre>

<p>相当长，说实话，如果让我笔试写肯定跪逼了</p>

<p>然后运用在url字符串上：</p>

<pre class="javascript"><code class="javascript">var regResult = url.match(/^(?:(\w+)\:\/\/)?([\w\d]+(?:\.[\w]+)*)(?:\:(\d+))?(?:\/([^?#]+))?(?:\?([^#]*))?(?:#(.*))?$/);
//[&quot;http://www.qunar.com:8080/plane/queryPlane.html?startTime=xxxx&amp;endTime=xxxxx#tags&quot;, &quot;http&quot;, &quot;www.qunar.com&quot;, &quot;8080&quot;, &quot;plane/queryPlane.html&quot;, &quot;startTime=xxxx&amp;endTime=xxxxx&quot;, &quot;tags&quot;]</code></pre>

<p>生成的数组各个元素基本上就是我们要的了，除了query部分，对query部分做一下单独的处理，首先利用正则表达式将所有的键值对字符串取出来放在一个数组中：</p>

<pre class="javascript"><code class="javascript">var rawParams = result.query.match(/([^=&amp;]+)=([^&amp;=]+)/g);</code></pre>

<p>这个正则由于可能匹配多次，所以用到了全局匹配</p>

<p>然后将所有的键值对字符串进行分割，分割成键和值插入到结果中就行了，这里分割使用了<code>String.split()</code>方法：</p>

<pre class="javascript"><code class="javascript">result.query = {};
if (rawParams) {
    for (var i = rawParams.length; i--;) {
        tmp = rawParams[i].split(&quot;=&quot;);
        result.query[tmp[0]] = unescape(tmp[1]);
    }
}</code></pre>

<p>需要注意题目上有一句话：<code>xxxx为url编码后的字符串，设计函数是肯定要求把它解码过来！</code>，所以这里需要使用unescape来进行解码</p>

<p>最后完整的代码如下：</p>

<pre class="javascript"><code class="javascript">var parseUrl = function(url) {
    if (typeof url !== &quot;string&quot;) {
        throw Error(&quot;The param is not a string!!!&quot;);
    }
    if (url === &quot;&quot;){
        throw Error(&quot;The param is an empty string!!!&quot;);
    }
    var regResult = url.match(/^(?:(\w+)\:\/\/)?([\w\d]+(?:\.[\w]+)*)(?:\:(\d+))?(?:\/([^?#]+))?(?:\?([^#]*))?(?:#(.*))?$/);
    var result = {
        url: regResult[0],
        scheme: regResult[1],
        host: regResult[2],
        port: regResult[3],
        path: regResult[4],
        query: regResult[5],
        fragment: regResult[6]
    };

    if (typeof result.query !== &quot;undefined&quot;) {
        var rawParams = result.query.match(/([^=&amp;]+)=([^&amp;=]+)/g);
        var tmp;
        result.query = {};
        if (rawParams) {
            for (var i = rawParams.length; i--;) {
                tmp = rawParams[i].split(&quot;=&quot;);
                result.query[tmp[0]] = unescape(tmp[1]);
            }
        }
    }
    return result;
};</code></pre>

<p>由于加了非字符串以及空字符串的检测，基本上能解析所有的情况了</p>

<h2 id="_12">总结</h2>

<p>这三题都是看似简单（解题思路很容易想到），但实际上实现起来很在乎细节。正则这个东西说实话在纸上写很难保证正确，基本上都是边调试边写，看来要笔试好还有很长的路要走</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/08/qunar-interview</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——文字排布 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/08/csszengarden-4</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 08 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">字体排印学基础知识</h2>

<h3 id="_2">字体格式</h3>

<p>字体格式指的是字样表现出的粗细、宽度和姿态等特征</p>

<h3 id="_3">字体粗细</h3>

<p>字体粗细指文字笔画的宽度</p>

<p>CSS中对应属性为<code>font-wight</code>。有些字体并没有粗细适中的字样，因而他们不能提供和CSS中等同的粗细划分。一般只依赖两种设置： <code>normal</code>和<code>bold</code></p>

<ul>
<li><code>normal</code>： 常规字体显示，和weight为400等价</li>

<li><code>bold</code>： 一般对应于700的weight值，少数字体为600</li>

<li>数字：范围100-900</li>

<li><code>bolder</code>：比继承的值更粗，如果继承值已经达到最高值900，则不变</li>

<li><code>lighter</code>：比继承值更细，如果继承值为100，那么计算所得的值还是100</li>

<li><code>inherit</code>：粗细与父元素一致</li>
</ul>

<h3 id="_4">字体宽度</h3>

<p>字体宽度指字符的宽度。紧缩字体会显得更为狭窄，而扩张字体则显得宽大</p>

<p>CSS中对应属性是<code>font-stretch</code>,不过这个属性浏览器支持很不好。目前只有ff9+和ie9+支持</p>

<h3 id="_5">字体姿态</h3>

<p>字体姿态就是字体的倾斜程度</p>

<p>CSS中对应属性为<code>font-style</code>:</p>

<ul>
<li><code>italic</code>：一种在常规字体基础上做过特殊处理的变体，一般带有手写风格</li>

<li><code>oblique</code>：直接由浏览器作倾斜处理后的版本</li>
</ul>

<h3 id="_6">字体对比度</h3>

<p>字体对比度指字形中粗的部分与细的部分之间的差异程度。不同字体的对比度相差很大</p>

<p>serif字体即衬线字体，sans-serif字体则为非衬线字体，衬线字体在笔画本来必要的形状之外，在笔画起始端、末端和关键节点处会有多出来的形状用于装饰。而非衬线字体则没有这些装饰，表现较为圆滑。通常做法中，圆滑、缺乏粗细对比的sans serif字体被用作标题用字，而Serif字体常用作正文字体。不过这种传统在当今的Web时代受到很大争议</p>

<h3 id="_7">字体色深</h3>

<p>字体色深就是指文字的深浅程度。字体色深不完全依赖于字体本身，还有很多其他的影响因素（字距调整、字间距、行间距、字体色相等等）</p>
<hr />
<h2 id="_8">对比</h2>

<h3 id="_9">色相和对比度的选择</h3>

<p>色相和对比度选择关系到设计的一致性，直接影响作品的可读性</p>

<p>传统的文字设计理论认为提高前景和背景的色相对比，会大大提高文本的可读性</p>

<p>低对比度的字体会造成视觉不便人士阅读困难</p>

<h3 id="_10">字号对比和字体颜色</h3>

<p>使用不同大小的字体可以增加文字区块间的对比</p>

<h3 id="_11">字号对比和粗细</h3>

<p>可以使用字号和粗细的变化来增加对比度</p>
<hr />
<h2 id="_12">字体选择</h2>

<h3 id="_13">限制</h3>

<p>所有站点文字都依赖与用户本地安装的字体。但是我们几乎无法在Windows、OS X和Unix/Linux中找到共有的字体。</p>

<h3 id="_14">通用字体族</h3>

<p>serif： 有明显的装饰钩，所以在字母笔画的结尾处大都能看到细小的衬钩</p>

<p>sans serif： 没有装饰钩</p>

<p>monospace：买个字母拥有相同的宽度，这类字体在现实代码时特别有用</p>

<p>cursive： 模仿手写风格，通常用于标题</p>

<p>fantasy： 装饰用字体，多数用于标题，但这个字族拥有太多的字体，无法统一，所以很少有人会在正式的站点设计中使用它们</p>

<h3 id="css">CSS中的字体</h3>

<p>使用<code>font-family</code>来去确定使用的字体族</p>

<p>需要明确一个x-height的概念，x-height定义为去除高出部分和低出部分后的高度，而通常就是小写的x字母的高度。拥有相同x-height的字体往往具有较好的相似性。而x-height也影响到了字体的显示。在CSS中，<code>font-size</code>对所有字体的作用都是相同的，因而如果使用了一中x-height比较大的字体，用户看起来这个字体就会显得比其他字体略小一些</p>
<hr />
<h2 id="_15">字体大小的变化</h2>

<h3 id="_16">字体大小</h3>

<p>由于网页中大号字体的显示效果较差，设计师往往倾向于使用小号的字。而小号的字也意味着同样的空间可以容纳更多的内容。但这让很多读者无法适应</p>

<h3 id="_17">浏览器控制</h3>

<p>很多浏览器都支持改变字体的大小</p>

<h3 id="_18">绝对单位和相对单位</h3>

<p>CSS中，绝对单位指可以预先确定单位长度的度量单位。这里包括<code>cm</code>、<code>in</code>、<code>pt</code>等</p>

<p>而相对单位包括<code>%</code>、<code>em</code>、<code>larger</code>和<code>smaller</code>等。这是一种可变的尺寸。如果使用相对单位意味着会有一个默认的基值。</p>

<p>CSS中有一些描述字体大小的关键字，比如<code>xx-small</code>、<code>medium</code>、<code>x-large</code>等，他们是绝对单位，但是实际显示大小却不是那么精确</p>

<h3 id="px">px像素</h3>

<p>根据CSS定义，px实际上是一个相对单位。因为就算相同分辨率的设备屏幕大小也不相同。有的设备屏幕较小，但分辨率高，导致1px很小，几乎无法分辨。在IE中，px被当做绝对单位来处理的。</p>

<p>浏览器的默认字体大小是16px</p>

<h2 id="_19">合理设置字体大小</h2>

<p>在使用百分比的方式能够避免很多舍入的误差，所以对body元素应用了百分比单位后，我们就可以为其余元素使用em值。同时需要注意的是，不要将文字大小设置在1em以下</p>
<hr />
<h2 id="_20">文字排布</h2>

<h3 id="_21">视觉行为</h3>

<p>在设计网页时，需要遵循人们的阅读方式进行页面布局。排版的主流理论认为人类视觉会自然地偏向页面的左上角，也就是所谓的视觉中心区。之后实现可以流畅的向右移动，或是转向新的一行，这样和逐渐趋近于页面底端。在这个过程中，视线会将页面的地段作为最终的停靠点</p>

<h3 id="_22">引导视线</h3>

<p>视线被吸引的现象被形象的比喻为“引力”。将重要的站点标志放在视觉中心区，而把文字等其他元素至于页面下部形成停靠点的设计规则非常合理，而视线从右方转向左侧时形成的这点通常也是较易被浏览者关注的地方</p>
<hr />
<h2 id="_23">避免产生理解上的问题</h2>

<h3 id="_24">标题文字</h3>

<p>标题文字用来指明段落的主要内容，关于处理标题，有如下建议：</p>

<ul>
<li>标题中使用的颜色必须是整个设计中较为强势的颜色</li>

<li>标题的色彩必须鲜明。在标题中亮色所带来的影响不如暗色。越是接近黑色的标题，越是能对浏览者产生强的冲击力</li>

<li>越是重要的标题，越是需要带有强烈冲击力的色彩</li>

<li>略为紧缩的字体更能凸现标题。设计师建议使用正常字体70%-90%宽的标题文字</li>

<li>字体对比可以帮助增强标题效果</li>

<li>标题长度应该有所限制</li>

<li>避免在标题中使用句号</li>
</ul>

<h3 id="_25">正文字体</h3>

<p>正文字体是页面文字的主体部分，关于正文布局，有如下建议：</p>

<ul>
<li>保持一行在60个字符以内</li>

<li>避免每行字数过少</li>

<li>较短的段落在快捷的网络时代更适合迅速传达重要信息</li>

<li>如果确实需要发布长篇文字，应当尽力让段落保持小巧。并且将长段落分割为节并加以标题，这样才能更好地引导读者</li>

<li>不要让段落之间的距离过大</li>

<li>避免在正文中使用鲜艳的色彩。唯一的色彩变化应该就在正文的链接上</li>
</ul>

<h3 id="_26">重要文字</h3>

<p>重要文字指的是侧栏、引用和说明部分的文字，有如下建议：</p>

<ul>
<li>重要文字的目的是引起读者的注意，可以应用鲜艳的色彩</li>

<li>重要文字应当使用短行，且只能有很少的行数</li>

<li>重要文字不应当阻断正文，而应当增强正文的效果</li>

<li>文字能为插图提供上下文，起到帮助读者阅读的作用</li>
</ul>
<hr />
<h2 id="_27">文本样式</h2>

<p>有是有需要对单个字符进行调整，CSS有很多属性能够达到类似的效果</p>

<h3 id="fontvarient">font-varient</h3>

<p>这个属性唯一的作用就是将文字用略小的大写字母表示</p>

<h3 id="texttransform">text-transform</h3>

<p>这个属性提供了更精确的字符大小写控制，有如下值：</p>

<ul>
<li><code>capitalize</code>：每个单词首字母大写</li>

<li><code>uppercase</code>：所有字母大写</li>

<li><code>lowercase</code>：所有字母小写</li>

<li><code>none</code>：正常</li>
</ul>

<h3 id="textdecoration">text-decoration</h3>

<p>文本装饰，常用的有如下值：</p>

<ul>
<li><code>none</code>： 没有装饰，在没有理由使用其他选项时，none是最好的选择</li>

<li><code>underline</code>： 下划线，仅仅在链接中使用下划线</li>

<li><code>overline</code>：上划线，仅仅在数学中表示平均值时候用到，其他时候很少会用</li>

<li><code>line-through</code>： 贯穿线，仅用于表示已经不再相关、非事实或无效的文字，这些文字可能很快会背其他文字替代，理想的用法是用于那些需要被改写的部分</li>

<li><code>blink</code>： 闪烁，已被废弃</li>
</ul>
<hr />
<h2 id="_28">间距样式</h2>

<p>CSS提供了很多控制间距的属性</p>

<h3 id="lineheight">line-height</h3>

<p>用于控制行间距，该属性可被设置为绝对数值、相对大小、长度或百分比，还有inherit</p>

<p><code>line-height</code>不需要单位，1.2和1.2em和120%是同义的</p>

<h3 id="letterspacing">letter-spacing</h3>

<p>可以控制字符间距，可将其设为normal或一个长度值。不应当为大段的文字设置字符间距。最好只在标题和小段文字中使用<code>letter-spacing</code></p>

<h3 id="wordspacing">word-spacing</h3>

<p>用于调整单词的间距，<code>text-align</code>和<code>white-space</code>都会影响到浏览器对<code>word-spacing</code>的处理</p>

<h3 id="textalign">text-align</h3>

<p>用于对齐文字，可选值为<code>left</code>、<code>right</code>、<code>center</code>、<code>justify</code>。建议使用传统的right-align和left-align方式对齐正文。居中对齐仅仅用于标题、引用等小块文字，不要将其用于大段文字中</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/08/csszengarden-4</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——图像 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/08/csszengarden-3</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 08 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">优化的重要性</h2>

<h3 id="_2">客户端</h3>

<p>网速的限制导致较大的文件需要更长的等待时间，降低用户体验</p>

<h3 id="_3">服务端</h3>

<p>高流量的站点通常都有很多用户同时访问，每个用户耗费的带宽越多，总的带宽需求就越大</p>
<hr />
<h2 id="_4">图像格式基础</h2>

<p>常用的图像格式有三种，GIF、JPEG和PNG。这三种格式都支持压缩。选择合适的图像文件格式也就是在透明支持、色深和压缩比率三者之间取舍</p>

<h3 id="_5">图像格式</h3>

<p>每个图片文件格式都有自己的色彩模型、表示形式、压缩方案以及透明度效果支持等特性。需要了解不同图像的优劣之处，根据实际需求做出合理的选择。</p>

<h3 id="_6">无损压缩和有损压缩</h3>

<p>无损压缩将保留原图像的所有细节，有损压缩会对细节有所取舍，以换取更小的文件。二者都有自己适用的地方</p>

<h3 id="_7">色深</h3>

<p>色深是指某种给图像格式包含的颜色的多少。用位计量，更高的色申表示能包含更多的颜色种类</p>
<hr />
<h2 id="gif">GIF</h2>

<h3 id="_8">适用范围</h3>

<p>GIF使用一中叫做LZW的无损压缩格式，非常适合带有大块相同颜色区域的图像。单色插图、文本、色块等文件非常适合存为此格式。</p>

<h3 id="_9">色深和压缩</h3>

<p>GIF最多只能支持256种颜色，如果超出范围，颜色信息将会丢失。通过颜色索引来实现无损压缩，若颜色超过256种，会变成有损压缩</p>

<h3 id="_10">透明度</h3>

<p>GIF支持1位的透明度，即某个像素要么完全透明，要么完全不透明，没有任何中间值</p>

<h3 id="_11">其他</h3>

<p>GIF支持基于帧的简单动画以及隔行加载技术，但这两者会增加文件大小</p>
<hr />
<h2 id="jpeg">JPEG</h2>

<h3 id="_12">适用范围</h3>

<p>适合色彩、细节丰富的图像，比如照片</p>

<h3 id="_13">色深和压缩</h3>

<p>JPEG有24位色深，支持有损压缩且可以设置压缩等级。压缩比很大的JPEG图像将高度失真，并引发一种叫非自然痕迹的小块像素缺陷问题</p>

<h3 id="_14">透明度</h3>

<p>不支持任何形式的透明度</p>

<h3 id="_15">其他</h3>

<p>最新的“渐进JPEG”版本能够和GIF一样实现隔行加载，且已被大多数浏览器所支持</p>
<hr />
<h2 id="png">PNG</h2>

<h3 id="_16">适用范围</h3>

<p>由于其两种色深模式，理论上可以用于任何图像。但实际上最好还是用GIF和JPEG，前者用于带有大块相同颜色区域的图像，后者用于照片等色彩、细节丰富的图像。但PNG本身的256级透明度使得在无法预知图像在Web页面中所处区域的背景颜色时，PNG将会非常实用</p>

<h3 id="_17">色深和压缩</h3>

<p>提供了两种色深模式，24位和8位。24位色深可以保证完全无损的压缩，8位色深的PNG使用类似GIF的颜色索引，同样设置项，很多时候PNG压缩的文件要比GIF更小</p>

<h3 id="_18">透明度</h3>

<p>支持256级透明度</p>

<h3 id="_19">其他</h3>

<p>老版Windows上的IE浏览器（IE6）无法正确呈现PNG的透明度设置</p>
<hr />
<h2 id="_20">优化技巧</h2>

<p>最好的方式是从较低品质（即较高压缩比）的图像开始，逐步提高品质，直到对图像质量满意为止</p>

<h3 id="gif_2">GIF优化</h3>

<p>从最低的颜色级别开始（8种），逐步提高颜色数目，直至可以接受，如果256种颜色还是不能满意，那么就需要考虑用JPEG代替GIF了</p>

<p>还有一些设定能偶影响到GIF格式文件的大小，例如抖动技术（在一块相同颜色区域添加另一种像素点， 这个技术可以用于模拟出一些本部在文件颜色索引中的颜色）</p>

<h3 id="jpeg_2">JPEG</h3>

<p>优化JPEG相对简单，将原始图像保存为JPEG时，可以从较低的图像品质等级开始，逐步增加，直至可以接受</p>

<h3 id="png_2">PNG</h3>

<p>优化8位PNG图像的步骤与优化GIF完全一致。24位PNG图像的优化无需关注，因为其压缩防止固化在文件格式中，无法更改</p>
<hr />
<h2 id="_21">图像替换技术</h2>

<p>很多时候需要隐去原本文字，取而代之是一副图像。</p>

<h3 id="_22">图像替换的目的</h3>

<p>通过CSS将元素中的文本隐藏，然后运用背景显示图像</p>

<h3 id="_23">图像替换的责任</h3>

<p>没有任何提示或帮助，计算机无法认出或读取图像中包含的文字。如果使用<code>display: none</code>，Google能够读取到隐藏的文本，但有些屏幕阅读器不能。这导致视觉不便用户不能够获取图像传递的信息。</p>

<h3 id="leahylangridge">Leahy和Langridge的方案</h3>

<p>如下HTML结构：</p>

<pre class="xml"><code class="xml">&lt;h1 id=&quot;header&quot;&gt;这是一个标题&lt;/h1&gt;</code></pre>

<p>通过添加CSS且不改变HTML文档结构的方式来替换，CSS如下：</p>

<pre class="css21"><code class="css21">#header {
    padding: 25px 0 0 0;
    overflow: hidden;
    background-image: url(back.gif) no-repeat;
    height: 0px !important;
    height /**/:25px;
}</code></pre>

<p>这种方式的原理是，由于background会在padding block中进行显示，所以先将height设为0以隐藏content block，padding设为背景图片的高度，这样background中定义的图片就能在padding中正常显示</p>

<p>这种方式并没有解决浏览器禁用图像后空白页面的可访问性问题，同时需要hack</p>

<h3 id="rundle">Rundle的方案</h3>

<p>使用负数的text-indent属性方法，将文本推到屏幕的左边缘外，CSS如下：</p>

<pre class="css21"><code class="css21">#header {
    text-indent: -5000px;
    background: url(back.gif) no-repeat;
    height: 25px;
}</code></pre>

<p>这种方式并没有解决浏览器禁用图像后空白页面的可访问性问题</p>

<h3 id="levin">Levin的方案</h3>

<p>通过将文本放在span外，并设置span覆盖住文本，HTML如下：</p>

<pre class="xml"><code class="xml">&lt;h1 id=&quot;header&quot;&gt;这是一个标题&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;</code></pre>

<p>CSS代码如下：</p>

<pre class="css21"><code class="css21">#header {
    position: relative;
    margin: 0px;
    padding: 0px;
    height: 25px;
    width: 300px;
    overflow: hidden;
}

#header span {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
    background-image: url(back.gif) no-repeat;
}</code></pre>

<p>这样就算禁用了图像，空白部分依旧可访问。但这种情况下无法使用透明图像，同时HTML和CSS代码都很冗长</p>
<hr />
<h2 id="_24">图像使用技巧</h2>

<h3 id="_25">图像的大小和尺寸</h3>

<p>在保证足够质量的前提下，图像文件的大小应该尽可能地降低</p>

<h3 id="_26">减少图像数量</h3>

<p>图像数量的增加，会导致浏览器的请求增加，所以在使用图像时，尽量做到以下几点：</p>

<ul>
<li>尽可能用文本样式替代图像</li>

<li>只把刘图像中为实现预期效果所必须的部分</li>

<li>使用细条图像填充背景</li>

<li>尽可能地重复使用图像</li>

<li>合理的选用图像和颜色</li>

<li>若能不适用图像，那么就不要使用</li>

<li>将图像合并，使用sprite技术</li>
</ul>
<hr />
<h2 id="_27">图像细节</h2>

<h3 id="_28">理解细节</h3>

<p>设计师的主要职责之一就是仔细观察生活中的细节，以便在作品中充分的重现环境。这就意味着必须全面理解细节，而不仅仅停留在能够看到的水平上</p>

<h3 id="_29">表现真实感</h3>

<p>创建真实感不一定必须用照片</p>

<ul>
<li>要特别注意图形边缘的效果。事实上，边缘来自于线条、光影、正负空间之间的交汇融合，而正是这种融合才让我们体会到线条的感觉</li>

<li>注意形状，大多数物体都是由若干种形状组合而来</li>

<li>图像的材质能够为物体带来真实感</li>

<li>深度可以表现出额外维度的感觉，即使在二维环境中也是如此</li>

<li>重力模拟同样重要</li>
</ul>

<p>在二维设计描述三维物体时，参考如下建议：</p>

<ul>
<li>封闭区域是由颜色和材质组成</li>

<li>物体的体积是由长宽高组成</li>

<li>体积感是这些视觉元素组合的结果，由此营造出了真实感</li>
</ul>

<h3 id="_30">处理层次</h3>

<p>层次表示环境的分层状态</p>

<ul>
<li>层次之间的线条、空间和大小都要有区别</li>

<li>层与层之间仍然是一个整体，以某种方式保持着联系</li>

<li>层与层之间的过度要自然</li>

<li>作品中总是要包含焦点或终点</li>

<li>作品中绝对不能缺少重力感</li>
</ul>

<h3 id="_31">其他</h3>

<p>在处理环境中非真实存在的元素时，应根据环境对其进行模拟，保持风格高度统一</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/08/csszengarden-3</guid>
            </item>
        
            <item>
                <title><![CDATA[ 对比display布局（clearfix） ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/07/display</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 07 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>最近在看面试题的时候看到很多次出现display的inline、block、inline-block的区别。在这里做一做实验，可以从margin、padding、border、width、height来区别</p>

<h2 id="display_block">display: block</h2>

<h3 id="">典型元素</h3>

<p>如<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>、<code>&lt;form&gt;</code>、<code>&lt;ul&gt;</code>等等</p>

<h3 id="_2">缺省宽度</h3>

<p>缺省宽度为其容器的100%</p>

<h3 id="_3">换行</h3>

<p>前后均会换行</p>

<h3 id="_4">设定盒子模型属性时</h3>

<p>设定<code>margin</code>、<code>padding</code>、<code>border</code>、<code>width</code>、<code>height</code>后都会根据设定进行相应显示</p>

<pre class="css21"><code class="css21">.block {
    display: block;
    margin: 1em;
    padding: 1em;
    border: 1em solid transparent;
    width: 10em;
    height: 10em;
}</code></pre>

<p><img src="/images/display/1.png" alt="display: block时的盒子模型" /></p>

<p><img src="/images/display/2.png" alt="display: block时的z真正显示的盒子模型" /></p>

<h2 id="display_inline">display: inline</h2>

<h3 id="_5">典型元素</h3>

<p>如<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;label&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>等等</p>

<h3 id="_6">缺省宽度</h3>

<p>宽度为内容宽度，且宽度不可变</p>

<h3 id="_7">换行</h3>

<p>前后均不会换行</p>

<h3 id="_8">设定盒子模型属性时</h3>

<p>设定<code>width</code>、<code>height</code>均不会起任何作用</p>

<p>设定<code>margin</code>时，仅有左右margin会起作用，上下margin无效</p>

<p>设定<code>padding</code>与<code>border</code>时，上下左右均有效，但不会影响布局（仅仅会拉大background，border显示）</p>

<pre class="css21"><code class="css21">.inline {
    display: inline;
    width: 200em;
    height: 200em;
    margin: 1em;
    padding: 1em;
    border: 1em solid #FF8686;
}</code></pre>

<p><img src="/images/display/3.png" alt="display: inline时真正显示的盒子模型" /></p>

<p><img src="/images/display/4.png" alt="display: inline时的盒子模型" /></p>

<h2 id="display_inlineblock">display: inline-block</h2>

<h3 id="_9">典型元素</h3>

<p>无</p>

<h3 id="_10">缺省宽度</h3>

<p>缺省宽度为内容宽度，可以设置宽度</p>

<h3 id="_11">换行</h3>

<p>前后均不会换行</p>

<h3 id="_12">设定盒子模型属性时</h3>

<p>设定<code>width</code>、<code>height</code>、<code>margin</code>、<code>padding</code>、<code>border</code>时均会撑大元素，并且与<code>display:block</code>时一样显示，但前后不会换行</p>

<pre class="css21"><code class="css21">.inline-block {
    display: inline-block;
    width: 15em;
    height: 15em;
    margin: 1em;
    padding: 1em;
    border: 1em solid #FF8686;
}</code></pre>

<p><img src="/images/display/5.png" alt="display: inline-block时的实际显示的盒子模型" /></p>

<p><img src="/images/display/6.png" alt="display: inline-block时的盒子模型" /></p>

<h3 id="_13">其他</h3>

<p>可以通过<code>verticle-align: middle</code>等属性来对文字与设定了<code>display:inline-block</code>来进行布局</p>

<pre class="css21"><code class="css21">.inline-block {
    display: inline-block;
    width: 15em;
    height: 15em;
    margin: 1em;
    padding: 1em;
    border: 1em solid #FF8686;
    vertical-align: middle;
}</code></pre>

<p><img src="/images/display/7.png" alt="Alt text" /></p>

<h3 id="_14">浏览器兼容性</h3>

<p>兼容ie8+、ff26+、chrome31+、safari7+、opera19+，详见<a href="http://caniuse.com/#search=inline-block">caniuse.com</a></p>

<p>需要让老版IE兼容，可以通过如下方式：</p>

<pre class="css21"><code class="css21">div {
    display: inline-block;/*触发块元素*/
    *display: inline;/*让块元素呈递为内联对象*/
    *zoom: 1;/*为内联对象触发块元素的layout*/
}</code></pre>

<h2 id="_15">总结</h2>

<p>display的这三个常用属性还是有很多陷阱的，面试也经常会问，在这里做一个对比。其实display还有很多新增的table布局的属性，比如<code>display: table</code>,<code>display: table-cell</code>等等，也可以深入的去试验一下具体的效果。这里把三种对比放在jsfiddle上</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/KC3Xr/embedded/result,css,html' width='100%'>&nbsp;</iframe> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/07/display</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——正文布局 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/07/csszengarden-2</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 07 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">布局</h2>

<h3 id="_2">绝对定位</h3>

<p>元素使用绝对定位时，其将脱离原始文档流，不会对其旁边的元素带来任何影响</p>

<h3 id="_3">浮动</h3>

<p>浮动布局的优势在于：浮动元素仍保留在文档流中其环绕的元素也都清楚它的位置</p>
<hr />
<h2 id="_4">布局方法</h2>

<h3 id="_5">固定布局和流式布局</h3>

<p>固定布局：页面有着固定的宽度，居左、居右对齐，或者居中。页面内容的宽度不会随着浏览器窗口的宽度变化而变化</p>

<p>流式布局：页面宽度用百分比指定，而不是某个固定的宽度。浏览器窗口大小变化时，页面宽度随之变化</p>

<p>流式布局设计避免了另一半页面的空白，显得更为平衡。但使用流式布局，无法精确控制行长、页面布局以及元素位置</p>
<hr />
<h2 id="_6">水平居中方案</h2>

<h3 id="margin">自动margin水平居中</h3>

<p>使用<code>margin: 0 auto</code>，使用时注意指定宽度，兼容ie6+</p>

<h3 id="textalign">使用text-align实现居中</h3>

<p>在body上设置<code>text-align: center</code>，这是一条hack，整整完全遵守标准的浏览器不会改变容器的位置，所以这条行不通</p>

<h3 id="margin_2">负margin</h3>

<p>先将元素通过如下代码右移屏幕宽度的50%：</p>

<pre class="css21"><code class="css21">position: absolute;
left: 50%;</code></pre>

<p>然后使用负margin左移元素宽度的50%:</p>

<pre class="css21"><code class="css21">position: absolute;
left: 50%;
width: 1000px;
margin-left: -500px;</code></pre>

<p>使用这种方式，需要将内边距、边框计算在容器宽度中</p>
<hr />
<h2 id="_7">布局的灵感和法则</h2>

<h3 id="_8">用户界面设计</h3>

<p>用户界面设计更加关注用户，其最主要的研究目的就是让开发者和工程师能够更好的满足用户的需求</p>

<ul>
<li>了解浏览额面的用户</li>

<li>在页面和站点中给用户足够的导向</li>

<li>使用被人们熟知的象征符号</li>

<li>保证与功能现骨干的特性在页面中足够显眼</li>

<li>保证设计元素的一致性</li>

<li>了解页面中的关键元素</li>

<li>清楚的表达页面内容：通常来讲人类的注意力持续最多9秒钟，这段时间还是不能了解页面的主要内容，用户就会彻底放弃</li>
</ul>

<h3 id="_9">可用性</h3>

<p>可用性研究更加关注最终的用户体验，即用户如何与已经开发完成了的程序进行交互</p>

<p>可用性原则：</p>

<ul>
<li>重要信息应放在显眼的位置</li>

<li>永远在title中给出页面的简单介绍</li>

<li>尽可能地保证页面中的导航链接有着一致的表现，同样也要确保有回到首页的链接</li>

<li>在大中型站点来说，最好提供搜索功能。搜索功能的位置要让用户直觉就能够发现</li>

<li>用缩进和偏移将栏中内容分开</li>
</ul>
<hr />
<h2 id="_10">灵感</h2>

<p>建议新手去一些地点进行观察。如壮美、多彩、富有活力的大自然常常是灵感的发源地。另外一个灵感的发源地就是人的性格和外贸。人的外形总会在艺术中占有相当的地位。</p>

<h3 id="_11">从印刷作品中找到灵感</h3>

<h3 id="_12">打破纵向布局的常规</h3>

<p>考虑横向布局，但注意浏览器兼容性和实现</p>
<hr />
<h2 id="_13">元素的位置以及带来的含义</h2>

<p>如果将一张纸分为四个象限，西方文字布局的顺序是从左到右，从上至下。浏览者一般都会无意中按照这个顺序来区分四个象限内容的重要性</p>

<p>所以logo一般放在左上位置</p>

<p>在页面中，无需滚动即可看到的区域都是最重要的部分，将某个元素至于页面的右上角，意味着该元素的重要性略逊于左上角的元素，但仍然远高于页面其他元素</p>

<p>底部两个象限并不是那么重要</p>

<p>页面底部的常见用途就是放置一些非必要的内容，比如没有足够层次性的连接，指向本页或网站其他页面的导航等等。这些内容若是用户没有看到，也没有什么大不了的</p>
<hr />
<h2 id="_14">网格布局</h2>

<p>网格不过是一系列相交线分割出的大小一致且极具逻辑性的方框。若在布局中严格依照网格，元素的比例和间距将变得更为协调统一，虽然这可能让作品过于规整、缺乏创造性</p>

<p>根据需要，可以使用绝对定位（<code>position: absolute</code>）或是相对定位（<code>position: relative</code>）来打破网格的限制</p>
<hr />
<h2 id="_15">内容溢出</h2>

<p>大多数浏览器都支持缩放页面的文本字号，很多视力不佳的人很依赖这个功能。字号会进行放大（150%甚至更大），字号放大后可能会导致文本重叠问题，尤其是类似导航链接之类的小块文字区域容易受影响</p>

<p>最常见的两种内容溢出情况：</p>

<ol>
<li>绝对定位元素中内容过多</li>

<li>浮动元素尺寸超过其可容纳区域</li>
</ol>

<h3 id="_16">浮动导致的内容溢出</h3>

<p>CSS引入浮动的本意是让文本能够环绕在其中内嵌的其他元素周围，而不是为了页面布局</p>

<p>浮动后可以使用清除浮动的的方式来让某一元素不再跟随在另一元素后面。清除浮动的方式有很多，这里就不一一列举了</p>

<h3 id="_17">绝对定位导致的内容已出</h3>

<p>绝对定位中遇到的最多的问题就是垂直方向溢出。绝对定位元素不像浮动元素那样能够被“清除”</p>

<p>避免方法：</p>

<ul>
<li>使用浮动替代绝对布局</li>

<li>在设计中尝试避免</li>

<li>通过<code>overflow: auto</code>或者<code>overflow: scroll</code>来让内容超出时出现滚动条</li>

<li>使用JavaScript脚本辅助</li>

<li>使用em作为长度单位而不是px（仅适用于增大字号导致的内容溢出）</li>
</ul> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/07/csszengarden-2</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——设计 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/06/csszengarden-1</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 06 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">简洁的设计</h2>

<h3 id="_2">排版样式</h3>

<p>正文部分的文字按照比例来讲要远大于菜单部分的文字。合理地使用字号来暗示浏览者哪些区域重要，哪些不重要</p>

<h3 id="_3">图标</h3>

<p>图标是一类简化的符号，用来表示某件物品或者某类概念，或者用来以抽象的图形化概念替代一段较长的文字描述</p>

<p>图标仅仅起到标号的作用，而不至于喧宾夺主地吸引或让浏览者转移视线</p>

<h3 id="_4">分界线</h3>

<p>适当的使用线条能够在页面中定义区域的边界，给页面增加额外的维度，但不要过度使用</p>

<h3 id="_5">外边距</h3>

<p>适当的左右外边距会让作品的正文部分不至于显得太局促。</p>

<p>文本需要一些呼吸的空间</p>
<hr />
<h2 id="_6">统一和象征手法</h2>

<h3 id="_7">一致性</h3>

<p>作品中用到的元素可能各不相同，但作品整体达到统一的已经却是最重要的</p>

<h3 id="_8">借喻</h3>

<p>借喻（用简单的设计元素表示复杂的图像或概念）是一种强大的设计方法，可以为为作品添加一些微妙的气氛并增加作品的深度</p>

<h2 id="_9">光与影</h2>

<h3 id="_10">确定光源的位置</h3>

<h3 id="_11">保留阴影</h3>

<ul>
<li>阴影可以为页面增加丰富的视觉效果</li>

<li>投射出的阴影能让浏览者感觉到页面以及页面中的元素存在层次感</li>

<li>绘图软件中，阴影很容易实现</li>
</ul>

<h3 id="_12">需要注意</h3>

<ul>
<li>注意阴影的深浅，深色的阴影代表物体与背景较近，而浅色的阴影表示物体与背景较远，更靠近观察者</li>

<li>注意阴影的长宽，较为细小的阴影让人感觉物体与背景较近，宽大的阴影让物体看起来离背景较远</li>

<li>确保光源的真实性，阴影的方向要保持统一以体现光源的一致性</li>
</ul>
<hr />
<h2 id="_13">形状</h2>

<h3 id="_14">圆弧</h3>

<p>与女性、阴柔关联，表示温暖、舒适、暧昧、爱情等</p>

<h3 id="_15">三角形</h3>

<p>让人联想到男性、阳刚，表达诸如强壮、攻击以及运动感等含义。</p>

<p>浏览者的目光通常会被吸引至处于支配地位的棱角所指方向。指向上方体现向上的趋势和攻击性，指向下方通常暗示出消极的意味</p>

<h3 id="_16">方形</h3>

<p>暗示力量和根基，看上去足够坚实稳重。给浏览者带来有序、逻辑、严密以及安全的感觉</p>
<hr />
<h2 id="_17">空间</h2>

<p>适当的空间可以将浏览者的目光引导至页面中的关键位置。空间还能够对文本和图像的过密产生一定的缓冲，让眼睛有休息的余地。大大提高内容的可读性，并给读者足够的思考内容的时间</p>

<h3 id="_18">心理和社会意义</h3>

<ul>
<li>间隔空间和经济形势息息相关</li>

<li>使用间隔空间并不意味着这个位置什么都没有</li>

<li>间隔空间与特定地区的文化也有关系</li>
</ul>

<h3 id="_19">正空间和负空间</h3>

<p>正空间是指组成作品的对象所占据的空间，负空间则是指非作品对象部分（即背景）占据的空间。负空间起到定义正空间边界的作用</p>
<hr />
<h2 id="_20">色彩</h2>

<h3 id="_21">清楚地表达信息</h3>

<p>优秀的实际是了解如何恰当地使用色彩来进行交流，表达设计意图，加深浏览者印象。色彩和主题息息相关</p>

<h3 id="_22">色彩和人类心理</h3>

<ul>
<li>红色： 力量、活力、爱、激情、进攻、危险</li>

<li>蓝色： 信任、保守、安全、清洁、悲伤、有序</li>

<li>绿色： 大自然、健康、嫉妒、复苏</li>

<li>橙色： 愉快、幸福</li>

<li>黄色： 乐观、希望、冷静、懦弱</li>

<li>紫色： 神秘</li>

<li>褐色： 可靠、舒适、忍耐、大地</li>

<li>灰色/银色： 智慧、未来、谦虚、悲哀、腐朽、高雅</li>

<li>黑色： 力量、性、完善、神秘、恐惧、忧愁、死亡</li>

<li>白色： 纯洁、干净、精确、清白、中性、不毛、死亡</li>
</ul>

<h3 id="_23">色彩、文化和性别</h3>

<p>文化背景和性别差异都会扩展并复杂化颜色引发的心里联想</p>

<h3 id="css">CSS中的颜色</h3>

<p>系统颜色是在CSS 2.1中引入的一系列关键词，允许设计师是用浏览器计算机上的系统颜色配置如：</p>

<pre class="css21"><code class="css21">color: WindowText</code></pre>

<p>很多人仍然坚持使用“Web安全”的调色板。但目前主流的计算机都能够显示数百万种颜色，所以已经没有必要再受限于这个规定了</p>
<hr />
<h2 id="_24">图案和材质</h2>

<p>图案是指重复填充到指定区域内的某一种（也可能多于一种）小块视觉元素</p>

<p>材质并不一定必须要通过触觉才能感受，视觉也能够体现材质感</p>

<p>图案是体现材质感所必不可少的。通常情况下，图案都能够模拟出材质的效果。很多材质的元素都自然地由图案的自有重复而体现出来。</p>
<hr />
<h2 id="_25">对比度</h2>

<p>对比度差别可以用来区分不同的元素。若对比度太低，则元素会失去彼此的界限并混合在一起，文字也变得难以辨认。若对比度高，则将给浏览者压迫感，同样不会觉得舒适</p>

<h3 id="_26">高对比度</h3>

<p>高对比度让作品显得过于拥挤，有过度设计之嫌。</p>

<p>一般来讲，白底黑字原则在计算机屏幕上同样是达到最佳对比度的不二之选</p>

<p>黑暗房间中一个明亮的LCD屏幕将显得极为刺眼，在这种环境下，阅读任何纯白北京上的文字无疑都是对视力的巨大挑战</p>

<p>若将两种互补色，例如橙色和蓝色、红色和绿色相邻防止，那么将显出明显的边界以及强烈的对比效果。进而引发人不愉快的视觉上的紧张感</p>

<p>在更加暗淡的颜色背景村脱下偏暗的颜色也会变得明亮起来</p>

<h3 id="_27">低对比度</h3>

<p>若作品的对比度过低，往往会给人带来压抑的感觉</p>

<p>若是降低线条与其背景之间的对比度，则能让其看上去变得更细一些</p>

<p>对比度低时，对于视力不好的浏览者来说，看清屏幕上的文字将会更加困难，从而降低可读性</p>

<h3 id="_28">视觉障碍</h3>

<p>对于任何依赖颜色传递的信息，我们都应该提供如下方式中的至少一种来告知用户：蓝色且带有下划线的超链接、包含图标或文本的绿色按钮、带有实现边框的红色警告信息</p>
<hr />
<h2 id="_29">引导视线</h2>

<p>一个良好的作品应该能够引导读者的实现，让读者以合理的逻辑顺序逐一阅读内容中的重点，但同时又不会让读者觉察出来</p>

<p>大多数人会在左边或上边寻找导航条，所以把导航条放那吧</p>

<p>在页面中添加足够、适当的旁白能够为读者的眼镜提供一些休息的空间</p>
<hr />
<h2 id="css_2">CSS技巧</h2>

<h3 id="table">减少使用table布局</h3>

<ul>
<li>表格布局会添加大量的标记（没必要的标记）</li>

<li>间隔图像（table布局中的常见技巧，通常是1*1大小的透明gif图，用来撑大表格等辅助布局），不必要地增加了页面的文件大小</li>

<li>图片通过img加入到页面中，增加了页面文件的大小，导致页面加载时间更长</li>

<li>各个页面必须统一的使用table布局，没给个页面都要包含类似的table和img，每次加载需要重绘，代价很大</li>

<li>降低可访问性，很多为障碍人士准备的屏幕浏览器无法正确理解table布局的页面</li>
</ul>

<p>需要留意CSS布局呈现时的FOUC（无样式内容瞬间），通过把CSS放在文档前来解决（不要使用@import）</p>

<h3 id="_30">图像</h3>

<p>若图像属于“内容”，而不是“样式”的一部分，应该使用img标签，否则应该使用background。通过将内容至于背景图像创建样式，能够：</p>

<ul>
<li>减少页面文件的大小</li>

<li>CSS会被缓存，大多数样式标记放在CSS中，浏览器不必每次都去服务器端获取页面样式，加快加载速度</li>

<li>可访问性增强</li>

<li>网站易于管理</li>
</ul>

<p>使用图片时，使用png可以免去很多不必要的麻烦，它带有256级透明度能够完美的显示阴影效果</p>

<h3 id="_31">外边距重叠</h3>

<p>外边距重叠是指，若两个上下毗邻且都定义了不为0的外边距值，同时有没有任何内边距、边框等设定，那么两个元素之间的距离将小于二者外边距的和。为元素添加1px的垂直内边距，就不会形成外边距重叠了（BFC也可）</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/06/csszengarden-1</guid>
            </item>
        
            <item>
                <title><![CDATA[ 博客换页面了 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/05/new-page</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 05 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>上一篇文章是2月28日，今天这篇3月5日才写。中间隔了这么久，两天一篇的计划又被抛弃了。得加紧赶上了。这段时间还是做了点事的，不过没有记录上。</p>

<h2 id="">起因</h2>

<p>如果之前看过这个博客的人一定会发现，整个页面焕然一新了。之前用的是html5up-striped的模板。虽然浏览器兼容性很好，但无论是背景纹理的图片大小还是为了那兼容性所使用的响应式库的大小都让这个搭载在github上的博客肝颤（背景纹理两张分别为60k+，skelton的js有41k+还有50k+的CSS以及好几百K的字体…）。加载速度简直让我这种强迫症患者有种砸电脑的感觉。同时使用别人的代码，自己也不好修改，不好扩展，不好发挥。于是乎就决定自己写一个响应式的页面出来。这个页面就出来了。</p>

<h2 id="_2">参考</h2>

<p>这个页面是参考了<a href="http://www.csszengarden.com/220//">CSS禅意花园的220号作品</a>。不过CSS文件并不是照搬他的，都是自己重写的（压缩后的大小8KB）。不过用了它的两个图片（都很小，2.79K+1.77K）。之前也是使用了禅意花园上的那种“文字配合mask-image”的形式，后来发现除了Chrome都不兼容（我勒个血槽，连FF都不兼容）于是乎就转而去网上寻找纹理。在一个非常不错的纹理网站<a href="http://subtlepatterns.com/">Subtle Patterns</a> 上找到了两个纹理，分别作为博客中的背景以及文章中代码块的背景（一个113B，一个128B，注意是B不是KB），简直爽歪歪。瞬间感觉之前的60K的背景纹理就是渣渣啊。于是乎就剩jQuery比较大了，但是jQuery可以放在CDN上，这里使用的是百度提供的CDN（速度杠杠的，400ms）。如果后续有时间，我会抛弃jQuery，重写博客中的JS部分，这样就更快了（其实压根就没有几行js代码）</p>

<h2 id="_3">设计</h2>

<p>这个页面的设计也是<a href="http://skyinlayer.com/blog/2014/02/14/responsive-web-design/">响应式设计</a>的<a href="http://skyinlayer.com/blog/2014/02/25/design-strategies/">移动先行策略</a>的产物。贯彻其从小到大的方针。</p>

<h3 id="_4">小视口出发</h3>

<p>从小型视口出发（这里我定义的小型视口是宽度小于768px的视口，准确来说是48em，font-size为初始的16px，为什么呢，因为我的ipad mini竖屏分辨率是768…）。定义了一套布局，最上面是header，里面有主要导航条，下面是内容，再下面是一些其他链接（以后成为侧边栏），再下面是footer</p>

<p>于是乎格式就变成了html文档大概就会变成这个样子：</p>

<pre class="xml"><code class="xml">&lt;body&gt;
    &lt;div class=&quot;wrapper&quot;&gt;
        &lt;header class=&quot;header&quot;&gt;
            &lt;div class=&quot;banner&quot;&gt;&lt;/div&gt;
            &lt;nav&gt;&lt;/nav&gt;
        &lt;/article&gt;
        &lt;/header&gt;
        &lt;div class=&quot;content&quot;&gt;
            &lt;article class=&quot;post&quot;&gt;
                &lt;header&gt;&lt;/header&gt;
                &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
                &lt;a class=&quot;to-detail&quot; href=&quot;#&quot;&gt;&lt;/a&gt;
                &lt;div class=&quot;tags&quot;&gt;&lt;/div&gt;
            &lt;/article&gt;
        &lt;/div&gt;
        &lt;aside class=&quot;aside&quot;&gt;
            &lt;section class=&quot;recent&quot;&gt;
                &lt;h3&gt;&lt;/h3&gt;
                &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
            &lt;/section&gt;
        &lt;/aside&gt;
        &lt;footer class=&quot;footer&quot;&gt;
        &lt;/footer&gt;
    &lt;/div&gt;
&lt;/body&gt;</code></pre>

<p>这里先用了几个语义化元素，header、nav、section、footer、article还有aside。另外我喜欢用一个wrapper包裹所有内容，方便以后有需要的时候布局</p>

<p>其中article的内容从上到下排布就好，所以我这里设定了<code>&lt;a class=&quot;to-detail&quot; href=&quot;#&quot;&gt;&lt;/a&gt;</code>为<code>display:block</code>，其他在结构上基本上保持了原样</p>

<p>小视口设备上的绝大部分内容都是很直观的显示的，也不用谈太多的布局，把一些基础的展现效果的css加进去就好，主要就是控制h1~h6的文字大小（上下margin），文字颜色，背景颜色等等</p>

<p>大致上达到的效果：</p>

<h3 id="_5">中视口的扩展</h3>

<p>中视口设备基本上和小视口设备差不多，我这里只不过在aside里面的内容作了一些变化，同时在主页上拉出一个侧边栏用于显示“查看详细”按钮</p>

<p>这样就需要添加一些布局进去了，这里都采用了很简单的布局，基本上就是float+BFC，保证浮动元素与非浮动元素不重叠</p>

<p>于是乎简单的布局代码如下</p>

<pre class="css21"><code class="css21">@media screen and (min-width: 48em) {
    .content .post .to-detail {width: 18%; overflow: hidden}
    .content .post .main {float:left;width: 80%; }
    .content .post .tags {clear:both}
    
    .aside section h3 {float:left; width: 30%;}
    .aside section .inner {overflow: hidden;}
    .aside section:after {content: &quot;&quot;; display: block; height: 0; visibility: hidden; clear: both; }
}</code></pre>

<p>大致上说一下，设定了float的元素一般会与不设定float的元素重叠，但如果不设定float的元素触发了BFC，就不会了，于是乎这里使用<code>overflow:hidden</code>触发BFC，同时由于有浮动元素的存在，需要清除浮动，如果后面有元素，在后面元素上加上<code>clear:both</code>就可以了。如果后面没有元素，那就在父元素上加入一个<code>::after</code>伪元素，里面设定清除浮动，代码如上所示</p>

<p>这样中视口的布局效果就搞定了，还可以加上一些额外的效果，比如修改一下h1~h6的文字大小和margin，修改一下导航条内元素的间距之类的</p>

<h3 id="_6">大视口的变革</h3>

<p>中视口和小视口终究还是一栏布局（中视口虽然拉出了一列仅显示“查看详细”按钮，但本质上还是一栏布局）。到了大视口（我这里定义的大视口是大于等于1024px，也就是64em的视口，为什么呢？因为我的ipadmini 横屏是1024px），边栏应该拉出来，放在屏幕的左边，内容在右边，同时footer应该还在最下面</p>

<p>还是用之前类似的方式，核心CSS如下：</p>

<pre class="css21"><code class="css21">@media screen and (min-width: 64em) {
    .content {float:right;}
    .aside {overflow: hidden}
    .footer {clear:both}
}</code></pre>

<p>这样布局修改就完成了，再加上一些CSS3的animation特效，齐活</p>

<h2 id="_7">总结</h2>

<p>响应式页面设计还是很有意思的，逐步向上扩展，需要很明确的将各个部分划分成一块一块，方便日后响应式布局，新的页面虽然丑了点，但是还能看，有点小清新的感觉（笑），关键是加载的大小降低了很多。至于浏览器的兼容性问题，我只是兼容了比较主流的浏览器，没有兼容ie6-8这些坑货，不过无所谓了，能兼容ie9+，Chrome和Firefox、opera我就满足了，毕竟ie8压根就不支持CSS3的media queries</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/05/new-page</guid>
            </item>
        
            <item>
                <title><![CDATA[ 网页布局实例 ]]></title>
                <link>http://skyinlayer.com/blog/2014/03/05/layouts</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 05 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">前面的话</h2>

<p>最近看前端相关面试题，看到很多关于CSS布局的面试题。于是乎自己实现了几个常用的布局，这里记录一下实现。所有的布局均已上传到github，命名为<a href="https://github.com/LingyuCoder/sky_layouts">sky_layouts项目</a></p>

<p>所有的页面都引入了一段CSS reset的代码，用于屏蔽不同浏览器之间的差异</p>

<pre class="css21"><code class="css21">/* Style reset 消除浏览器默认样式 */
body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,blockquote,th,td,p{margin:0;padding:0}input,button,select,textarea{outline:none}li{list-style:none}img{border:none}textarea{resize:none}body{color:#666;background:#fff;word-break:break-all;word-wrap:break-word;text-align:center}body,input,textarea{font-size:12px;font-family:\5b8b\4f53,Verdana,Arial}a{color:#305999;text-decoration:none;outline:none}a:hover{color:#090}.wrap{width:1000px;margin:0 auto;text-align:left;position:relative}/*clearfix*/.clearfix:after,.wrap:after{content:&quot;.&quot;;display:block;height:0;clear:both;visibility:hidden}.clearfix,.wrap{*+height:1%}</code></pre>

<p>另外这里所有的header区、footer区的高度都为100px，侧边栏都是300px</p>

<h2 id="_2">单栏水平居中布局（首尾全屏）</h2>

<p>这种布局很常见，比如新浪微博的布局就是这样，header宽度为全屏，内容区宽度固定</p>

<p>这种布局有三部分构成:</p>

<ul>
<li>header区，g-hd</li>

<li>main区，g-mn</li>

<li>footer区，g-ft</li>
</ul>

<h3 id="html">HTML结构</h3>

<pre class="xml"><code class="xml">&lt;div class=&quot;g-hd&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;g-mn&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;g-ft&quot;&gt;
&lt;/div&gt;</code></pre>

<h3 id="css">CSS样式</h3>

<pre class="css21"><code class="css21">.g-hd, .g-ft {
    height: 100px;
}
.g-mn {
    max-width: 1000px;
    margin: 0 auto
}</code></pre>

<h3 id="_3">说明</h3>

<p>这里技巧不多，使用了一个很常见的水平居中样式<code>margin: 0 auto</code>。需要注意的是<code>max-width: 1000px</code>这个属性，这个属性时为了自适应。当浏览器窗口宽度大于1000px时，main区将以1000px的宽度居中显示。如果浏览器窗口宽度小于等于1000px时，页面的宽度将是浏览器窗口宽度</p>

<h3 id="_4">效果</h3>

<p><a href="http://jsfiddle.net/skyinlayer/24rT2/">jsfiddle地址</a></p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/24rT2/embedded/result,html,css' width='100%'>&nbsp;</iframe>
<h3 id="_5">浏览器兼容性</h3>

<p>兼容ie8+和所有现代浏览器，如果设定为固定宽度，则兼容ie6</p>

<h2 id="_6">单栏水平居中布局（全部居中）</h2>

<p>实现思路和上面类似，不过这次把header区，main区，footer区全部放在一个容器中，然后把这个容器设定居中（记得设定max-width）</p>

<h3 id="html_2">HTML结构</h3>

<pre class="xml"><code class="xml">&lt;div class=&quot;g-ctn&quot;&gt;
    &lt;div class=&quot;g-hd&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;g-mn&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;g-ft&quot;&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>

<h3 id="css_2">CSS样式</h3>

<pre class="css21"><code class="css21">.g-ctn { margin: 0 auto; max-width: 1000px;}
.g-hd, .g-ft {height: 100px }</code></pre>

<h3 id="_7">预览效果</h3>

<p><a href="http://jsfiddle.net/skyinlayer/24rT2/1/">jsfiddle地址</a></p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/24rT2/1/embedded/result,html,css' width='100%'>&nbsp;</iframe>
<h3 id="_8">浏览器兼容性</h3>

<p>兼容ie8+和所有现代浏览器，如果设定为固定宽度，则兼容ie6</p>

<h2 id="_9">全屏两栏自适应布局</h2>

<p>这一类布局分为4个部分：</p>

<ul>
<li>header区 g-hd</li>

<li>footer区 g-ft</li>

<li>aside区 g-sd</li>

<li>main区 g-mn</li>
</ul>

<p>这种布局一般用于应用类的页面，所有区块全部在一个屏幕中固定显示，内容溢出时使用滚动条浏览</p>

<h3 id="html_3">HTML结构</h3>

<pre class="xml"><code class="xml">&lt;div class=&quot;g-hd&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;g-sd&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;g-mn&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;g-ft&quot;&gt;
&lt;/div&gt;</code></pre>

<h3 id="css_3">CSS样式</h3>

<pre class="css21"><code class="css21">html, body {height: 100%; width: 100%; }
.g-hd, .g-ft {position: absolute; width: 100%; height: 100px;  }
.g-hd {top: 0; }
.g-ft {bottom: 0; }
.g-sd, .g-mn {position: absolute; top: 100px; bottom: 100px; overflow: auto; }
.g-sd {width: 300px; }
.g-mn {left: 300px; right: 0px; }</code></pre>

<h3 id="_10">说明</h3>

<p>这里首先需要注意<code>html, body {height: 100%; width: 100%; }</code>，这一句是常用的将页面的宽度、高度定义为浏览器窗口的大小一致。然后将四个区块全都设置为<code>position: absolute</code>绝对定位，通过设定每个区块相对于根元素的位置，来拉开区块。比如main区，相对上下都有100px的空隙，左侧300px的空隙(这里侧边栏设定为300px)，所以其css样式为<code>.g-mn {position: absolute; top: 100px; bottom: 100px;left: 300px;}</code>其他也是一样的方式。需要注意给侧边栏和内容区增加<code>overflow:auto</code>，这样在其内容溢出时，显示滚动条</p>

<h3 id="_11">预览效果</h3>

<p><a href="http://jsfiddle.net/skyinlayer/24rT2/2/">jsfiddle地址</a></p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/24rT2/2/embedded/result,html,css' width='100%'>&nbsp;</iframe>
<h3 id="_12">浏览器兼容性</h3>

<p>兼容所有ie8+和现代浏览器</p>

<h2 id="_13">全屏三栏自适应布局</h2>

<p>这一类布局有5个部分：</p>

<ul>
<li>header区 g-hd</li>

<li>footer区 g-ft</li>

<li>main区 g-mn</li>

<li>左侧边栏 g-lsd</li>

<li>右测边栏 g-rsd</li>
</ul>

<h3 id="html_4">HTML结构</h3>

<pre class="xml"><code class="xml">&lt;div class=&quot;g-hd&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;g-lsd&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;g-mn&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;g-rsd&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;g-ft&quot;&gt;&lt;/div&gt;</code></pre>

<h3 id="css_4">CSS样式</h3>

<pre class="css21"><code class="css21">html, body {width: 100%; height: 100%; }
.g-hd, .g-ft {height: 100px; width: 100%;}
.g-hd, .g-ft, .g-lsd, .g-rsd, .g-mn {position: absolute;} 
.g-lsd, .g-rsd, .g-mn {top: 100px;bottom: 100px;overflow: auto;}
.g-lsd, .g-rsd {width: 300px;}
.g-mn {right: 300px;left: 300px;}
.g-rsd {right: 0 }
.g-ft {bottom: 0; }</code></pre>

<h3 id="_14">说明</h3>

<p>和上面全屏两栏自适应布局一样，首先使用<code>html, body {width: 100%; height: 100%; }</code>设定整个页面的大小为浏览器窗口大小，然后通过上例同样的方式将所有元素设定为绝对位置，通过偏移拉长区块。同时左侧边栏、内容区、右侧边栏都需要设定<code>overflow: auto</code>使得内容溢出时显示滚动条</p>

<h3 id="_15">预览效果</h3>

<p><a href="http://jsfiddle.net/skyinlayer/24rT2/3/">jsfiddle地址</a></p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/24rT2/3/embedded/result,html,css' width='100%'>&nbsp;</iframe>
<h3 id="_16">浏览器兼容性</h3>

<p>兼容所有ie8+和现代浏览器</p>

<h2 id="_17">两栏自适应布局（左侧固定，右侧自适应）</h2>

<p>这个分四块：</p>

<ul>
<li>header区 g-hd</li>

<li>aside区 g-sd</li>

<li>main区 g-mn</li>

<li>footer区 g-ft</li>
</ul>

<h3 id="html_5">HTML结构</h3>

<pre class="xml"><code class="xml">&lt;div class=&quot;g-hd&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;g-sd&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;g-mn&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;g-ft&quot;&gt;&lt;/div&gt;</code></pre>

<h3 id="css_5">CSS样式</h3>

<pre class="css21"><code class="css21">.g-hd, .g-ft {height: 100px;}
.g-ft {clear: both;}
.g-sd {float: left; width: 300px; }
.g-mn {*zoom: 1; overflow: hidden; }</code></pre>

<h3 id="_18">说明</h3>

<p>常见情况，侧边栏宽度固定，右侧内容区自适应布局。这里使BFC，设定aside区为浮动，在main区触发BFC，使得不与aside区重叠。同时由于有浮动出现，所以在footer区加上<code>clear:both</code>来清除浮动。在老式的ie中使用<code>zoom:1</code>来达到BFC的效果</p>

<h3 id="_19">效果预览</h3>

<p><a href="http://jsfiddle.net/skyinlayer/24rT2/4/">jsfiddle地址</a></p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/24rT2/4/embedded/result,html,css' width='100%'>&nbsp;</iframe>
<h3 id="_20">浏览器兼容</h3>

<p>兼容ie6+及所有现代浏览器</p>

<h2 id="_21">两栏底部自适应布局</h2>

<p>这个分4个区块：</p>

<ul>
<li>header区 g-hd</li>

<li>footer区 g-ft</li>

<li>main区 g-mn</li>

<li>aside区 g-sd</li>
</ul>

<p>这个需求比较有意思，主要是需要footer在内容aside区、main区内容都比较少时（不满一个屏幕），显示在页面底部，而当aisde区、main区内容增多时，footer区显示在这两个区下面（高度较高的元素下面）</p>

<h3 id="html_6">HTML结构</h3>

<pre class="xml"><code class="xml">&lt;div class=&quot;g-hd&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;g-ctn&quot;&gt;
    &lt;div class=&quot;g-ct&quot;&gt;
        &lt;div class=&quot;g-sd&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;g-mn&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;g-ft&quot;&gt;
&lt;/div&gt;</code></pre>

<h3 id="css_6">CSS样式</h3>

<pre class="css21"><code class="css21">html, body {width: 100%; height: 100%; }
.g-ctn {position: relative; min-height: 100%; }
    .g-ctn .g-ct {padding-top: 100px; padding-bottom: 100px; overflow: hidden; }
        .g-ctn .g-ct .g-sd {float: left; height: 600px; width: 300px; }
        .g-ctn .g-ct .g-mn {height: 600px; overflow: hidden; zoom:1; }
.g-hd {height: 100px; margin-bottom: -100px; }
.g-ft {height:100px; margin-top: -100px; }</code></pre>

<h3 id="_22">说明</h3>

<p>首先需要设定html的高度为一个页面以方便将一个div（g-ctn）设定为最小大小为浏览器窗口大小。然后针对这个g-ctn，header区（g-hd）和footer区（g-ft），利用负margin来将他们定位到g-ctn里面，这样g-ctn的大小就是整个页面了。然后在g-ctn中顶一个一个div（g-ct），为其设定<code>padding-top</code>和<code>padding-bottom</code>来防止内容区和header区与footer区重叠。然后在这个区块触发BFC，来清除子元素浮动，清除aside区（g-sd）的浮动。在里面放入aside区和main区，将aside区设为<code>float: left</code>，在main区上触发BFC，防止其余aside区重叠。这样布局就完成了</p>

<h3 id="_23">预览效果</h3>

<p><a href="http://jsfiddle.net/skyinlayer/24rT2/5/">jsfiddle地址</a></p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/24rT2/5/embedded/result,html,css' width='100%'>&nbsp;</iframe>
<h3 id="_24">浏览器兼容性</h3>

<p>兼容ie6+和所有现代浏览器</p>

<h2 id="_25">三栏底部自适应布局</h2>

<p>这个布局分5块：</p>

<ul>
<li>header区 g-hd</li>

<li>footer区 g-ft</li>

<li>main区 g-mn</li>

<li>左边栏区 g-lsd</li>

<li>右边栏区 g-rsd</li>
</ul>

<h3 id="html_7">HTML结构</h3>

<pre class="xml"><code class="xml">&lt;div class=&quot;g-hd&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;g-ctn&quot;&gt;
    &lt;div class=&quot;g-ct&quot;&gt;
        &lt;div class=&quot;g-lsd&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;g-rsd&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;g-mn&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;g-ft&quot;&gt;&lt;/div&gt;</code></pre>

<h3 id="css_7">CSS样式</h3>

<pre class="css21"><code class="css21">html, body {width: 100%; height: 100%; }
.g-hd {margin-bottom: -100px; height: 100px; }
.g-ft {margin-top: -100px; height: 100px; }
.g-ctn {position: relative; min-height: 100%; }
    .g-ctn .g-ct {padding: 100px 0; overflow: hidden; *zoom: 1; }
        .g-ctn .g-ct .g-lsd {width: 300px; float: left; }
        .g-ctn .g-ct .g-rsd {width: 300px; float: right; }
        .g-ctn .g-ct .g-mn {overflow: hidden; *zoom: 1; }</code></pre>

<h3 id="_26">说明</h3>

<p>和上面底部两栏自适应几乎一样，不过这一次分为左边栏和右边栏，所以需要注意一下，把两个侧边栏写在前面，后面写main区，否则会出现main区直接把右边栏挤开的情况</p>

<h3 id="_27">预览效果</h3>

<p><a href="http://jsfiddle.net/skyinlayer/24rT2/6/">jsfiddle地址</a></p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/24rT2/6/embedded/result,html,css' width='100%'>&nbsp;</iframe>
<h2 id="_28">总结</h2>

<p>还有很多很多的布局没有实现，有时间实现一些其他的布局，布局前端面试还是问的很多的，手动实现了一下发现，还是需要动手的，否则直接问真心不一定能答上来</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/03/05/layouts</guid>
            </item>
        
            <item>
                <title><![CDATA[ 初识Grunt ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/28/grunt</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 28 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>最近总是看到各种推荐使用Grunt的文章，说其对前端项目开发的自动化程度提升到一个新的流程。之前开发也是苦于各种文件的处理，比如之前写less的时候，每次改动都得手动去调用命令编译一次，效率很低。而Grunt正解决了这个问题，于是乎乘着这两天闲下来了，乘机学习了一下Grunt的基础用法</p>

<h2 id="grunt">什么是Grunt？</h2>

<p>Grunt官网首页上，最显眼的一句话就是：“Grunt JavaScript世界的构建工具”，它运行于Node.js平台</p>

<h2 id="grunt_2">为什么要用Grunt？</h2>

<p>面对以下一些常见的前端开发中的问题，Grunt都可以大展拳脚</p>

<h3 id="">文件的压缩与合并</h3>

<p>在平常的前端项目开发中，最需要顾忌的就是效率问题。为了提升用户体验，页面的加载不能过长，这也就使得“优化”在前端开发中永远是个说不完道不尽的话题。一些比较常见的优化方式有这么几种：</p>

<ul>
<li>JavaScript文件的优化：将多个JS文件合并成一个文件，以减少请求次数。对JavaScript文件采用压缩，消除掉所有缩进和换行，减小文件体积。使用类似uglify的压缩工具压缩JavaScript代码内部变量名称长度，减少文件体积等等</li>

<li>CSS文件的优化：将多个CSS文件合并成一个文件，并进行压缩。道理同JS文件的合并及压缩</li>

<li>图片文件的合并：sprite技术，也是为了减少请求次数</li>

<li>等等等等</li>
</ul>

<p>这些文件的压缩合并都可以交给Grunt进行处理</p>

<h3 id="_2">代码提示</h3>

<p>无论CSS、JavaScript、HTML都是在快速发展的，这也导致了API及一些属性功能的变化。同时这些代码不像Java那样有一套完善的编码时错误提示，这也是JSHint，CSSHint等代码提示出现的原因。这些编码提示也可以通过Grunt来进行处理</p>

<h3 id="_3">预处理</h3>

<p>众所周知，现在出现了很多以提升开发效率为目的的前端语言预处理方案：</p>

<ul>
<li>CSS相关：Less和Sass，通过简洁的语法，来提升代码的复用性</li>

<li>JavaScript相关：CoffeeScript，类似Python的语法，友好而高效</li>

<li>HTML：一些模板引擎如Jade</li>
</ul>

<p>这些预处理也可以交给Grunt来进行</p>

<h3 id="_4">一些额外的处理</h3>

<p>有时候还会需要一些额外的需求，比如添加版本自动更新注释，CSS前缀自动补全等等。这些Grunt也提供了很多插件进行处理，方便快捷</p>

<h2 id="grunt_3">安装Grunt</h2>

<h3 id="xxx">首先你得有一个xxx</h3>

<p>想要使用Grunt，首先你得有一个Node.js环境和一个npm。这俩网上教程一大把，安装也很简单，就不说了。这里只提及Grunt如何安装</p>

<p>另外这里介绍的是Grunt 0.4.x，要求Node.js的版本在0.8.0以上，如果已经使用了Grunt 0.3.x版本的，可以先卸载，然后重新安装0.4.x版本</p>

<h3 id="npmgrunt">使用npm安装Grunt命令行</h3>

<p>执行如下代码：</p>

<pre class="shell"><code class="shell">$ npm install -g grunt-cli</code></pre>

<p>这样就可以在命令行使用<code>grunt</code>命令。需要注意的是，安装了grunt-cli并不等同于安装了Grunt，它只是一个命令行命令，用来调用与gruntfile文件在同一目录下的grunt的，如果没有grunt，将会给一个错误提示并退出。之所以这么设计的主要原因是，这样可以在同一个系统上安装多个版本的grunt了</p>

<h3 id="grunt_4">安装Grunt</h3>

<p>使用过Node.js做过项目的人应该都对<code>package.json</code>这个文件不陌生了。Grunt安装也是通过npm安装，所以只要将其加入到<code>devDependencies</code>中就可以了。一个简单的package.json文件大概长这个样子：</p>

<pre class="javascript"><code class="javascript">{
  &quot;name&quot;: &quot;your project name&quot;,
  &quot;version&quot;: &quot;x.x.x&quot;,
  &quot;devDependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.4.2&quot;,
    &quot;grunt-autoprefixer&quot;: &quot;~0.4.0&quot;,
    &quot;grunt-contrib-watch&quot;: &quot;~0.5.3&quot;,
    &quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;,
    &quot;grunt-contrib-cssmin&quot;: &quot;~0.8.0&quot;,
    &quot;load-grunt-tasks&quot;: &quot;~0.2.0&quot;
  }
}</code></pre>

<p>在写完类似的<code>package.json</code>（或添加完Grunt依赖后），运行<code>npm install</code>就可以从npm自动安装了，下面几个都是grunt的可选查件，大致上介绍几个可选查件（包括上面出现的和没出现的）:</p>

<ul>
<li>grunt-contrib-watch: 自动监听指定文件改变并执行相关任务流的插件</li>

<li>grunt-contrib-concat: 文本合并插件</li>

<li>grunt-contrib-cssmin: CSS代码压缩插件</li>

<li>grunt-autoprefixer: 为CSS属性自动添加前缀，兼容信息来自著名的<a href="http://caniuse.com/">Can I Use</a>网站</li>

<li>grunt-contrib-jshint：JavaScript代码提示插件</li>

<li>grunt-contrib-uglify：JavaScript代码压缩插件</li>

<li>load-grunt-tasks：自动加载Grunt插件的插件（好绕口）</li>

<li>还有一大堆请参见<a href="http://gruntjs.com/plugins">Grunt plugins</a>，这个是官网上的，但是我显示不出来,无止境的loading，所以可以去<a href="https://npmjs.org/">npm官网</a>上搜gruntplugin关键字</li>
</ul>

<p>这些插件的安装也是一样写在devDependencies中，定好需要的版本号后直接使用<code>npm install</code>命令安装可以了。或者也可以反过来，先使用<code>npm install grunt --save-dev</code>安装，然后再将依赖加入到package.json的devDependencies中</p>

<h2 id="grunt_5">配置项目中的Grunt</h2>

<p>Grunt的配置都写在一个名为<code>Gruntfile.js</code>的文件中（当然，在这里面可以通过引入外部文件的方式来加载自己的配置文件），这个文件必须在项目的根目录下，也就是和<code>package.json</code>同一路径下，一个简单的<code>Gruntfile.js</code>文件大概长这个样子：</p>

<pre class="javascript"><code class="javascript">module.exports = function(grunt) {
  grunt.initConfig({
    //确定需要加载的package.json文件的路径
    pkg: grunt.file.readJSON(&#39;package.json&#39;),
    //定义任务
    concat: {
      dist: {
        src: [
          &#39;src/css/*.css&#39;
        ],
        dest: &#39;skyinlayer.css&#39;
      }
    }
  });
  //加载插件
  grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;);
  //定义默认任务列表
  grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;]);
};</code></pre>

<h3 id="packagejson">引入package.json中的配置</h3>

<p>通过<code>pkg</code>引入的<code>package.json</code>文件的JSON数据可以通过<code>&lt;% %&gt;</code>模板字符串来进行引用</p>

<h3 id="_5">定义任务</h3>

<p>定义任务部分则是定义了一个任务所需要的相关配置，比如这里定义了合并文件（concat）任务，相关配置确定了需要被合并的文件为<code>src/css/</code>下的所有后缀为<code>.css</code>的文件，合并完成的文件输出到根目录下的<code>skyinlayer.css</code>文件中。</p>

<p>在定义任务部分可以定义多个任务，比如我写一个纯CSS的项目，也需要经过合并、添加前缀、压缩等任务，，所以可以将其修改为如下：</p>

<pre class="javascript"><code class="javascript">concat: {
  dist: {
    src: [
      &#39;src/base.css&#39;,
      &#39;src/**/*.css&#39;
    ],
    dest: &#39;skyinlayer.css&#39;
  }
},

autoprefixer: {
  no_dest: {
    src: &#39;skyinlayer.css&#39;
  },
},

cssmin: {
  minify: {
    src: [&#39;skyinlayer.css&#39;],
    dest: &#39;skyinlayer.min.css&#39;,
  },
}</code></pre>

<h3 id="_6">加载插件</h3>

<p>由于Grunt的任务都是通过npm插件的形式被引入的，所以需要进行查件加载，通过如下语句加载：</p>

<pre class="javascript"><code class="javascript">grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;);
grunt.loadNpmTasks(&#39;grunt-autoprefixer&#39;);
grunt.loadNpmTasks(&#39;grunt-contrib-cssmin&#39;);</code></pre>

<p>这样就加载了三个插件，分别用来指向上面定义的三个任务，值得注意的是可以使用<code>load-grunt-tasks</code>来自动加载所有在<code>package.json</code>中被依赖的grunt插件，其检测的标准是插件名称以<code>grunt-</code>字符串开头。如果使用了<code>load-grunt-tasks</code>，加载就变得很简单了，一句代码搞定：</p>

<pre class="javascript"><code class="javascript">require(&#39;load-grunt-tasks&#39;)(grunt);</code></pre>

<h3 id="_7">定义默认任务流程</h3>

<p>在定义完任务以及加载完插件之后，我们需要定义任务流程，确定任务执行的顺序。使用如下代码定义任务流程：</p>

<pre class="javascript"><code class="javascript">grunt.registerTask(&#39;default&#39;, [&#39;concat&#39;,&#39;autoprefixer&#39;,&#39;cssmin&#39;]);</code></pre>

<p>这样定义完后，每次执行<code>grunt</code>命令，就会制动执行代码合并，添加前缀和CSS代码压缩三项任务了</p>

<h3 id="_8">监听文件变化</h3>

<p>一般情况下，我们需要多次改动代码来查看效果，有时候改动很小甚至只是一个数字。这样每次改动都需要手动执行grunt命令太麻烦了，<code>grunt-contrib-watch</code>这个插件帮我们解决了这个问题。引入<code>grunt-contrib-watch</code>插件和上面一样（如果使用了<code>load-grunt-tasks</code>，不需要额外的引入过程）。定义watch任务：</p>

<pre class="javascript"><code class="javascript">watch: {
  css: {
    files: [
      &#39;src/**/*&#39;,
      &#39;!node_modules&#39;
    ],
    tasks: [&#39;concat&#39;, &#39;autoprefixer&#39;, &#39;cssmin&#39;],
  }
}</code></pre>

<p>其中，files属性可以定义哪些文件需要监听改变，哪些不需要，而tasks则定义了文件改变后需要执行的任务流程。这样定义的话，比如我的<code>src/css/base.css</code>文件进行了变更，在保存的时候，将自动执行代码合并，前缀添加及代码压缩等任务</p>

<h2 id="_9">总结</h2>

<p>Grunt其实还有很多更加深入的用法，比如读取json问价作为配置文件、根据配置文件动态的进行处理等等（比如<a href="https://github.com/daneden/animate.css">daneden的animate.css项目</a>），这里就只是介绍了一下基础的用法。学好了Grunt，以后也可以出去和别人吹牛逼说自己的项目工作流是自动化的啦（括弧笑）</p>

<h2 id="_10">更多详细请参考</h2>

<p><a href="http://www.gruntjs.net/">Grunt官网</a></p>

<p><a href="http://www.w3cplus.com/blog/tags/372.html">W3CPlus的Grunt相关文章</a></p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/28/grunt</guid>
            </item>
        
            <item>
                <title><![CDATA[ 深入浅出BFC（Block formatting contexts） ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/26/BFC</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 26 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="bfc">何为BFC</h2>

<p>BFC（Block formatting contexts）,是W3C CSS 2.1中的一个概念，决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。在创建了BFC的元素中，子元素会一个接一个的被放置。垂直方向上，他们的起点是一个包含块的顶部，两个相邻元素之间的垂直距离取决于<code>margin</code>特性。BFC中相邻的块级元素的垂直边距(<code>margin-top</code>和<code>margin-bottom</code>)会被折叠（collapse）。在BFC中，每一个元素的左边与包含块的左边（<code>border-left</code>）相接触（如果从右到左的格式化，右边接触包含块的<code>border-right</code>），除非这个元素也创建了一个BFC。</p>

<h2 id="bfc_2">触发BFC</h2>

<p>满足以下任意一个情况就会触发BFC：</p>

<ul>
<li>根节点</li>

<li>浮动（<code>float</code>不为<code>none</code>）</li>

<li>绝对定位元素（<code>position</code>为<code>absolute</code>或<code>fixed</code>）</li>

<li><code>display: inline-block</code>的元素</li>

<li><code>display: table-cell</code>的元素（HTML的table格子默认就是这个）</li>

<li><code>display: table-caption</code>的元素(HTML的table caption默认就是这个)</li>

<li><code>overflow</code>不为<code>visible</code>的元素</li>

<li>伸缩盒元素（<code>display</code>为<code>flex</code>或<code>inline-flex</code>）</li>
</ul>

<h2 id="bfc_3">BFC的作用</h2>

<p>BFC的主要知识点在清除浮动重叠与margin重叠上，margin重叠有如下规则：</p>

<ul>
<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值</li>

<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值</li>

<li>两个外边距一正一负时，折叠结果是两者的相加的和</li>
</ul>

<h3 id="bfcmargin">BFC清除嵌套元素的margin重叠</h3>

<p>如果父元素不触发BFC，</p>

<pre class="xml"><code class="xml">&lt;div class=&quot;outer&quot;&gt;
	&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre>

<p>CSS代码如下：</p>

<pre class="css21"><code class="css21">.outer {
	background-color: #f0f0f0;
	width: 100%;
	margin-top: 50px;
}
	.outer .inner {
		width: 100px;
		height: 100px;
		margin-top: 50px;
		background-color: blue;
	}</code></pre>

<p>效果图：</p>

<p><img src="/images/BFC/1.png" alt="不触发BFC时垂直margin重叠" /></p>

<p>可以看到，子元素inner和父元素outer的<code>margin-top</code>重叠了</p>

<p>在outer上触发BFC，修改CSS：</p>

<pre class="css21"><code class="css21">.outer {
	background-color: #f0f0f0;
	width: 100%;
	margin-top: 50px;
	overflow: hidden;
}
	.outer .inner {
		width: 100px;
		height: 100px;
		margin-top: 50px;
		background-color: blue;
	}</code></pre>

<p>效果图： <img src="/images/BFC/2.png" alt="触发BFC后垂直margin不重叠" /></p>

<p>在触发了父元素的BFC，于是乎margin不再重叠</p>

<h3 id="">不与浮动元素重叠</h3>

<pre class="xml"><code class="xml">&lt;div class=&quot;outer&quot;&gt;
	&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
	&lt;div class=&quot;top&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre>

<pre class="css21"><code class="css21">.outer {
	background-color: #f0f0f0;
	width: 100%;
}
	.outer .left {
		width: 100px;
		height: 200px;
		background-color: blue;
		float: left;
	}

	.outer .top {
		width: 200px;
		height: 100px;
		background-color: red;
	}</code></pre>

<p>效果图：</p>

<p><img src="/images/BFC/3.png" alt="两个矩形重叠" /></p>

<p><img src="/images/BFC/4.png" alt="检索left元素" /></p>

<p><img src="/images/BFC/5.png" alt="检索top元素" /></p>

<p>可以从上面三张图看到，两个长方形被重叠了</p>

<p>在非浮动元素（top）上触发BFC，修改CSS:</p>

<pre class="css21"><code class="css21">.outer {
	background-color: #f0f0f0;
	width: 100%;
}
	.outer .left {
		width: 100px;
		height: 200px;
		background-color: blue;
		float: left;
	}

	.outer .top {
		width: 200px;
		height: 100px;
		background-color: red;
		overflow:hidden;
	}</code></pre>

<p>效果图：</p>

<p><img src="/images/BFC/6.png" alt="浮动元素与非浮动元素不再重叠" /></p>

<p>两个矩形不再重叠，不过需要注意在非浮动元素上触发BFC</p>

<h3 id="_2">清除元素内部浮动</h3>

<pre class="xml"><code class="xml">&lt;div class=&quot;outer&quot;&gt;
	&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
	&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre>

<pre class="css21"><code class="css21">.outer {
	background-color: #f0f0f0;
	width: 100%;
}
	.outer .left {
		width: 100px;
		height: 100px;
		background-color: blue;
		float: left;
	}

	.outer .right {
		width: 100px;
		height: 100px;
		background-color: red;
		float: right;
	}</code></pre>

<p>效果图：</p>

<p><img src="/images/BFC/7.png" alt="outer没有被浮动元素撑开" /></p>

<p>可以看到，outer并没有被撑开，查看元素发现其高度为0px</p>

<p>修改css在outer上触发BFC：</p>

<pre><code>.outer {
	background-color: #f0f0f0;
	width: 100%;
	overflow: hidden;
}
	.outer .left {
		width: 100px;
		height: 100px;
		background-color: blue;
		float: left;
	}

	.outer .right {
		width: 100px;
		height: 100px;
		background-color: red;
		float: right;
	}</code></pre>

<p>效果图：</p>

<p><img src="/images/BFC/8.png" alt="触发BFC后outer被浮动元素撑开" /></p>

<p>在outer上触发BFC后可以看到，outer的高度变成了100px，被left和right两个浮动元素撑开了</p>

<h2 id="_3">参考文献</h2>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context">Block formatting context</a></p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/26/BFC</guid>
            </item>
        
            <item>
                <title><![CDATA[ 聊一聊优雅降级、渐进增强和移动先行 ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/25/design-strategies</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 25 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>前端开发，最重要的是让更多的人访问到我们的页面，并给他们优秀的用户体验。但在这美丽而残酷的世界，总有那么一些事情不尽如人意，浏览器之间差异便是其中一个。如今网页开发者和网页设计师们需要一个优秀的设计策略来引导跨浏览器、跨设备网页开发。这里就介绍了三种主流的设计策略。</p>

<h2 id="">浏览器兼容设计策略</h2>

<h3 id="_2">优雅降级(适度退化)</h3>

<p>一般情况下，我们总是希望自己的网页能在所有的浏览器中能正常工作，但事实总是那么的残酷（因为M记的IE）。一种比较常见的策略，名叫优雅降级(也叫适度退化)。也就是先使得网页能在所有的现代浏览器中正常工作（不一定是最新，一般是当前最新版本的上一个发行版本），然后通过代码来监测网页能否在用户使用的老式浏览器中正常工作。比如IE自身的盒子模型问题，开发者就会根据具体的IE版本实现来进行降级。也就是说，如果使用优雅降级的策略，我们需要实现整个网页的所有功能和效果，为无法支持所有功能的浏览器专门去制定一些候选方案，关注其中的核心功能，在老式浏览器上降低用户体验而保持核心功能能够正常工作。</p>

<h3 id="_3">渐进增强</h3>

<p>渐进增强的策略与优雅降级相反。首先从能被所有浏览器所支持的基本功能开始，逐步的去添加现代浏览器所支持的功能。用户体验中内容为王，在网页实现时最重要的就是将主要内容展现给用户。渐进增强就很符合这个理念。</p>

<p>要实现渐进增强，首先需要为所有设备准备好清晰的语义化HTML以及完善的内容，再通过无侵入的方式想页面中增加无害于基础浏览器的额外样式和功能。这样当浏览器更新换代时，就会不断提升用户体验</p>

<h3 id="_4">不要为了兼容舍弃新技术</h3>

<p>有很多人整日只关注老式浏览器上的表现情况，和他们一谈HTML5和CSS3，他们的态度是：“IE6（7）支持吗？不支持用（学）它干嘛”，我很鄙视这种想法。我们不应该仅仅为了照顾那些老古董（老式浏览器用户），而阻碍大批量现代浏览器用户享受CSS3和HTML5所带来的优秀视觉体验和交互设计。同时浏览器本身也会随着时间而变得更加强大，老式浏览器所占的份额也越来越小，没理由不去使用CSS3和HTML5。</p>

<h2 id="_5">响应式页面设计策略</h2>

<h3 id="_6">移动先行</h3>

<p>在响应式页面设计时我们需要考虑的几个问题：</p>

<ol>
<li>允许更多的人访问我们的网页（目前77%的人拥有收集，2011年出售的85%收集安装了浏览器）</li>

<li>让设计者关注核心的内容和功能（如果你失去了屏幕大小的80%你会怎么做？）</li>

<li>让设计者关注新技术，热爱创新（地理位置、触碰事件等等）</li>
</ol>

<p>响应式页面的核心内容：</p>

<ol>
<li>根据设备的屏幕大小流式布局</li>

<li>伸缩的图片和媒体保证在任何屏幕大小中完整显示</li>

<li>通过为媒体查询增加断点</li>
</ol>

<p>如今，随着移动互联网的发展，移动设备（智能手机、平板电脑等）所占有的比重越来越重，这也决定了视口大小的多种多样。同时随着传统数字设备（台式机、笔记本电脑、上网本）的发展，其视口大小也在不断扩大。这也导致了需要兼容的最大视口与最小视口的大小的差距逐渐增大。响应式web设计业应运而生。我们的目标就是（没有蛀牙！），让我们的页面兼容更多的设备。但是需要注意的是，将页面做成响应式页面只是权宜之计，最好的方法（预算够）是为移动端设备专门开发一个页面。这样可以为移动端设备做一些针对性的优化。 移动先行就是一种响应式页面设计策略，采用渐进增强的思想。最初只是为移动端的小视口设备（智能手机等）展现核心内容和功能，然后通过媒体查询为中视口设备（平板电脑等）添加更多的功能和视觉效果，再在大视口传统数字设备（台式机、笔记本电脑）上添加所有的内容和更加复杂的视觉效果，最后为了兼容超大视口（高分屏），可以适当加大原有内容的显示效果，并同时保持内容居中。</p>

<h3 id="_7">参考文献</h3>

<p><a href="http://fatesinger.com/764.html">渐进增强与优雅降级</a></p>

<p><a href="http://bradfrostweb.com/blog/web/mobile-first-responsive-web-design/">Mobile-First Responsive Web Design</a></p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/25/design-strategies</guid>
            </item>
        
            <item>
                <title><![CDATA[ CSS优先级备忘 ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/25/css-selectors-priority</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 25 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">常规优先级计算</h2>

<p>一个选择器的优先级是由如下方式计算的：</p>

<ul>
<li>通配符（<code>*</code>）的权重为0</li>

<li>元素选择器(<code>div</code>)、伪元素(<code>::before</code>)的权重为1</li>

<li>类型选择器(<code>.className</code>)、属性选择器(<code>[someAttr=someValue]</code>)、伪类选择器(<code>:hover</code>)的权重为10</li>

<li>id选择器（<code>#</code>）的权重为100</li>

<li>内联样式（HTML中的<code>style=&quot;blahblah&quot;</code>）为1000</li>

<li>如果权重一样，后声明的优先</li>
</ul>

<p>需要注意的是这里的10、100、1000并不是十进制的，进制数很大，在W3C上的原话： Concatenating the three numbers a-b-c (in a number system with a large base) gives the specificity.</p>

<p>确定伪元素有哪些：</p>

<ul>
<li>first-letter</li>

<li>first-line</li>

<li>before</li>

<li>after</li>
</ul>

<p>确伪类有哪些：</p>

<ul>
<li>active</li>

<li>focus</li>

<li>hover</li>

<li>link</li>

<li>visited</li>

<li>first-child</li>

<li>lang</li>
</ul>

<p>需要注意的是伪类和伪元素的差别，伪类的优先级要高于伪元素。伪元素一般使用<code>::first-letter</code>，前面两个冒号，而伪类只有一个。但目前已知处于相互混淆的状态。用一个也是可以的。同时很多人将<code>::before</code>和<code>::after</code>也一起称为伪类，更加混淆了伪类和伪元素。虽然平常使用的时候差别并不大，但在计算优先级权重的时候还是有差别的，需要注意。</p>

<h2 id="_2">特殊规则</h2>

<h3 id="important">!important永远覆盖其他</h3>

<p>当!important规则被用在一个样式声明中，这个样式声明会覆盖任何其他声明，无论在声明列表的那个位置，与优先级无关</p>

<p>如下例所示：</p>

<pre class="xml"><code class="xml">&lt;div class=&quot;outer&quot; style=&quot;color:red&quot;&gt;
    &lt;p&gt;这是outer中的一段文字&lt;/p&gt;
&lt;/div&gt;</code></pre>

<p>然后加上outer类的样式：</p>

<pre class="css21"><code class="css21">.outer {
    color: green !important;
}</code></pre>

<p>最终结果:</p>

<p><img src="/images/selector_priority/1.png" alt="结果" /></p>

<p>可见!important凌驾于一切之上</p>

<h3 id="not0">:not伪类的优先级为0</h3>

<p>需要注意的是伪类的优先级为0，比如如下例子：</p>

<pre class="xml"><code class="xml">&lt;div class=&quot;outer&quot;&gt;
    &lt;p&gt;这是outer中的文本，不属于inner&lt;/p&gt;
    &lt;div class=&quot;inner&quot;&gt;
        &lt;p&gt;这是inner中的文本&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>

<p>给其添加样式如下：</p>

<pre class="css21"><code class="css21">div:not(.outer) p {
    color: green;
}

div.outer p{
    color: red;
}</code></pre>

<p>结果如图：</p>

<p><img src="/images/selector_priority/2.png" alt="结果" /></p>

<p>可以看到，outer的color属性为red，很好理解</p>

<p>但inner的color也是red，可以检索一下元素发现：</p>

<p><img src="/images/selector_priority/3.png" alt="结果" /></p>

<p>两个样式都被用在了inner上了，但<code>div.outer p</code>被最终采用。说明<code>div:not(.outer) p</code>的优先级不会大于<code>div.outer p</code>。</p>

<p>接下来给两个样式换个顺序：</p>

<pre class="css21"><code class="css21">div.outer p{
    color: red;
}

div:not(.outer) p {
    color: green;
}</code></pre>

<p>F5看看输出效果，inner的color属性变成green了</p>

<p><img src="/images/selector_priority/4.png" alt="结果" /></p>

<p>由此可以看出<code>div.outer p</code>的优先级也不会大于<code>div:not(.outer) p</code>。这俩优先级一样，会按照最后声明的样式进行加载。这也充分证明了<code>:not</code>伪类是没有优先级的</p>

<h2 id="_3">参考文献</h2>

<p><a href="https://developer.mozilla.org/zh-CN/docs/CSS/Specificity">MDN的CSS优先级文章</a></p>

<p><a href="http://www.w3.org/TR/selectors/#specificity">CSS3 Selectors Specificity</a></p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/25/css-selectors-priority</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（CSS动画篇） ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/24/CSS3-animation-optimization</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 24 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>最近拜读了一下<a href="http://www.html5rocks.com/">html5rocks</a>上几位大神写的一篇关于CSS3动画性能优化的文章，学到了很多，在这里记录一下，其中的知识都是来源于这俩篇文章，我只是截取了其中比较关注的内容出来，原文地址<a href="http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">High Performance Animations</a>及<a href="http://www.html5rocks.com/zh/tutorials/speed/layers/">Accelerated Rendering in Chrome</a></p>

<h2 id="">原理</h2>

<p>现代浏览器在使用CSS3动画时，以下四种情形绘制的效率较高，分别是：</p>

<ul>
<li>改变位置</li>

<li>改变大小</li>

<li>旋转</li>

<li>改变透明度</li>
</ul>

<h3 id="_2">层？重绘？回流和重布局？图层重组？</h3>

<p>首先要了解CSS的图层的概念（Chrome浏览器）</p>

<p>浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。在渲染DOM的时候，浏览器所做的工作实际上是：</p>

<ol>
<li>获取DOM后分割为多个图层</li>

<li>对每个图层的节点计算样式结果（Recalculate style–样式重计算）</li>

<li>为每个节点生成图形和位置（Layout–回流和重布局）</li>

<li>将每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘）</li>

<li>图层作为纹理上传至GPU</li>

<li>符合多个图层到页面上生成最终屏幕图像（Composite Layers–图层重组）</li>
</ol>

<p>Chrome中满足以下任意情况就会创建图层：</p>

<ul>
<li>3D或透视变换（perspective transform）CSS属性</li>

<li>使用加速视频解码的<code>&lt;video&gt;</code>节点</li>

<li>拥有3D（WebGL）上下文或加速的2D上下文的<code>&lt;canvas&gt;</code>节点</li>

<li>混合插件（如Flash）</li>

<li>对自己的opacity做CSS动画或使用一个动画webkit变换的元素</li>

<li>拥有加速CSS过滤器的元素</li>

<li>元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）</li>

<li>元素有一个<code>z-index</code>较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）</li>
</ul>

<p>需要注意的是，如果图层中某个元素需要重绘，那么整个图层都需要重绘。比如一个图层包含很多节点，其中有个gif图，gif图的每一帧，都会重回整个图层的其他节点，然后生成最终的图层位图。所以这需要通过特殊的方式来强制gif图属于自己一个图层（<code>translateZ(0)</code>或者<code>translate3d(0,0,0)</code>），CSS3的动画也是一样（好在绝大部分情况浏览器自己会为CSS3动画的节点创建图层）</p>

<h3 id="css">层和CSS动画</h3>

<p>简化一下上述过程，每一帧动画浏览器可能需要做如下工作：</p>

<ol>
<li>计算需要被加载到节点上的样式结果（Recalculate style–样式重计算）</li>

<li>为每个节点生成图形和位置（Layout–回流和重布局）</li>

<li>将每个节点填充到图层中（Paint Setup和Paint–重绘）</li>

<li>组合图层到页面上（Composite Layers–图层重组）</li>
</ol>

<p>如果我们需要使得动画的性能提高，需要做的就是减少浏览器在动画运行时所需要做的工作。最好的情况是，改变的属性仅仅印象图层的组合，变换（<code>transform</code>）和透明度（<code>opacity</code>）就属于这种情况</p>

<p>现代浏览器如Chrome，Firefox，Safari和Opera都对变换和透明度采用硬件加速，但IE10+不是很确定是否硬件加速</p>

<h2 id="_3">触发重布局的属性</h2>

<p>有些节点，当你改变他时，会需要重新布局（这也意味着需要重新计算其他被影响的节点的位置和大小）。这种情况下，被影响的DOM树越大（可见节点），重绘所需要的时间就会越长，而渲染一帧动画的时间也相应变长。所以需要尽力避免这些属性</p>

<p>一些常用的改变时会触发重布局的属性： 盒子模型相关属性会触发重布局：</p>

<ul>
<li>width</li>

<li>height</li>

<li>padding</li>

<li>margin</li>

<li>display</li>

<li>border-width</li>

<li>border</li>

<li>min-height</li>
</ul>

<p>定位属性及浮动也会触发重布局：</p>

<ul>
<li>top</li>

<li>bottom</li>

<li>left</li>

<li>right</li>

<li>position</li>

<li>float</li>

<li>clear</li>
</ul>

<p>改变节点内部文字结构也会触发重布局：</p>

<ul>
<li>text-align</li>

<li>overflow-y</li>

<li>font-weight</li>

<li>overflow</li>

<li>font-family</li>

<li>line-height</li>

<li>vertival-align</li>

<li>white-space</li>

<li>font-size</li>
</ul>

<p>这么多常用属性都会触发重布局，可以看到，他们的特点就是可能修改整个节点的大小或位置，所以会触发重布局</p>

<h3 id="css_2">别使用CSS类名做状态标记</h3>

<p>如果在网页中使用CSS的类来对节点做状态标记，当这些节点的状态标记类修改时，将会触发节点的重绘和重布局。所以在节点上使用CSS类来做状态比较是代价很昂贵的</p>

<h2 id="_4">触发重绘的属性</h2>

<p>修改时只触发重绘的属性有：</p>

<ul>
<li>color</li>

<li>border-style</li>

<li>border-radius</li>

<li>visibility</li>

<li>text-decoration</li>

<li>background</li>

<li>background-image</li>

<li>background-position</li>

<li>background-repeat</li>

<li>background-size</li>

<li>outline-color</li>

<li>outline</li>

<li>outline-style</li>

<li>outline-width</li>

<li>box-shadow</li>
</ul>

<p>这样可以看到，这些属性都不会修改节点的大小和位置，自然不会触发重布局，但是节点内部的渲染效果进行了改变，所以只需要重绘就可以了</p>

<h3 id="_5">手机就算重绘也很慢</h3>

<p>在重绘时，这些节点会被加载到GPU中进行重绘，这对移动设备如手机的影响还是很大的。因为CPU不如台式机或笔记本电脑，所以绘画巫妖的时间更长。而且CPU与GPU之间的有较大的带宽限制，所以纹理的上传需要一定时间</p>

<h2 id="_6">触发图层重组的属性</h2>

<h3 id="_7">透明度竟然不会触发重绘？</h3>

<p>需要注意的是，上面那些触发重绘的属性里面没有<code>opacity</code>（透明度），很奇怪不是吗？实际上透明度的改变后，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。不过这个前提是这个被修改<code>opacity</code>本身必须是一个图层，如果图层下还有其他节点，GPU也会将他们透明化</p>

<h3 id="_8">强迫浏览器创建图层</h3>

<p>在Blink和WebKit的浏览器中，一当一个节点被设定了透明度的相关过渡效果或动画时，浏览器会将其作为一个单独的图层，但很多开发者使用<code>translateZ(0)</code>或者<code>translate3d(0,0,0)</code>去使浏览器创建图层。这种方式可以消除在动画开始之前的图层创建时间，使得动画尽快开始（创建图层和绘制图层还是比较慢的），而且不会随着抗锯齿而导出突变。不过这种方法需要节制，否则会因为创建过多的图层导致崩溃</p>

<h3 id="chrome">Chrome中的抗锯齿</h3>

<p>Chrome中，非根图层以及透明图层使用grayscale antialiasing而不是subpixel antialiasing，如果抗锯齿方法变化，这个效果将会非常显著。如果你打算预处理一个节点而不打算等到动画开始，可以通过这种强迫浏览器创建图层的方式进行</p>

<h3 id="transform">transform变换是你的选择</h3>

<p>我们通过节点的<code>transform</code>可以修改节点的位置、旋转、大小等。我们平常会使用<code>left</code>和<code>top</code>属性来修改节点的位置，但正如上面所述，<code>left</code>和<code>top</code>会触发重布局，修改时的代价相当大。取而代之的更好方法是使用<code>translate</code>，这个不会触发重布局</p>

<h2 id="jscss3">JS动画和CSS3动画的比较</h2>

<p>我们经常面临一个抉择：是使用JavaScript的动画还是使用CSS的动画，下面将对比一下这两种方式</p>

<h3 id="js">JS动画</h3>

<p>缺点：JavaScript在浏览器的主线程中运行，而其中还有很多其他需要运行的JavaScript、样式计算、布局、绘制等对其干扰。这也就导致了线程可能出现阻塞，从而造成丢帧的情况。</p>

<p>优点：JavaScript的动画与CSS预先定义好的动画不同，可以在其动画过程中对其进行控制：开始、暂停、回放、中止、取消都是可以做到的。而且一些动画效果，比如视差滚动效果，只有JavaScript能够完成</p>

<h3 id="css_3">CSS动画</h3>

<p>缺点：缺乏强大的控制能力。而且很难以有意义的方式结合到一起，使得动画变得复杂且易于出问题。 优点：浏览器可以对动画进行优化。它必要时可以创建图层，然后在主线程之外运行。</p>

<h2 id="_9">前瞻</h2>

<p>Google目前正在探究通过JS的多线程（Web Workers）来提供更好的动画效果，而不会触发重布局及样式重计算</p>

<h2 id="_10">结论</h2>

<p>动画给予了页面丰富的视觉体验。我们应该尽力避免使用会触发重布局和重绘的属性，以免失帧。最好提前申明动画，这样能让浏览器提前对动画进行优化。由于GPU的参与，现在用来做动画的最好属性是如下几个：</p>

<ul>
<li>opacity</li>

<li>translate</li>

<li>rotate</li>

<li>scale</li>
</ul>

<p>也许会有一些新的方式使得可以使用JavaScript做出更好的没有限制的动画，而且不用担心主线程的阻塞问题。但在那之前，还是好好考虑下如何做出流畅的动画吧</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/24/CSS3-animation-optimization</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（Application Cache篇） ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/20/application-cache</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 20 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>之前在segmentfault上刷问题看到一个关于manifest的问题，很好奇就研究了一下application cache。Application Cache是HTML5的新特性，允许浏览器在本地存储页面所需要的资源，使得页面离线也可以访问。之前研究的目的是为了在博客中使用，将一些不需要改动的CSS、JavaScript、图片文件离线缓存，这样加载速度必然飞起，希望能用在博客上，但是失败了，但还是记录一下学到的知识</p>

<h2 id="application_cache">Application Cache的配置文件</h2>

<p>首先需要在服务器上建立一个文件，里面的内容确定了哪些文件需要缓存，哪些文件不需要，如果资源无法访问会使用什么页面等</p>

<p>这个文件一般为<code>.appcache</code>类型，称为<strong>缓存清单(cache manifest)文件</strong>，一个完整的缓存清单文件如下：</p>

<pre><code>CACHE MANIFEST
# version xx.xx.xx
CACHE:
needBeCached.png
needBeCached2.js

NETWORK:
notNeedBeCached.html
notNeedBeCached2.css

FALLBACK:
/ 404.html</code></pre>

<p>可以看到，文件的头部信息<code>CACHE MANIFEST</code>用来标注这个文件是缓存清单文件，其后一般情况下（最好是）跟着一行标明版本的注释，这行注释非常重要，将在后面文件加载部分详细介绍这行注释的重要性</p>

<h3 id="cache">CACHE部分</h3>

<p>除了头部信息，这个缓存清单文件分为几部分，第一部分为CACHE部分:</p>

<pre><code>CACHE:
needBeCached.png
needBeCached2.js</code></pre>

<p>这一部分标注了哪些资源文件需要被缓存可以列出多个</p>

<p>如果有路径，如需要缓存blog下的blog.css文件，可以写成<code>blog/blog.css</code>。</p>

<p>另外<code>CACHE:</code>可以被省略，让需要缓存的资源文件直接跟在注释之后</p>

<h3 id="network">NETWORK部分</h3>

<p>第二部分为NETWORK部分：</p>

<pre><code>NETWORK:
notNeedBeCached.html
notNeedBeCached2.css</code></pre>

<p>这一部分定义了哪些文件不需要缓存，这些文件需要与服务器连接</p>

<p>与CACHE一样，可以定义多个资源，而如果直接输入一个文件夹路径，也是合法的，比如<code>/blog</code>这样，blog文件夹下的所有文件都不会被缓存</p>

<p>可以使用通配符来，如除了上面CACHE中定义的资源，其他都必须与服务器连接：</p>

<pre><code>NETWORK:
*</code></pre>

<p>需要注意一点是，载有这个manifest文件的HTML文档将一定会缓存，这个会在后面再次提到</p>

<h3 id="fallback">FALLBACK部分</h3>

<p>第三部分为FALLBACK部分：</p>

<pre><code>FALLBACK:
/ 404.html</code></pre>

<p>这一部分指定了一个后备页面，当资源无法访问时，浏览器会使用该页面</p>

<p>同样可以定义多条记录，每条记录列出两个URI，一个表示资源，一个表示后备页面。需要注意的是两个资源文件都需要使用相对路径切与manifest文件同源</p>

<p>同样可以使用通配符</p>

<h3 id="manifest">保存和引用manifest文件</h3>

<p>manifest文件可以保存在服务器上，保存为<code>.appcache</code>后缀，但必须与应用本身同源。在HTML文档中，可以指定清单文件的相对路径和绝对URL。需要注意的是，manifest文件的MIME类型必须是<code>text/cache-manifest</code></p>

<p>需要在HTML文档中引入manifest文件，可以使用类似如下代码：</p>

<pre class="xml"><code class="xml">&lt;!doctype html&gt;
&lt;html manifest=&quot;manifest.appcache&quot;&gt;
...
&lt;/html&gt;</code></pre>

<p>这样，HTML文档加载后，就会根据manifest.appcache的内容来缓存资源文件，在下次访问相同页面的时候，会直接使用缓存的资源文件来进行加速</p>

<h2 id="">缓存和加载机制</h2>

<p>在第一次访问时，浏览器加载完HTML文档后，会查看其是否有引入manifest文件。若引入，则加载manifest文件，然后根据manifest的文件内容进行资源的缓存，并缓存当前文档</p>

<p>之后访问，浏览器首先会查看manifest文件是否被修改（无论是内容还是注释），如果被修改，将当做第一次访问，重新根据manifest文件内容进行缓存</p>

<p>如果应用缓存存在，且manifest没有被修改，浏览器直接从缓存中加载文档（注意：加载文档）和资源，不会访问网络（注意：无论联网与否，都不会访问网络）</p>

<p>在缓存多个资源文件时，浏览器下载资源文件会先放在一个临时的缓存中，如果有任何一个资源文件下载失败，浏览器将停止其他缓存资源的下载，并清除临时缓存。如果所有资源文件都被成功下载，浏览器将会把这些资源文件以及引用manifest文件的HTML文档移动到永久离线缓存中</p>

<h2 id="_2">满满的都是坑</h2>

<h3 id="_3">一些小坑</h3>

<ol>
<li>需要注意的是manifest文件放在服务器上，MIME类型必须是<code>text/cache-manifest</code>，如果使用 Apache，需要修改.htaccess文件。IE下默认application/octet-stream，需要在服务器指定</li>

<li>每个需要缓存的页面的html都需要加入manifest属性</li>

<li>不要将manifest文件本身加入缓存，如果加入，浏览器将不会检测到服务器上manifest的更新，页面版本将万年不变</li>

<li>不要以为一个资源文件加载失败，其他文件就会被缓存，原因参见缓存和加载机制的最后一段</li>
</ol>

<h3 id="_4">一些大坑</h3>

<ol>
<li>在manifest文件中定义的资源全部被成功加载后，这些资源文件连同<strong>引用manifest文件的HTML文档</strong>一并被移动到永久离线缓存中。所以如果想只缓存js、css、图片等文件，而不希望缓存HTML文档以保持获得最新内容的情况来说，这就是个大坑</li>

<li>根据Application Cache的加载机制，如果仅仅修改资源文件的内容（没有修改资源文件的路径或名称），浏览器将直接从本地离线缓存中获取资源文件。所以在每次修改资源文件的同时，需要修改manifest文件，以触发资源文件的重新加载和缓存。这其中，最有效的方式是修改manifest文件内部的版本注释（所以说那句注释相当重要）</li>

<li>如果资源没有被缓存，在而没有设置NETWORK的情况下，将会无法加载（浏览器不会去网络上进行加载），所以需要使用通配符来表明除了CACHE中确定的资源以外，其他资源都需要去网络上加载</li>
</ol>

<h3 id="iframe">使用iframe来避开一号坑？</h3>

<p>网上传言避开一号坑的方法是使用iframe来指定需要缓存的资源，而避开HTML文档的缓存。具体做法是在HTML中嵌入一个iframe，iframe中的页面的HTML标签包含manifest属性引用manifest文件，里面定义了需要缓存的文件。这样就会只缓存iframe中的HTML文档，而持续更新主页面：</p>

<pre class="xml"><code class="xml">&lt;!doctype html&gt;
&lt;html lang=&quot;zh&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;主页面&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;
    &lt;script src=&quot;js/javascript.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;iframe src=&quot;cache.html&quot;&gt;&lt;/iframe&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>可以看到，主页面的html标签中，并没有引入manifest文件。只是在其中加载了一个iframe，而这个iframe所加载的页面文档如下：</p>

<pre class="xml"><code class="xml">&lt;!DOCTYPE html&gt;
&lt;html manifest=&quot;manifest.appcache&quot;&gt;
&lt;head&gt;
    &lt;meta charset=utf-8 /&gt;
    &lt;title&gt;缓存页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>缓存页面中引入了manifest文件，这样浏览器就会缓存manifest文件中定义的资源列表，比如这里manifest文件的内容如下：</p>

<pre><code>CACHE MANIFEST
# VERSION 1.0

CACHE:
css/someStyle.css
js/someJavaScript.js

NETWORK:
*</code></pre>

<p>在chrome中运行，可以在命令行中看到如下效果：</p>

<pre><code>Creating Application Cache with manifest http://localhost:8000/manifest.appcache
Application Cache Checking event
Application Cache Downloading event
Application Cache Progress event (0 of 2) http://localhost:8000/css/someStyle.css
Application Cache Progress event (1 of 2) http://localhost:8000/js/someJavaScript.js
Application Cache Progress event (2 of 2)
Application Cache Cached event </code></pre>

<p>浏览器缓存了manifest文件中定义的资源文件，其实同时还缓存了iframe中的缓存页面的文档，但不会缓存主页面，修改一下主页面，并按F5刷新</p>

<pre><code>Document was loaded from Application Cache with manifest http://localhost:8000/manifest.appcache
Application Cache Checking event
Application Cache NoUpdate event </code></pre>

<p>可以看到主页面被更新了，但是someStyle.css和someJavaScript.js文件依旧从网络上加载了，而没有从cache中加载。打开chrome的<code>chrome://appcache-internals/</code>可以看到，里面cache.html、someStyle.css、someJavaScript.js确实被缓存了，去掉NETWORK段，结果也是一样</p>

<pre><code>Flags       URL                                         Size (headers and data)
Master,     http://localhost:8000/cache.html            388 B
Explicit,   http://localhost:8000/css/someStyle.css     228 B
Explicit,   http://localhost:8000/js/someJavaScript.js  244 B
Manifest,   http://localhost:8000/manifest.appcache     316 B</code></pre>

<p>在firefox、opera上测试也是一样，虽然被缓存了，但依旧会从网络上加载，而iframe的解答方法也是2011~2012年左右提出的，后来就没有相关文章了，估计已经彻底失效了</p>

<h2 id="_5">总结</h2>

<p>Application主要是为了构建离线缓存，使得页面在离线模式下也能浏览。这比较适合一些页面上的应用以及静态的不经常变更的页面。其会缓存载体页面也是由于其机制。如果上面iframe机制实现有错误，或是有其他方法只缓存资源不缓存HTML文档，请联系我</p>

<h2 id="_6">参考资料</h2>

<p><a href="https://developer.mozilla.org/zh-CN/docs/HTML/Using_the_application_cache">使用应用缓存</a></p>

<p><a href="http://zoomzhao.com/2012/11/08/application-cache-is-a-douchebag/">Application Cache 就是个坑</a></p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/20/application-cache</guid>
            </item>
        
            <item>
                <title><![CDATA[ PL/SQL编写存储函数 ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/19/plsql-and-storage-function</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 19 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="plsql">PL/SQL安装</h2>
<hr />
<p><a href="http://pan.baidu.com/s/1ntwisrB">PL/SQL和Oracle920整合的压缩包</a> 提取码：cgsf</p>

<p>下载后由”PL_SQL_DEV_9 + Oracle920.rar”解压并安装</p>

<h3 id="oracle920">安装Oracle920</h3>

<ol>
<li>解压压缩包，建议将Oracle920文件夹放在D盘根目录下，否则需要修改其注册表文件中的路径</li>

<li>运行注册表文件oracle.reg</li>

<li>在环境变量中添加bin文件夹路径，如放在D盘根目录下，则添加D:\oracle920\bin</li>
</ol>

<h3 id="plsql_2">安装pl/sql</h3>

<ol>
<li>解压压缩包</li>

<li>运行plsqldev906.exe安装</li>

<li>运行chinese.exe添加中文补丁</li>
</ol>

<h3 id="">注意事项</h3>

<ol>
<li>若Oracle920路径不放在D盘根目录下，运行注册表文件oracle.reg文件前，用文本编辑工具打开，将所有涉及路径的地方修改成Oracle920文件夹的路径</li>

<li>请在32位机上安装，64位自行百度解决方法</li>
</ol>

<h3 id="plsql_3">修改pl/sql登录时的服务器可选项</h3>

<p>由于无锡、绥化的Oracle服务器IP地址出现变更，需要修改服务器地址</p>

<p>存放地址的文件为(Oracle920所在文件夹)/Oracle920/network/ADMIN/tnsnames.ora，使用文本编辑工具打开</p>

<p>可以看到其中有类似代码：</p>

<pre><code>hiservice_197 =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.197)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SID = hiservic)
    )
  )</code></pre>

<p>其中<code>hiservice_197</code>即为PL/SQl选择服务器的服务器名。<code>HOST = 192.168.0.197</code>定义了IP地址，<code>PORT = 1521</code>定义了端口，<code>SID = hiservic</code>定义了连接的数据库，可以根据需要进行修改，或者按照同样的规则在文档最后进行添加</p>

<h2 id="plsql_4">PL/SQL使用</h2>

<h3 id="crud">一般CRUD操作</h3>

<p>很简单，在菜单 文件-&gt;新建-&gt;SQL窗口 来创建新的SQL窗口，在窗口中敲入SQL语句，按F8执行</p>

<p>若要通过图形界面进行新增、修改、删除，请在SQL语句后增加<code>for update</code>代码，比如原语句为<code>select * from user_info</code>，则修改为<code>select * from user_info for update</code>。</p>

<p>在执行前，点击SQL框下的“小锁”开启增加、删除、修改权限，使用“小锁”旁边的“加号”和“减号”来新增删除数据，修改直接单击需要修改的数据格即可。</p>

<p>修改完成后点击一下旁边的“绿勾”确认，然后点击左上角主菜单下的“提交按钮”或按F10进行提交，否则事务不会提交，修改不会生效</p>

<h3 id="_2">存储过程相关</h3>

<p>在有友好插件的文本编辑工具中写完存储过程后，若要全部执行，可以直接复制到同上的SQL框</p>

<p>如需一个一个定义执行，可以在菜单 文件-&gt;新建-&gt;命令窗口 来创建命令行，然后通过复制代码的方式写入存储过程的结构和函数，最后一行加<code>/</code>来标志结束。在命令行中需要检测是否含有某结构或函数，可以使用<code>desc</code>进行查看，如检测某Object结构或Table结构是否存在，可以使用（xxxx为结构名）：</p>

<pre class="sql"><code class="sql">desc type xxxx</code></pre>

<p>若要检测函数或表信息，则（xxxx为函数名或表名）：</p>

<pre class="sql"><code class="sql">desc xxxx</code></pre>

<p>若需要检查编译错误，在菜单 文件-&gt;新建-&gt;程序窗口 来进行调试，比如存储函数，可以新建Function窗口，模板向导若已有代码，可以不必填写，点击确定后直接用已有代码进行覆盖即可。使用F8来编译，若编译错误，底下会显示编译错误的原因及产生错误的行数</p>

<p>若存储过程中有输出语句如<code>DBMS_OUTPUT.PUTLINE(xxxx)</code>则在SQL窗口中运行，运行完成后点击输出标签页查看输出</p>

<h2 id="_3">一些存储函数实例</h2>

<h3 id="_4">定义元数据结构</h3>

<p>一般使用存储函数都是为了将现有的数据库表中的不规则的数据整理，生成iReport比较容易生成报表的结构。所以首先需要定义报表中需要的每一条数据的样式：</p>

<pre class="sql"><code class="sql">CREATE OR REPLACE TYPE objectName AS OBJECT (
    property_name_1 varchar2(255),
    property_name_2 number
);</code></pre>

<p>其中<code>objectName</code>为结构名，<code>property_name_x</code>为属性名</p>

<p>这样就定义了一个简单的有一个字符串属性，一个数字属性的元数据结构。</p>

<h3 id="_5">定义临时表结构</h3>

<p>由于一般情况下都需要存储函数输出一整张每行都是这个结构的表，所以需要定义通过这个元数据结构组织成的表结构：</p>

<pre class="sql"><code class="sql">create or replace type tableName table of objectName;</code></pre>

<p>其中<code>tableName</code>为表结构的名称，<code>objectName</code>为这个表结构所使用元数据结构的名称</p>

<h3 id="_6">定义存储函数</h3>

<p>定义存储函数：</p>

<pre class="sql"><code class="sql">create or replace function functionName(param1 number, param2 number)
return tableName pipelined
as
v_row objectName;
--变量定义
begin
--函数体
return;
end;</code></pre>

<p>其中<code>functionName</code>为存储函数的名称，<code>tableName</code>为存储函数返回表结构的名称，<code>objectName</code>为表结构使用的元数据结构的名称</p>

<p>需要注意变量定义部分，所有后面使用到的变量都需要在这里先行定义</p>

<p>这个函数中定义了两个参数<code>param1</code>和<code>param2</code>，若不需要使用参数，则第一行直接改为<code>create or replace function functionName</code>，函数名后不需要添加括号</p>

<h3 id="_7">遍历数据库中表获取数据</h3>

<p>在函数体中通过<code>for in</code>遍历已有的表：</p>

<pre><code>for itemName in (
    --sql语句
) loop
    --对表每一行数据进行操作
end loop;</code></pre>

<p>这里sql语句和平常的sql语句没有太大区别，唯一的区别是可以使用变量作为<code>where</code>中的判断条件的参数，如有两个number型变量startTime，endTime，可以直接使用语句<code>where fieldName &lt; endTime and fieldName &gt;= startTime</code></p>

<h3 id="_8">将单个结果输出到变量</h3>

<p>有的时候只需要一个统计结果，通过sql的聚集函数来实现，若需要将其结果存入变量中，可以使用<code>into</code>来实现：</p>

<pre class="sql"><code class="sql">select count(someUtTableName.id) into v_number_type_var
from someUtTableName
where balabala</code></pre>

<p>这样就将count的结果存入到名叫<code>v_number_type_var</code>的变量之中了，这个变量需要在前面先行定义</p>

<h3 id="_9">将数据组织成表</h3>

<p>若需要将数据组织成结构，添加到返回表中：</p>

<pre class="sql"><code class="sql">v_row := objectName(&#39;abc&#39;, 123);
pip row(v_row);</code></pre>

<p>其中<code>objectName</code>为元数据结构，<code>v_row</code>为元数据结构的变量，这样就相当于往结果的表里增加了一行。括号里面可以使用变量，但类型必须与元数据结构定义严格一致。</p>

<h3 id="_10">在函数中增加调试用的输出</h3>

<p>在函数体中加入如下代码:</p>

<pre class="sql"><code class="sql">DBMS_OUTPUT.PUTLINE(&#39;test information&#39;);</code></pre>

<p>即可在运行的时候产生输出，括号内可以使用变量。在SQL框的输出标签页查看输出结果</p>

<h3 id="_11">注释</h3>

<p>使用<code>--注释内容</code>来添加单行注释</p>

<p>使用<code>/*注释内容*/</code>来添加多行注释</p>

<h3 id="_12">调用存储函数</h3>

<p>已经写好的存储函数需要在sql中进行调用，在写入iReport之前可以先在pl/sql中测试一下，比如已有存储函数functionName，接受两个number参数，则：</p>

<pre class="sql"><code class="sql">select * from table(functionName(123, 456))</code></pre>

<p>若无参数，直接<code>from table(functionName())</code>即可。将其当做一张表来看，可以使用<code>group by</code>、<code>order by</code>、<code>where</code>等。select也可以选择需要的字段或改名</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/19/plsql-and-storage-function</guid>
            </item>
        
            <item>
                <title><![CDATA[ 聊聊响应式网页设计中的HTML5 ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/15/responsive-html5</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 15 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>系列文章：</p>

<p><a href="http://skyinlayer.com/blog/2014/02/14/responsive-web-design/">《聊聊响应式网页设计》</a></p>

<p>继上一篇《聊聊响应式网页设计》。这一篇记录了响应式网页设计中的HTML5部分。</p>

<h3 id="html5">HTML5带来了什么？</h3>

<h3 id="html5_2">何为HTML5？</h3>

<p>何为HTML5？wiki上的定义：HTML5是HTML下一个主要的修订版本，现在仍处于发展阶段。目标是取代1999年所制定的HTML 4.01和XHTML 1.0标准，以期能在互联网应用迅速发展的时候，使网络标准达到符合当代的网络需求。</p>

<h3 id="">多了些啥？</h3>

<p>相比较HTML4.01而言，其新增了很多有实质价值的东西。具体来说，HTML5添加了许多新的语法特征，其中包括<code>&lt;video&gt;</code>, <code>&lt;audio&gt;</code>,和<code>&lt;canvas&gt;</code>元素，同时集成了SVG内容。这些元素是为了更容易的在网页中添加和处理多媒体和图片内容而添加的。其它新的元素包括<code>&lt;section&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;header&gt;</code>, 和<code>&lt;nav&gt;</code>,是为了丰富文档的数据内容。新的属性的添加也是为了同样的目的。同时也有一些属性和元素被移除掉了。一些元素，像<code>&lt;a&gt;</code>, 和<code>&lt;menu&gt;</code>被修改，重新定义或标准化了。同时APIs和DOM已经成为HTML5中的基础部分了。HTML5还定义了处理非法文档的具体细节，使得所有浏览器和客户端程序能够一致地处理语法错误。</p>

<h3 id="html5_3">为什么现在开始HTML5？</h3>

<p>几乎所有现代浏览器都能正确理解常见的HTML5属性，其提供的新的结构元素、视频、音频标签对于老版本的IE可以使用腻子脚本（一段能给老版本浏览器带来新特性的JavaScript代码，如<a href="http://modernizr.com/">Modernizr</a>）来弥补。</p>

<h2 id="html5_4">如何编写HTML5页面？</h2>

<h3 id="html5_5">使用HTML5文档类型声明</h3>

<p>如果你使用了Emmet（原名zencoding），在页面中敲入<code>html:5</code>代码，按下CTRL+E，就会自动扩展成如下代码：</p>

<pre class="xml"><code class="xml">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    
&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>可以看到第一行的文档声明很简洁，没错，这就是HTML5的文档声明。</p>

<p>还记得其他的文档声明吗？</p>

<pre class="xml"><code class="xml">&lt;!-- HTML4.01文档过渡定义类型，此类型定义的文档可以使用HTML中的标签与元素包括一些不被W3C推荐的标签（例如：font、b等），不可以使用框架 --&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;!-- HTML4.01文档严格定义类型，此类型定义的文档可以使用HTML中的标签与元素，不能包含不被W3C推荐的标签（例如：font、b等），不可以使用框架 --&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
&lt;!-- XHTML1.0文档过渡定义类型，此类型定义的文档可以使用HTML中的标签与元素包括一些不被W3C推荐的标签（例如：font、b等），不可以使用框架 --&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;!-- XHTML1.0文档严格定义类型，此类型定义的文档只可以使用HTML中定义的标签与元素，不能包含不被W3C推荐的标签（例如：font、b）(梦之都就使用了此类型)，不可以使用框架 --&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
&lt;!-- XHTML1.0文档框架定义类型，等同于XHTML1.0文档过渡定义类型，但可以使用框架 --&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;
&lt;!-- XHTML1.1文档严格定义类型，等同于XHTML1.0文档过渡定义类型 --&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;</code></pre>

<p>我勒个凑，为什么HTML5的文档声明如此简短？因为HTML5是以简洁的方式高速浏览器用“标准模式”渲染页面。这种思想贯穿HTML5始终。</p>

<h2 id="html5_6">细谈HTML5带来的改变</h2>

<h3 id="_2">大小写？无所谓~</h3>

<p>下面这两句代码实际上是一样的效果：</p>

<pre class="xml"><code class="xml">&lt;img src=&quot;someImage.png&quot; alt=&quot;someImage&quot;&gt;
&lt;img SRC=&quot;someImage.png&quot; aLt=&quot;someImage&quot;&gt;</code></pre>

<h3 id="_3">引号？无所谓~</h3>

<p>下面这两句也是一样的：</p>

<pre class="xml"><code class="xml">&lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;
&lt;div id=wrapper&gt;&lt;/div&gt;</code></pre>

<h3 id="xml">闭合？那是XML才干的事~</h3>

<p>下面这两句也是一样的：</p>

<pre class="xml"><code class="xml">&lt;img src=&quot;someImage.png&quot; alt=&quot;someImage&quot;&gt;
&lt;img src=&quot;someImage.png&quot; alt=&quot;someImage&quot;/&gt;</code></pre>

<h3 id="type">省略type，敲码更轻松</h3>

<p>link标签和script的标签，经常被使用，而主要是CSS文件和JavaScript文件，何不将其作为默认？下面其实也是一样的</p>

<pre class="xml"><code class="xml">&lt;link href=&quot;CSS/main.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;
&lt;link href=CSS/main.css rel=stylesheet&gt;

&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script&gt;&lt;/script&gt;</code></pre>

<h3 id="a">a标签能嵌套多个标签了</h3>

<p>如今，<code>&lt;a&gt;</code>标签之中可以嵌套一组元素了。不过需要注意的是，<code>&lt;a&gt;</code>标签不能嵌套<code>&lt;a&gt;</code>标签，也不能在<code>&lt;a&gt;</code>标签中嵌套表单</p>

<h3 id="_4">增加了很多语义化元素</h3>

<p>HTML5中新增了很多语义化元素，使得HTML也能真正表达页面本质了，这个将在下面详细介绍</p>

<h2 id="_5">新来的语义化元素们</h2>

<h3 id="section">section</h3>

<p>元素<code>&lt;section&gt;</code>用来定义文档或应用程序中的区域（或节）。它的主要功能是为了区分内容区域，如果只是想包裹起来便于设置样式的话，还是用<code>&lt;div&gt;</code>吧。HTML5允许每个<code>&lt;section&gt;</code>容器有自己独立的大钢结构</p>

<p>比如这个博客中的侧边栏就有类似如下代码：</p>

<pre class="xml"><code class="xml">&lt;section&gt;
    &lt;header&gt;
        &lt;h2&gt;最近的文章&lt;/h2&gt;
    &lt;/header&gt;
    &lt;ul&gt;&lt;/ul&gt;
&lt;/section&gt;
&lt;section&gt;
    &lt;header&gt;
        &lt;h2&gt;文章类别&lt;/h2&gt;
    &lt;/header&gt;
    &lt;ul&gt;&lt;/ul&gt;
&lt;/section&gt;
&lt;section&gt;
    &lt;header&gt;
        &lt;h2&gt;文章标签&lt;/h2&gt;
    &lt;/header&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/section&gt;</code></pre>

<p>其中使用section将最近文章、文章类别、文章标签的区域区分开来</p>

<h3 id="nav">nav</h3>

<p>元素<code>&lt;nav&gt;</code>用来定义文档的主导航区域，其中的连接指向其他页面或是当前页面的其他区域。其中经常包含一组链接</p>

<p>比如在这个博客中，左侧的导航栏中有如下代码：</p>

<pre class="xml"><code class="xml">&lt;nav&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;/index.html&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;/archieves.html&quot;&gt;所有文章&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;/items.html&quot;&gt;小玩意儿&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;/about.html&quot;&gt;关于我&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/nav&gt;</code></pre>

<p>用来包含最核心的导航链接</p>

<h3 id="article">article</h3>

<p>元素<code>&lt;article&gt;</code>用来包裹独立的内容片断。和<code>&lt;section&gt;</code>很相似。《响应式Web设计》书上对他们俩的区分是真么说的：</p>

<p><em>当搭建一个页面是，想想你准备放入<code>&lt;article&gt;</code>标签的内容能否作为一个整块而被复制黏贴到另外一个完全不同的网站且能保持完整的意义？另一种办法是，想想包裹在<code>&lt;article&gt;</code>中的内容能否在RSS订阅源中独立成一篇文章？应该使用<code>&lt;article&gt;</code>标签包裹的内容，最明显的例子就是博客正文</em></p>

<h3 id="aside">aside</h3>

<p>元素<code>&lt;aside&gt;</code>用来表示与页面主内容松散相关的内容，实践中，一般用来做侧边栏，另外像引文、广告以及导航元素（友情链接）也可以使用</p>

<h3 id="hgroup">hgroup</h3>

<p>如果有页面有一组<code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>标签时，可以考虑使用<code>hgroup</code>将他们包裹，这样HTML5大纲的算法就会只提取第一个标题元素进入文档大纲</p>

<h3 id="header">header</h3>

<p>元素<code>&lt;header&gt;</code>不会被计入大纲，所以不能用其来划分内容结构，应该使用它来包含对区域内容的介绍说明。<code>&lt;header&gt;</code>可以用作网站头部的“刊头”区域，也可以用作对其他内容如<code>&lt;article&gt;</code>元素的简要介绍</p>

<h3 id="footer">footer</h3>

<p>元素<code>&lt;footer&gt;</code>与<code>&lt;header&gt;</code>一样,不会计入大钢结构,所以不能用于划分内容结构,但它可以用来包含一些其所在区域的辅助信息,比如一些超链接和版权信息啥的</p>

<h3 id="address">address</h3>

<p>元素<code>&lt;address&gt;</code>用于标注其最近的<code>&lt;article&gt;</code>或<code>&lt;body&gt;</code>祖先元素的联系信息</p>

<h2 id="_6">为你的网页生成大纲吧</h2>

<p>书中介绍了两个将html转换成大纲的网站: <a href="http://gsnedders.html5.org/outliner/">HTML5 Outliner by gsnedders</a>和<a href="http://hoyois.github.io/html5outliner/">HTML5 Outliner by hoyois</a>，其中第二个需要用firefox打开</p>

<p>两者都支持直接输入URL、上传HTML文件、直接敲入HTML内容来生成大纲</p>

<p>比如下面这一段HTML，一个很常见的HTML文档：</p>

<pre class="xml"><code class="xml">&lt;!doctype html&gt;
&lt;html lang=&quot;zh&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;标题&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;整个文章的主题&lt;/h1&gt;
    &lt;header&gt;
        &lt;nav&gt;
            &lt;hgroup&gt;
                &lt;h1&gt;主导航条&lt;/h1&gt;
                &lt;h2&gt;这里放置最主要的导航&lt;/h2&gt;
            &lt;/hgroup&gt;
            &lt;ul&gt;
                &lt;li&gt;导航1&lt;/li&gt;
                &lt;li&gt;导航2&lt;/li&gt;
                &lt;li&gt;导航3&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/nav&gt;
    &lt;/header&gt;
    &lt;aside&gt;
        &lt;h2&gt;侧边栏&lt;/h2&gt;
        &lt;section&gt;
            &lt;h3&gt;侧边栏区域1&lt;/h3&gt;
            &lt;ul&gt;&lt;/ul&gt;
        &lt;/section&gt;
        &lt;section&gt;
            &lt;h3&gt;侧边栏区域2&lt;/h3&gt;
            &lt;ul&gt;&lt;/ul&gt;
        &lt;/section&gt;
        &lt;section&gt;
            &lt;h3&gt;侧边栏区域3&lt;/h3&gt;
            &lt;ul&gt;&lt;/ul&gt;
        &lt;/section&gt;
    &lt;/aside&gt;
    &lt;section&gt;
        &lt;h1&gt;内容&lt;/h1&gt;
        &lt;article&gt;
            &lt;hgroup&gt;
                &lt;h1&gt;第一篇文章&lt;/h1&gt;
                &lt;h2&gt;文章副标题&lt;/h2&gt;
                &lt;h3&gt;文章描述&lt;/h3&gt;
            &lt;/hgroup&gt;
            &lt;header&gt;
                &lt;nav&gt;
                    &lt;h2&gt;文章内部导航&lt;/h2&gt;
                    &lt;ul&gt;
                        &lt;li&gt;导航1&lt;/li&gt;
                        &lt;li&gt;导航2&lt;/li&gt;
                        &lt;li&gt;导航3&lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/nav&gt;
            &lt;/header&gt;
            &lt;p&gt;正文内容&lt;/p&gt;
        &lt;/article&gt;
        &lt;article&gt;
            &lt;hgroup&gt;
                &lt;h1&gt;第二篇文章&lt;/h1&gt;
                &lt;h2&gt;文章副标题&lt;/h2&gt;
                &lt;h3&gt;文章描述&lt;/h3&gt;
            &lt;/hgroup&gt;
            &lt;header&gt;
                &lt;nav&gt;
                    &lt;h2&gt;文章内部导航&lt;/h2&gt;
                    &lt;ul&gt;
                        &lt;li&gt;导航1&lt;/li&gt;
                        &lt;li&gt;导航2&lt;/li&gt;
                        &lt;li&gt;导航3&lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/nav&gt;
            &lt;/header&gt;
            &lt;p&gt;正文内容&lt;/p&gt;
        &lt;/article&gt;
    &lt;/section&gt;
    &lt;footer&gt;一些版权信息&lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>生成的大纲如下：</p>

<ol>
<li>整个文章的主题
<ol>
<li>主导航条</li>

<li>侧边栏
<ol>
<li>侧边栏区域1</li>

<li>侧边栏区域2</li>

<li>侧边栏区域3</li>
</ol>
</li>

<li>内容
<ol>
<li>第一篇文章
<ol>
<li>文章内部导航</li>
</ol>
</li>

<li>第二篇文章
<ol>
<li>文章内部导航</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>

<h2 id="html5_7">HTML5的文本级语义元素</h2>

<h3 id="b">b</h3>

<p>元素<code>&lt;b&gt;</code>通常用来给文本加粗，如今可以将其仅仅作为样式钩子来使用了</p>

<h3 id="em">em</h3>

<p>元素<code>&lt;em&gt;</code>，HTML5中赋予它的语义是：强调内容中的重点</p>

<h3 id="i">i</h3>

<p>元素<code>&lt;i&gt;</code>，过去只是给文本加斜体，如今它表示的语义是：一小段有不同于语态或语气的文字，或者样子上与普通文章有所差异以便标明不同特点的文字</p>

<p>注意这些元素，其中<code>&lt;b&gt;</code>已然会被很多浏览器默认渲染为粗体，而<code>&lt;i&gt;</code>则会被渲染为斜体，可以通过设置样式重置来消除浏览器默认的渲染效果</p>

<h2 id="html5_8">HTML5的多媒体标签</h2>

<h3 id="video">视频标签video</h3>

<p>如今绝大部分浏览器都支持HTML5的视频和音频，就连IE也从9就支持了，放心大胆的去用吧</p>

<p>使用<code>&lt;video src=&quot;myVideo.ogg&quot;&gt;&lt;/video&gt;</code>来嵌入视频，同时可以增加一些其他属性如：</p>

<ul>
<li>width：播放器的宽度</li>

<li>height： 播放器的高度</li>

<li>controls：为播放器添加控制栏</li>

<li>autoplay：播放器加载完后自动对视频进行播放</li>

<li>preload：媒体预加载</li>

<li>loop：重复播放视频</li>

<li>poster：定义视频缩略图</li>
</ul>

<p>同时，由于每个浏览器自身支持的视频格式的不同，可以为了兼容不同的浏览器，定义一个视频源栈，浏览器会从栈顶向下查找，如果找到能播放的格式，就忽略后面的源，对其进行播放，代码如下：</p>

<pre class="xml"><code class="xml">&lt;video width=&quot;640&quot; height=&quot;360&quot; contorls autoplay preload=&quot;auto&quot; loop poster=&quot;myVidelPost.jpg&quot;&gt;
    &lt;source src=&quot;video/myVideo.ogv&quot; type=&quot;video/ogg&quot;&gt;
    &lt;source src=&quot;video/myVideo.mp4&quot; type=&quot;video/mp4&quot;&gt;
&lt;/video&gt;</code></pre>

<h3 id="audio">audio</h3>

<p>元素<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>基本一致，除了width、height、poster外基本相同，但<code>audio</code>没有可视区域</p>

<h3 id="_7">响应式设计中的视频</h3>

<p>通过设置width和height为百分比来达到响应式的效果，但这样没办法解决iframe中视频的响应问题，可以使用JavaScript来解决，其中<a href="http://fitvidsjs.com/">FitVids</a>就是一个用来解决iframe中视频响应问题的jQuery插件</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/15/responsive-html5</guid>
            </item>
        
            <item>
                <title><![CDATA[ 聊聊响应式网页设计 ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/14/responsive-web-design</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 14 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p><span class='image image-full'><img alt='响应式Web设计' src='/images/responsive.png' /></span></p>

<p>总是在各个地方看到响应式Web设计。一直对其很感兴趣，也只是零零散散的接触，但并没有系统的去学习响应式。这两天读了Ben Frain著（王永强 译）的《响应式Web设计-HTML5和CSS3实践》，收获颇多，在这里记录一下</p>

<h2 id="web">什么是响应式Web设计？</h2>

<p>响应式网页设计： 由伊桑·马科特提出。他将弹性网格布局、弹性图片、媒体和媒体查询这三种已有的开发技巧整合，命名为响应式网页设计。它是针对任意设备对网页内容进行完美布局的一种显示机制。</p>

<p>同时还有很多其他的叫法：流式设计、弹性布局、塑料布局、流体设计、自适应布局、跨设备设计以及弹性设计</p>

<p>响应式Web设计倡导的是，首先针对小屏幕进行设计，然后逐步增强针对大屏幕的设计和内容</p>

<h2 id="">为什么要响应式？</h2>

<h3 id="_2">小屏幕的崛起</h3>

<p>根据<a href="http://gs.statcounter.com">统计数据</a>，使用台式机和笔记本上网的人越来越少，使用手机、pad等小屏幕上网的人越来越多。 这就表示，为了能让大多数用户能在自己的网站上有较好的用户体验，必须改变传统的针对台式机浏览器设计网页的思路，为移动终端上的网页浏览提供支持。</p>

<h3 id="_3">响应还是不响应？</h3>

<p>但是，并不是响应式设计就一定是最佳选择。如果预算充足，做一个真正的手机版网站更为合适。这样就可以为不同的用户，根据他们的条件（设备、位置、网速等）来提供不同的内容、设计与交互。</p>

<p>响应式Web设计的最终目的，就是需要做出能响应各种设备大小的完美设计，同时为无论哪种设备提供好的用户体验</p>

<h2 id="_4">如何做到响应式？</h2>

<p>要做到响应式，需要明确视口的概念：<code>视口指浏览器窗口内，网页实际显示的区域</code>。而不同设备上的用户体验不同，也是由于视口大小不同造成的。</p>

<h3 id="_5">视口</h3>

<p>这里，根据视口大小的不同，一般可以分为三个大类：</p>

<ul>
<li>手机等小视口：一般使用的浏览器基本都是webkit内核的现代浏览器。屏幕较小，浏览时需要排除掉所有多余的信息，将网页内容主体直观的呈现在浏览器中</li>

<li>平板电脑等中等大小视口：同手机等小视口终端设备，也是基本使用的webkit内核的现代浏览器，分辨率稍大。可以适当添加一些额外的导航信息放入其中</li>

<li>台式机、笔记本电脑等大视口：浏览器内核种类多种多样，现代浏览器的比例在上升，但是一些老式的浏览器依旧被广泛使用，需要兼容这些老式的浏览器。屏幕较大，可以显示所有信息（主体或是其他额外信息）。同时分辨率还在不断增大</li>
</ul>

<p>由于大视口设备的分辨率还在不断增大（比如博主的分辨率就是1920*1080的，经常被其他同学吐槽字太小看不见…），导致大视口设备与小视口设备的差距也在不断增大</p>

<h3 id="_6">设计方式</h3>

<p>所以在响应式页面设计时，首先，需要针对小视口设备进行设计，将网页中真正需要展示的内容放入其中。然后添加一些适当的跳转链接。在视口的分辨率达到一定时（这个分辨率临界点称为断点），在小视口设备所展现的页面上，添加一些相对重要的信息，用于适配中视口设备，形成新的设计。最后，在到达又一个临界点的时候，再次增加更多的信息，形成大视口的网页设计。</p>

<p>这是响应式页面设计真正所倡导的设计方式，由小至大，逐步扩展。但目前经常遇到的工作并不是编写新的响应式页面，更多的时候是需要将老的页面转换成响应式的。这点可以通过哪种逐步扩展的思想反过来，逐步删除一些不重要的信息，最终只留下重要的信息。或许会有人想在小视口和中视口的设计中也保留所有信息，但这样会破坏用户体验中“内容为主”的原则，而且也加大了小视口设备中页面设计的难度。</p>

<h2 id="_7">响应式的实现方式？</h2>

<p>响应式的实现方式有两种：</p>

<ol>
<li>通过JavaScript获取当前视口大小，来动态的加载CSS文件实现</li>

<li>通过HTML5+CSS3的媒体查询来实现</li>
</ol>

<h3 id="javascript">JavaScript实现</h3>

<p>通过JavaScript实现是相对古老的方式，主要思路就是通过JavaScript的window对象获取当前视口的宽度和高度（一般是宽度，因为页面的高度一般是动态改变的），然后根据当前视口信息确定需要添加的CSS文件，使用诸如<code>document.createStyleSheet(cssFile);</code>的代码进行CSS文件的动态添加。这种方法依赖JavaScript，同时也会造成额外的性能问题</p>

<h3 id="html5css3">HTML5和CSS3实现</h3>

<p>现在HTML5+CSS3可以通过很简单的方式来添加，比如HTML5支持根据视口信息来动态添加CSS文件：</p>

<pre class="xml"><code class="xml">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/screen.css&quot; media=&quot;screen&quot;&gt;</code></pre>

<p>更多的支持我将会在后续的博文中进行详细介绍</p>

<p>而在CSS文件中，也可以根据视口信息应用样式：</p>

<pre class="css21"><code class="css21">@media screen and (max-width: 960px) {
   /*需要在960px以下宽度设备中使用的CSS*/
}</code></pre>

<p>媒体查询并不是上面简单的代码就能展示的，其可以查询的信息有：</p>

<ol>
<li>视口高度</li>

<li>视口宽度</li>

<li>设备屏幕高度</li>

<li>设备屏幕宽度</li>

<li>设备方向（横向还是纵向）</li>

<li>视口宽高比</li>

<li>设备屏幕宽高比</li>

<li>颜色的位数</li>

<li>单色缓冲区中每像素所使用的位数</li>

<li>屏幕或打印机的分辨率</li>

<li>电视机的扫描方式</li>

<li>输出设备是网格设备还是位图设备</li>
</ol>

<p>其中除了电视机的扫描范围和设备是否是网格还是位图的检测外，其他检测都能用min和max创建一个查询范围，可谓相当强大。</p>

<p>也许会有一些顾虑，媒体查询是否被大多数浏览器支持。情况是，媒体查询已经被浏览器广泛支持，老版本的IE 6、7、8也可以通过JavaScript补丁进行修复。所以，没有理由拒绝使用媒体查询</p>

<h2 id="_8">响应式的效果</h2>

<p>这篇博客实际上就是响应式的，使用了html5up的HTML5模板，放大缩小浏览器的可视区域，或者通过其他设备访问，将看到不一样的效果</p>

<h2 id="_9">写在最后</h2>

<p>响应式Web设计需要的结果是使用有限的资源，为所有设备上的用户提供较好的用户体验。其实这个博客就是响应式的。其中涉及到较多的HTML5+CSS3的内容，所以经常需要在兼顾多种浏览器和开发成本上权衡利弊，后续会有HTML5和CSS3的文章。这两天没写文章了，之前的两天一篇文章的计划被打破了，必须加油了</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/14/responsive-web-design</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript选择题解答（21-37） ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/11/javascript-puzzlers-2</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 11 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h3 id="">第二十一题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">var a = 111111111111111110000,
    b = 1111;
a + b;</code></pre>

<p>A: 111111111111111111111</p>

<p>B: 111111111111111110000</p>

<p>C: NaN</p>

<p>D: Infinity</p>

<p>又是一道考查JavaScript数字的题，与第七题考察点相似。由于JavaScript实际上只有一种数字形式IEEE 754标准的64位双精度浮点数，其所能表示的整数范围为-2^53~2^53(包括边界值)。这里的111111111111111110000已经超过了2^53次方，所以会发生精度丢失的情况。综上选B</p>

<h3 id="_2">第二十二题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">var x = [].reverse;
x();</code></pre>

<p>A: []</p>

<p>B: undefined</p>

<p>C: error</p>

<p>D: window</p>

<p>这题考查的是函数调用时的this和Array.prototype.reverse方法。</p>

<p>首先看Array.prototype.reverse方法，首先举几个栗子：</p>

<pre class="javascript"><code class="javascript">console.log(Array.prototype.reverse.call(&quot;skyinlayer&quot;));
//skyinlayer
console.log(Array.prototype.reverse.call({}));
//Object {}
console.log(Array.prototype.reverse.call(123));
//123</code></pre>

<p>这几个栗子可以得出一个结论，Array.prototype.reverse方法的返回值，就是this</p>

<p>Javascript中this有如下几种情况：</p>

<p>全局下this，指向window对象</p>

<pre class="javascript"><code class="javascript">console.log(this);
//输出结果：
//Window {top: Window, window: Window, location: Location, external: Object, chrome: Object…}</code></pre>

<p>函数调用，this指向全局window对象：</p>

<pre class="javascript"><code class="javascript">function somefun(){
    console.log(this);
}
somefun();
//输出结果：
//Window {top: Window, window: Window, location: Location, external: Object, chrome: Object…}</code></pre>

<p>方法调用，this指向拥有该方法的对象：</p>

<pre class="javascript"><code class="javascript">var someobj = {};
someobj.fun = function(){
    console.log(this);
};
console.log(someobj.fun());
//输出结果：
//Object {fun: function}</code></pre>

<p>调用构造函数，构造函数内部的this指向新创建对象：</p>

<pre class="javascript"><code class="javascript">function Con() {
    console.log(this);
}
Con.prototype.somefun = function(){};
console.log(new Con());
//输出结果：
//Con {somefun: function}</code></pre>

<p>显示确定this：</p>

<pre class="javascript"><code class="javascript">function somefun(){
    console.log(this);
};
somefun.apply(&quot;skyinlayer&quot;);
somefun.call(&quot;skyinlayer&quot;);
//输出结果：
//String {0: &quot;s&quot;, 1: &quot;k&quot;, 2: &quot;y&quot;, 3: &quot;i&quot;, 4: &quot;n&quot;, 5: &quot;l&quot;, 6: &quot;a&quot;, 7: &quot;y&quot;, 8: &quot;e&quot;, 9: &quot;r&quot;, length: 10}
//String {0: &quot;s&quot;, 1: &quot;k&quot;, 2: &quot;y&quot;, 3: &quot;i&quot;, 4: &quot;n&quot;, 5: &quot;l&quot;, 6: &quot;a&quot;, 7: &quot;y&quot;, 8: &quot;e&quot;, 9: &quot;r&quot;, length: 10} </code></pre>

<p>这里可以看到，使用的是函数调用方式，this指向的是全局对象window，所以选D</p>

<h3 id="_3">第二十三题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">Number.MIN_VALUE &gt; 0</code></pre>

<p>A: false</p>

<p>B: true</p>

<p>C: error</p>

<p>D: other</p>

<p>考查的Number.MIN_VALUE的概念，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE">MDN传送门</a>，关键的几句话</p>

<ul>
<li>
<p>The Number.MIN_VALUE property represents the smallest positive numeric value representable in JavaScript. 翻译：Number.MIN_VALUE表示的是JavaScript中最小的正数</p>
</li>

<li>
<p>The MIN_VALUE property is the number closest to 0, not the most negative number, that JavaScript can represent. 翻译：MIN_VALUE是接近0的数，而不是最小的数</p>
</li>

<li>
<p>MIN_VALUE has a value of approximately 5e-324. Values smaller than MIN_VALUE (“underflow values”) are converted to 0. 翻译：MIN_VALUE值约等于5e-324，比起更小的值（大于0），将被转换为0</p>
</li>
</ul>

<p>所以，这里是true，选B</p>

<p>顺带把Number的几个常量拉出来：</p>

<ul>
<li>Number.MAX_VALUE：最大的正数</li>

<li>Number.MIN_VALUE：最小的正数</li>

<li>Number.NaN：特殊值，用来表示这不是一个数</li>

<li>Number.NEGATIVE_INFINITY：负无穷大</li>

<li>Number.POSITIVE_INFINITY：正无穷大</li>
</ul>

<p>如果要表示最小的负数和最大的负数，可以使用-Number.MAX_VALUE和-Number.MIN_VALUE</p>

<h3 id="_4">第二十四题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1]</code></pre>

<p>A: [true, true]</p>

<p>B: [true, false]</p>

<p>C: error</p>

<p>D: other</p>

<p>运算符的运算顺序和隐式类型转换的题，从<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN上运算符优先级</a>，’&lt;’运算符顺序是从左到右，所以变成了[true &lt; 3, false &lt; 1]</p>

<p>接着进行隐式类型转换，’&lt;’操作符的转换规则（来自<a href="http://www.cnblogs.com/mizzle/archive/2011/08/12/2135885.html">$雨$的文章《Javascript类型转换的规则》</a>）:</p>

<ol>
<li>如果两个操作值都是数值，则进行数值比较</li>

<li>如果两个操作值都是字符串，则比较字符串对应的字符编码值</li>

<li>如果只有一个操作值是数值，则将另一个操作值转换为数值，进行数值比较</li>

<li>如果一个操作数是对象，则调用valueOf()方法（如果对象没有valueOf()方法则调用toString()方法），得到的结果按照前面的规则执行比较</li>

<li>如果一个操作值是布尔值，则将其转换为数值，再进行比较</li>
</ol>

<p>所以，这里首先通过Number()转换为数字然后进行比较，true会转换成1，而false转换成0，就变成了[1 &lt; 3, 0 &lt; 1]</p>

<p>所以结果为A</p>

<h3 id="_5">第二十五题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">// the most classic wtf
2 == [[[2]]]</code></pre>

<p>A: true</p>

<p>B: false</p>

<p>C: undefined</p>

<p>D: other</p>

<p>又是隐式类型转换的题（汗）</p>

<p>题目作者的解释是： both objects get converted to strings and in both cases the resulting string is “2”</p>

<p>也就是说左右两边都被转换成了字符串，而字符串都是”2”</p>

<p>这里首先需要对==右边的数组进行类型转换，根据以下规则（来自<a href="http://justjavac.iteye.com/blog/1848749">justjavac的文章《「译」JavaScript 的怪癖 1：隐式类型转换》</a>）：</p>

<ol>
<li>调用 valueOf()。如果结果是原始值（不是一个对象），则将其转换为一个数字。</li>

<li>否则，调用 toString() 方法。如果结果是原始值，则将其转换为一个数字。</li>

<li>否则，抛出一个类型错误。</li>
</ol>

<p>所以右侧被使用toString()方法转换为”2”，然后又通过Number(“2”)转换为数字2进行比较，结果就是true了，选A</p>

<h3 id="_6">第二十六题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">3.toString()
3..toString()
3...toString()</code></pre>

<p>A: “3”, error, error</p>

<p>B: “3”, “3.0”, error</p>

<p>C: error, “3”, error</p>

<p>D: other</p>

<p>说实话这题有点常见了，很多人都踩过3.toString()的坑（包括我）…虽然JavaScript会在调用方法时对原始值进行包装，但是这个点是小数点呢、还是方法调用的点呢，于是乎第一个就是error了，因为JavaScript解释器会将其认为是小数点。</p>

<p>而第二个则很好说通了，第一个点解释为小数点，变成了(3.0).toString()，结果就是”3”了</p>

<p>第三个也是，第一个点为小数点，第二个是方法调用的点，但是后面接的不是一个合法的方法名，于是乎就error了</p>

<p>综上，选C</p>

<h3 id="_7">第二十七题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">(function(){
  var x = y = 1;
})();
console.log(y);
console.log(x);</code></pre>

<p>A: 1, 1</p>

<p>B: error, error</p>

<p>C: 1, error</p>

<p>D: other</p>

<p>变量提升和隐式定义全局变量的题，也是一个JavaScript经典的坑</p>

<p>还是那句话，在作用域内，变量定义和函数定义会先行提升，所以里面就变成了:</p>

<pre class="javascript"><code class="javascript">(function(){
    var x;
    y = 1;
    x = 1;
})();</code></pre>

<p>这点会问了，为什么不是<code>var x, y;</code>，这就是坑的地方…这里只会定义第一个变量x，而y则会通过不使用var的方式直接使用，于是乎就隐式定义了一个全局变量y</p>

<p>所以，y是全局作用域下，而x则是在函数内部，结果就为1, error，选C</p>

<h3 id="_8">第二十八题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">var a = /123/,
    b = /123/;
a == b
a === b</code></pre>

<p>A: true, true</p>

<p>B: true, false</p>

<p>C: false, false</p>

<p>D: other</p>

<p>首先需要明确JavaScript的正则表达式是什么。JavaScript中的正则表达式依旧是对象，使用typeof运算符就能得出结果：</p>

<pre class="javascript"><code class="javascript">console.log(typeof /123/);
//输出结果：
//&quot;object&quot;</code></pre>

<p>’==’运算符左右两边都是对象时，会比较他们是否指向同一个对象，可以理解为C语言中两个指针的值是否一样（指向同一片内存），所以两个结果自然都是false</p>

<h3 id="_9">第二十九题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">var a = [1, 2, 3],
    b = [1, 2, 3],
    c = [1, 2, 4]
a == b
a === b
a &gt; c
a &lt; c</code></pre>

<p>A: false, false, false, true</p>

<p>B: false, false, false, false</p>

<p>C: true, true, false, true</p>

<p>D: other</p>

<p>和上题类似，JavaScript中Array的本质也是对象，所以前两个的结果都是false，</p>

<p>而JavaScript中Array的’&gt;’运算符和’&lt;’运算符的比较方式类似于字符串比较字典序，会从第一个元素开始进行比较，如果一样比较第二个，还一样就比较第三个，如此类推，所以第三个结果为false，第四个为true。</p>

<p>综上所述，结果为false, false, false, true，选A</p>

<h3 id="_10">第三十题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">var a = {}, b = Object.prototype;
[a.prototype === b, Object.getPrototypeOf(a) === b]</code></pre>

<p>A: [false, true]</p>

<p>B: [true, true]</p>

<p>C: [false, false]</p>

<p>D: other</p>

<p>原型链的题（总会有的），考查的__proto__和prototype的区别。首先要明确对象和构造函数的关系，对象在创建的时候，其__proto__会指向其构造函数的prototype属性</p>

<p>Object实际上是一个构造函数（typeof Object的结果为”function”）,使用字面量创建对象和new Object创建对象是一样的，所以a.__proto__也就是Object.prototype，而Object.getPrototypeOf(a)与a.__proto__是一样的，所以第二个结果为true</p>

<p>而实例对象是没有prototype属性的，只有函数才有，所以a.prototype其实是undefined，第一个结果为false</p>

<p>综上，选A</p>

<h3 id="_11">第三十一题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">function f() {}
var a = f.prototype, b = Object.getPrototypeOf(f);
a === b</code></pre>

<p>A: true</p>

<p>B: false</p>

<p>C: null</p>

<p>D: other</p>

<p>还是__proto__和prototype的区别，两者不是一个东西，所以选B</p>

<h3 id="_12">第三十二题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">function foo() { }
var oldName = foo.name;
foo.name = &quot;bar&quot;;
[oldName, foo.name]</code></pre>

<p>A: error</p>

<p>B: [””, ””]</p>

<p>C: [“foo”, “foo”]</p>

<p>D: [“foo”, “bar”]</p>

<p>考察了函数的name属性，使用函数定义方式时，会给function对象本身添加一个name属性，保存了函数的名称，很好理解oldName为”foo”。name属性时只读的，不允许修改，所以<code>foo.name = &quot;bar&quot;;</code>之后，foo.name还是”foo”，所以结果为[“foo”, “foo”]，选C</p>

<p>PS：name属性不是一个标准属性，不要去使用，除非你想要坑别人</p>

<h3 id="_13">第三十三题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">&quot;1 2 3&quot;.replace(/\d/g, parseInt)</code></pre>

<p>A: “1 2 3”</p>

<p>B: “0 1 2”</p>

<p>C: “NaN 2 3”</p>

<p>D: “1 NaN 3”</p>

<p>String.prototype.replace、正则表达式的全局匹配和parseInt（又是parseInt…），可以根据题意看出来题目上漏了一个’&#39;</p>

<p>首先需要确定replace会传给parseInt哪些参数。举个栗子：</p>

<pre class="javascript"><code class="javascript">&quot;1 2 3&quot;.replace(/\d/g, function(){
    console.log(arguments);
});
//输出结果：
//[&quot;1&quot;, 0, &quot;1 2 3&quot;]
//[&quot;2&quot;, 2, &quot;1 2 3&quot;]
//[&quot;3&quot;, 4, &quot;1 2 3&quot;] </code></pre>

<p>一共三个：</p>

<ol>
<li>match：正则表达式被匹配到的子字符串</li>

<li>offset：被匹配到的子字符串在原字符串中的位置</li>

<li>string：原字符串</li>
</ol>

<p>这样就很好理解了，又回到之前parseInt的问题了，结果就是parseInt(“1”, 10), parseInt(“2”, 2), parseInt(“3”, 4)所以结果为”1, NaN, 3”，选D</p>

<h3 id="_14">第三十四题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">function f() {}
var parent = Object.getPrototypeOf(f);
f.name // ?
parent.name // ?
typeof eval(f.name) // ?
typeof eval(parent.name) //  ?</code></pre>

<p>A: “f”, “Empty”, “function”, “function”</p>

<p>B: “f”, undefined, “function”, error</p>

<p>C: “f”, “Empty”, “function”, error</p>

<p>D: other</p>

<p>又是Function.name属性的题，和三十二题一样样，f.name值为”f”，而eval(“f”)则会输出f函数，所以结果为”function”</p>

<p>接着看parent，parent实际上就是f.__proto__，需要明确的是JavaScript中的函数也是对象，其也有自己的构造函数Function，所以f.__proto__ === Function.prototype结果是true，而Function.prototype就是一个名为Empty的function</p>

<pre class="javascript"><code class="javascript">console.log(Function.prototype);
console.log(Function.prototype.name);
//输出结果：
//function Empty() {}
//Empty</code></pre>

<p>所以parent.name的值为Empty</p>

<p>如果想直接在全局作用域下调用Empty，显示未定义…因为Empty并不在全局作用域下</p>

<p>综上所述，结果为C</p>

<h3 id="_15">第三十五题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">var lowerCaseOnly =  /^[a-z]+$/;
[lowerCaseOnly.test(null), lowerCaseOnly.test()]</code></pre>

<p>A: [true, false]</p>

<p>B: error</p>

<p>C: [true, true]</p>

<p>D: [false, true]</p>

<p>正则表达式的test方法会自动将参数转换为字符串，原式就变成了<code>[lowerCaseOnly.test(&quot;null&quot;), lowerCaseOnly.test(&quot;undefined&quot;)]</code>，结果都是真，所以选C</p>

<h3 id="_16">第三十六题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">[,,,].join(&quot;, &quot;)</code></pre>

<p>A: “, , , ”</p>

<p>B: “undefined, undefined, undefined, undefined”</p>

<p>C: “, , ”</p>

<p>D: ””</p>

<p>JavaScript中使用字面量创建数组时，如果最末尾有一个逗号’,’，会背省略，所以实际上这个数组只有三个元素（都是undefined）：</p>

<pre class="javascript"><code class="javascript">console.log([,,,].length);
//输出结果：
//3</code></pre>

<p>而三个元素，使用join方法，只需要添加两次，所以结果为”, , “，选C</p>

<h3 id="_17">第三十七题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">var a = {class: &quot;Animal&quot;, name: &#39;Fido&#39;};
a.class</code></pre>

<p>A: “Animal”</p>

<p>B: Object</p>

<p>C: an error</p>

<p>D: other</p>

<p>经典坑中的一个，class是关键字。根据浏览器的不同，结果不同：</p>

<p>chrome的结果： “Animal”</p>

<p>Firefox的结果：”Animal”</p>

<p>Opera的结果：”Animal”</p>

<p>IE 8以上也是： “Animal”</p>

<p>IE 8 及以下： 报错</p>

<h3 id="_18">总结</h3>

<p>终于把37题全部弄完了，虽然很多题都偏而怪，但其中涉及的知识还是相当重要的。JavaScript中的糟粕和精华永远是一个话题，也是笔试面试时经常遇到的问题。</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/11/javascript-puzzlers-2</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript选择题解答（1-20） ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/10/javascript-puzzlers</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 10 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>最近做了个heroku上的JavaScript的测试（<a href="http://javascript-puzzlers.herokuapp.com/">题目地址</a>），错了一大堆，感觉js的概念还有很多不是很清晰，这里记录一下</p>

<h3 id="">第一题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) </code></pre>

<p>A：[“1”, “2”, “3”]</p>

<p>B：[1, 2, 3]</p>

<p>C：[0, 1, 2]</p>

<p>D：other</p>

<p>解答：这里考的是map、parseInt的用法。map会传递三个参数给其作为参数的函数，为(element, index, array)，分别为当前的元素、当前元素在数组中的位置、整个数组：</p>

<pre><code>&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(function(){console.log(arguments)}) 
[&quot;1&quot;, 0, Array[3]]
[&quot;2&quot;, 1, Array[3]]
[&quot;3&quot;, 2, Array[3]]</code></pre>

<p>而parseInt只接收两个参数，为(element, radix)，element代表需要被转换为int的字符串，radix代表当前字符串里数字的进制数</p>

<p>所以相当于说，结果数组的元素实际分别为为：</p>

<pre><code>parseInt(&quot;1&quot;, 0)
parseInt(&quot;2&quot;, 1)
parseInt(&quot;3&quot;, 2)</code></pre>

<p>parseInt(“1”, 0)的值为1，MDN上可以看到parseInt函数的radix为0时的行为</p>

<p>If radix is undefined or 0 (or absent), JavaScript assumes the following:</p>

<p>If the input string begins with “0x” or “0X”, radix is 16 (hexadecimal) and the remainder of the string is parsed.</p>

<p>If the input string begins with “0”, radix is eight (octal) or 10 (decimal). Exactly which radix is chosen is implementation-dependent. ECMAScript 5 specifies that 10 (decimal) is used, but not all browsers support this yet. For this reason always specify a radix when using parseInt.</p>

<p>If the input string begins with any other value, the radix is 10 (decimal).</p>

<p>所以这里radix值实际为10，所以结果为1</p>

<p>而parseInt(“2”, 1)和parseInt(“3”, 2)则确实无法解析，会生成NaN</p>

<p>所以答案为[1,NaN,NaN]，为D</p>

<h3 id="_2">第二题和第五题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">[typeof null, null instanceof Object]</code></pre>

<p>A: [“object”, false]</p>

<p>B: [null, false]</p>

<p>C: [“object”, true]</p>

<p>D: other</p>

<p>考察typeof运算符和instanceof运算符，上MDN上看一下typeof运算符，一些基础类型的结果为： Undefined “undefined” Null “object” Boolean “boolean” Number “number” String “string” Any other object “object” Array “object”</p>

<p>自从javascript创造出来，typeof null的值就是object了</p>

<p>而null instanceof 任何类型 都是false</p>

<p>所以答案为[“object”, false], 选A</p>

<h3 id="_3">第三题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow)] ]</code></pre>

<p>A: an error</p>

<p>B: [9, 0]</p>

<p>C: [9, NaN]</p>

<p>D: [9, undefined]</p>

<p>这题考的Math.pow和Array.prototype.reduce</p>

<p>Math.pow(base, exponent)接受两个参数：基数、需要计算的次方</p>

<p>reduce传递给其作为参数的函数几个值：</p>

<ul>
<li>previousValue：上一次计算的结果</li>

<li>currentValue：当前元素的值</li>

<li>index： 当前元素在数组中的位置</li>

<li>array：整个数组</li>
</ul>

<p>reduce本身接受两个参数，callback和initialValue，分别是reduce的回调函数和计算初始值–也就是第一次reduce的callback被调用时的previousValue的值，默认为0</p>

<p>reduce在数组为空且没有定义initialValue时，会抛出错误，如chrome下：TypeError: Reduce of empty array with no initial value</p>

<p>所以选A</p>

<h3 id="_4">第四题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">var val = &#39;smtg&#39;;
console.log(&#39;Value is &#39; + (val === &#39;smtg&#39;) ? &#39;Something&#39; : &#39;Nothing&#39;);</code></pre>

<p>A: Value is Something</p>

<p>B: Value is Nothing</p>

<p>C: NaN</p>

<p>D: other</p>

<p>这题考的javascript中的运算符符优先级，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN传送门</a>，这里’+’运算符的优先级要高于’?’所以运算符，实际上是 ‘Value is true’?’Something’ : ‘Nothing’，当字符串不为空时，转换为bool为true，所以结果为’Something’，选D</p>

<h3 id="_5">第六题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">var name = &#39;World!&#39;;
(function () {
    if (typeof name === &#39;undefined&#39;) {
        var name = &#39;Jack&#39;;
        console.log(&#39;Goodbye &#39; + name);
    } else {
        console.log(&#39;Hello &#39; + name);
    }
})();</code></pre>

<p>A: Goodbye Jack</p>

<p>B: Hello Jack</p>

<p>C: Hello undefined</p>

<p>D: Hello World</p>

<p>这题考的是javascript作用域中的变量提升，javascript的作用于中使用var定义的变量都会被提升到所有代码的最前面，于是乎这段代码就成了：</p>

<pre class="javascript"><code class="javascript">var name = &#39;World!&#39;;
(function () {
    var name;//现在还是undefined
    if (typeof name === &#39;undefined&#39;) {
        name = &#39;Jack&#39;;
        console.log(&#39;Goodbye &#39; + name);
    } else {
        console.log(&#39;Hello &#39; + name);
    }
})();</code></pre>

<p>这样就很好理解了，<code>typeof name === &#39;undefined&#39;</code>的结果为true，所以最后会输出’Goodbye Jack’，选A</p>

<h3 id="_6">第七题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">var END = Math.pow(2, 53);
var START = END - 100;
var count = 0;
for (var i = START; i &lt;= END; i++) {
    count++;
}
console.log(count);</code></pre>

<p>A: 0</p>

<p>B: 100</p>

<p>C: 101</p>

<p>D: other</p>

<p>这题考查javascript中的数字的概念：首先明确一点，javascript和其他语言不同，仅有一种数字，IEEE 754标准的64位浮点数，能够表示的整数范围是-2^53~2^53（包含边界值），所以Math.pow(2, 53)即为javascript中所能表示的最大整数，在最大整数在继续增大就会出现精度丢失的情况，END + 1 的值其实是等于END的，这也就造成了死循环，所以选D</p>

<h3 id="_7">第八题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">var ary = [0,1,2];
ary[10] = 10;
ary.filter(function(x) { return x === undefined;});</code></pre>

<p>A: [undefined 脳 7]</p>

<p>B: [0, 1, 2, 10]</p>

<p>C: []</p>

<p>D: [undefined]</p>

<p>考查Array.prototype.filter方法的使用，MDN上有这么一句it is not invoked for indexes which have been deleted or which have never been assigned values，所以结果为空数组，选C</p>

<h3 id="_8">第九题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">var two   = 0.2
var one   = 0.1
var eight = 0.8
var six   = 0.6
[two - one == one, eight - six == two]</code></pre>

<p>A: [true, true]</p>

<p>B: [false, false]</p>

<p>C: [true, false]</p>

<p>D: other</p>

<p>浮点数计算时的精度丢失问题，其他语言也会出现…至于结果，反正我是蒙的…chrome中计算出来的结果：[0.1, 0.20000000000000007]，也就是[true, false]，选C</p>

<h3 id="_9">第十题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">function showCase(value) {
    switch(value) {
    case &#39;A&#39;:
        console.log(&#39;Case A&#39;);
        break;
    case &#39;B&#39;:
        console.log(&#39;Case B&#39;);
        break;
    case undefined:
        console.log(&#39;undefined&#39;);
        break;
    default:
        console.log(&#39;Do not know!&#39;);
    }
}
showCase(new String(&#39;A&#39;));</code></pre>

<p>A: Case A</p>

<p>B: Case B</p>

<p>C: Do not know!</p>

<p>D: undefined</p>

<p>这题考的是使用new方法创建基础类型，使用new方法创建的基础类型，首先来看个栗子(chrome):</p>

<pre class="javascript"><code class="javascript">&gt; typeof new String(&quot;skyinlayer&quot;);
&quot;object&quot;
typeof &quot;skyinlayer&quot;;
&quot;string&quot;</code></pre>

<p>这样基本上就能看到结果了，但是为什么呢？MDN上的解释是，字符串字面量和直接调用String()方法（不使用new调用构造函数）的结果是原始字符串。JS自动回转化原始字符串到String对象。所以可以在原始字符串上使用用String对象的方法。而在上下文中，在原始字符串的方法被调用或者从其中获取属性时，JS会自动包裹原始字符串然后调用方法或者获取属性。</p>

<p>所以呢，JS本身有原始字符串和字符串对象之分，只不过在调用方法和获取属性时的时候会自动转换，但typeof运算符运算时是不会转换的。Number和Boolean同样适用</p>

<p>所以这里结果为Do not know!，选C</p>

<h3 id="_10">第十一题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">function showCase2(value) {
    switch(value) {
    case &#39;A&#39;:
        console.log(&#39;Case A&#39;);
        break;
    case &#39;B&#39;:
        console.log(&#39;Case B&#39;);
        break;
    case undefined:
        console.log(&#39;undefined&#39;);
        break;
    default:
        console.log(&#39;Do not know!&#39;);
    }
}
showCase(String(&#39;A&#39;));</code></pre>

<p>A: Case A</p>

<p>B: Case B</p>

<p>C: Do not know!</p>

<p>D: undefined</p>

<p>和上题原理一样，不过这里没有使用new来生成字符串，所以生成的结果就是原始字符串，相当于<code>showCase(&#39;A&#39;)</code>，所以结果就是A了</p>

<h3 id="_11">第十二题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">function isOdd(num) {
    return num % 2 == 1;
}
function isEven(num) {
    return num % 2 == 0;
}
function isSane(num) {
    return isEven(num) || isOdd(num);
}
var values = [7, 4, &#39;13&#39;, -9, Infinity];
values.map(isSane);</code></pre>

<p>A: [true, true, true, true, true]</p>

<p>B: [true, true, true, true, false]</p>

<p>C: [true, true, true, false, false]</p>

<p>D: [true, true, false, false, false]</p>

<p>还是JS的数字相关，不过这次考察的是取模，这题我也是瞎蒙的（果断跪了）。</p>

<p>前两个基本上没什么疑问，必然是true</p>

<p>‘13’在进行计算前则会进行隐式类型转换（JS最恶心的部分之一），详细参见<a href="http://www.cnblogs.com/mizzle/archive/2011/08/12/2135885.html">$雨$的文章《Javascript类型转换的规则》</a>，这里的规则就是将字符串通过Number()方法转换为数字，所以结果为13 % 2 ，也就是true</p>

<p>而JS中负数取模的结果是负数，这里-9%2的结果实际上是-1，所以为false</p>

<p>而Infinity对任意数取模都是NaN，所以是false</p>

<p>综上，结果为[true, true, true, false, false]，也就是C</p>

<h3 id="_12">第十三题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">parseInt(3, 8)
parseInt(3, 2)
parseInt(3, 0)</code></pre>

<p>A: 3, 3, 3</p>

<p>B: 3, 3, NaN</p>

<p>C: 3, NaN, NaN</p>

<p>D: other</p>

<p>还是parseInt的题，考的和第一题类似，第一个值为3没什么好说的。如果出现的数字不符合后面输入的进制，则为NaN，所以第二个值为NaN。而radix为0时的情况第一题下面有介绍，这里也是一样为默认10，所以结果为3，所以答案为3, NaN, 3，选D</p>

<h3 id="_13">第十四题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">Array.isArray( Array.prototype )</code></pre>

<p>A: true</p>

<p>B: false</p>

<p>C: error</p>

<p>D: other</p>

<p>死知识，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype">MDN传送门</a>，这是MDN官方给的例子</p>

<h3 id="_14">第十五题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">var a = [0];
if ([0]) { 
  console.log(a == true);
} else { 
  console.log(&quot;wut&quot;);
}</code></pre>

<p>A: true</p>

<p>B: false</p>

<p>C: “wut”</p>

<p>D: other</p>

<p>同样是一道隐式类型转换的题，不过这次考虑的是’==’运算符，a本身是一个长度为1的数组，而当数组不为空时，其转换成bool值为true。</p>

<p>而==左右的转换，会使用<code>如果一个操作值为布尔值，则在比较之前先将其转换为数值</code>的规则来转换，Number([0])，也就是0，于是变成了0 == true，结果自然是false，所以最终结果为B</p>

<h3 id="_15">第十六题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">[] == []</code></pre>

<p>A: true</p>

<p>B: false</p>

<p>C: error</p>

<p>D: other</p>

<p>这题考的是数组字面量创建数组的原理和==运算符，首先JS中数组的真实类型是Object这点很明显<code>typeof []</code>的值为”object”，而==运算符当左右都是对象时，则会比较其是否指向同一个对象。而每次调用字面量创建，都会创造新的对象，也就是会开辟新的内存区域。所以指针的值自然不一样，结果为 false，选B</p>

<h3 id="_16">第十七题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">&#39;5&#39; + 3  
&#39;5&#39; - 3  </code></pre>

<p>A: 53, 2</p>

<p>B: 8, 2</p>

<p>C: error</p>

<p>D: other</p>

<p>又是一道隐式类型转换的题</p>

<p>加法： 加法运算中，如果有一个操作值为字符串类型，则将另一个操作值转换为字符串，最后连接起来</p>

<p>减法： 如果操作值之一不是数值，则被隐式调用Number()函数进行转换</p>

<p>所以第一行结果为字符串运算，为’53’。第二行结果为2，选A</p>

<h3 id="_17">第十八题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">1 + - + + + - + 1 </code></pre>

<p>A: 2</p>

<p>B: 1</p>

<p>C: error</p>

<p>D: other</p>

<p>C语言中的经典…对于这种问题，原理什么的不懂，蒙吧，结果是2</p>

<h3 id="_18">第十九题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">var ary = Array(3);
ary[0]=2
ary.map(function(elem) { return &#39;1&#39;; }); </code></pre>

<p>A: [2, 1, 1]</p>

<p>B: [“1”, “1”, “1”]</p>

<p>C: [2, “1”, “1”]</p>

<p>D: other</p>

<p>又是考的Array.prototype.map的用法，map在使用的时候，只有数组中被初始化过元素才会被触发，其他都是undefined，所以结果为[“1”, undefined × 2]，选D</p>

<h3 id="_19">第二十题</h3>

<p>What is the result of this expression? (or multiple ones)</p>

<pre class="javascript"><code class="javascript">function sidEffecting(ary) { 
  ary[0] = ary[2];
}
function bar(a,b,c) { 
  c = 10
  sidEffecting(arguments);
  return a + b + c;
}
bar(1,1,1)</code></pre>

<p>A: 3</p>

<p>B: 12</p>

<p>C: error</p>

<p>D: other</p>

<p>这题考的是JS的函数arguments的概念：</p>

<p>在调用函数时，函数内部的arguments维护着传递到这个函数的参数列表。它看起来是一个数组，但实际上它只是一个有length属性的Object，不从Array.prototype继承。所以无法使用一些Array.prototype的方法。</p>

<p>arguments对象其内部属性以及函数形参创建getter和setter方法，因此改变形参的值会影响到arguments对象的值，反过来也是一样</p>

<p>具体例子可以参见<a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#function.arguments">Javascript秘密花园#arguments</a></p>

<p>所以，这里所有的更改都将生效，a和c的值都为10，a+b+c的值将为21，选D</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/10/javascript-puzzlers</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（将本地博客上传至github） ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/09/jekyll-5</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 09 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>系列文章传送门：</p>

<p><a href="http://skyinlayer.com/blog/2014/01/25/jekyll-1/">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>

<p><a href="http://skyinlayer.com/blog/2014/01/27/jekyll-2/">使用Jekyll在Github上搭建个人博客（博客编写）</a></p>

<p><a href="http://skyinlayer.com/blog/2014/02/06/jekyll-3/">使用Jekyll在Github上搭建个人博客（分页实现）</a></p>

<p><a href="http://skyinlayer.com/blog/2014/02/06/jekyll-4/">使用Jekyll在Github上搭建个人博客（文章分类索引）</a></p>

<h3 id="">预先准备</h3>

<p>首先安装git bash和申请，这个文章很多，百度、Google上一抓一大把，就不重复赘述了</p>

<h3 id="git">对已有项目进行git初始化</h3>

<p>到jekyll项目下，运行命令：</p>

<pre class="shell"><code class="shell">$ git init</code></pre>

<h3 id="ghpages">创建一个名为gh-pages的分支</h3>

<pre class="shell"><code class="shell">$ git checkout --orphan gh-pages</code></pre>

<p><a href="http://jekyllrb.com/docs/github-pages/">Jekyll官网的github pages介绍</a>上说如果要部署在github上，必须名称叫gh-pages。所以先创建一个叫gh-pages的分支</p>

<h3 id="_2">发布</h3>

<p>使用命令:</p>

<pre class="shell"><code class="shell">$ git add .
$ git commit -a -m &quot;v0.0.1 first blood&quot;</code></pre>

<p>提交所有的修改到本地的git仓库</p>

<h3 id="github">上传到github</h3>

<p>使用命令：</p>

<pre class="shell"><code class="shell">$ git remote add origin https://github.com/(github用户名)/(jekyll项目名称).git
$ git push origin gh-pages</code></pre>

<h3 id="_3">修改后提交</h3>

<p>使用命令：</p>

<pre class="shell"><code class="shell">$ git add .
$ git commit -a -m &quot;自己的提交注释&quot;
$ git push origin gh-pages</code></pre>

<p>第一句增加所有新增的文件到项目中</p>

<p>第二句提交所有修改</p>

<p>第三句将修改提交到远程github服务器</p>

<h3 id="_4">绑定到自己的域名</h3>

<p>如果是绑定到一级域名：</p>

<ol>
<li>首先在项目根目录下创建一个叫CNAME文件，里面写上自己的以及一级域名（如这个博客就是skyinlayer.com）</li>

<li>在DNS中为自己的域名增加一条A记录，指向207.97.227.245</li>

<li>将项目提交到github上，等一会儿（不会超过1小时）</li>

<li>baseurl应该为”/”</li>

<li>访问自己的域名看看结果吧</li>
</ol>

<p>如果是绑定到二级域名，需要额外在DNS中增加一条CNAME，指向(github用户名).github.io，然后再CNAME文件中修改为自己的二级域名即可</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/09/jekyll-5</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用box-shadow绘制像素画 ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/09/box-shadow-pix-image</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 09 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">前面的话</h2>

<p>曾经在codepen.io上看到很多像素画，都是css3实现的，点进去看才知道是使用box-shadow实现的，但是当时并不了解CSS3的box-shadow属性。如今稍微了解了box-shadow属性，并自己绘制了一个超级玛丽</p>

<p>希望实现的效果：</p>

<p><img src="/images/mario.jpg" alt="马里奥" /></p>

<h2 id="boxshadow">box-shadow属性</h2>

<p>首先了解一下CSS3的box-shadow属性</p>

<p><img src="/images/box-shadow.jpg" alt="box-shadow" /></p>

<p>可以看到浏览器的支持还是相当不错的，就连IE也从9就支持了</p>

<p>既然需要画像素画，当然主要是绘制矩形，而使用box-shadow可以很方便的实现。box-shadow属性的值可以为[水平偏移, 垂直偏移 , 阴影颜色]、[水平偏移, 垂直偏移 , 阴影模糊值 ,阴影颜色]或者[水平偏移, 垂直偏移 , 阴影模糊值 , 阴影延长值,阴影颜色]。由于绘制像素画不需要使用模糊效果，所以只要使用第一种格式[水平偏移, 垂直偏移 , 阴影颜色]就可以了。</p>

<p>那使用box-shadow如何绘制多个方块？</p>

<h3 id="_2">定义基础元素</h3>

<p>定义一个div用于作为box-shadow的拥有者：</p>

<pre class="xml"><code class="xml">&lt;div class=&quot;pix&quot;&gt;&lt;/div&gt;</code></pre>

<pre class="css21"><code class="css21">.pix {
    width: 100px;
    height: 100px;
    background-color: red;
}</code></pre>

<p>将它作为最左上角的方块，由于被元素覆盖的box-shadow将不会被显示（就算元素本身的background-color为transparent也不行），颜色直接由background-color属性来确定。关键是定义它的width和height属性，这两个属性决定了每个方块的宽和高。</p>

<p>效果很简单：</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='300' src='http://jsfiddle.net/skyinlayer/56pgb/12/embedded/result' width='100%'>&nbsp;</iframe>
<h3 id="_3">在其四周绘制方块</h3>

<p>首先在其右侧绘制一个与原始大小等大的方块，这就要使用box-shadow属性了。给元素添加box-shadow，并添加一个阴影值<code>100px 0 blue</code>，这样就相当于在该元素的左边100px，绘制了一个与元素等大的颜色为blue的方块。</p>

<p>css代码修改为：</p>

<pre class="css21"><code class="css21">.pix {
    width: 100px;
    height: 100px;
    background-color: red;
    box-shadow: 100px 0 blue
}</code></pre>

<p>效果如下：</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='300' src='http://jsfiddle.net/skyinlayer/56pgb/10/embedded/result' width='100%'>&nbsp;</iframe>
<p>在元素下面绘制一个等大的方块类似，再给box-shadow添加一个值：<code>0 100px blue</code>，css代码修改为：</p>

<pre class="css21"><code class="css21">.pix {
    width: 100px;
    height: 100px;
    background-color: red;
    box-shadow: 100px 0 blue, 0 100px blue
}</code></pre>

<p>效果如下：</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='300' src='http://jsfiddle.net/skyinlayer/56pgb/13/embedded/result' width='100%'>&nbsp;</iframe>
<p>再添加几个，比如以原始元素为[0,0]，添加[2,0],[1,1],[0,2],背景为绿色： 分别在box-shadow中添加三个属性分别表示这三个方块：</p>

<pre class="css21"><code class="css21">.pix {
    width: 100px;
    height: 100px;
    background-color: red;
    box-shadow: 
        100px 0 blue, 
        0 100px blue,
        200px 0 green
        100px 100px green,
        0 200px green;
}</code></pre>

<p>效果如下：</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='300' src='http://jsfiddle.net/skyinlayer/56pgb/14/embedded/result' width='100%'>&nbsp;</iframe>
<p>这里可以看到，完全可以使用box-shadow绘制像素画，每个像素（方块）用一行box-shadow的值表示就可以了</p>

<h2 id="_4">画超级玛丽</h2>

<p>一般画像素画之前需要做点准备：</p>

<ol>
<li>首先需要确定每个像素（格子）的真正大小，一般为方块，这里我取了32X32大小。</li>

<li>然后需要确定整幅图需要格子的行数和列数，可以数一数，横向12格，纵向16格。</li>

<li>如果有范本可以直接一行一行添加格子的box-shadow值，如果直接凭空画，可以把整张图拆分成多个部分进行绘制。甚至拆成多个div，每个div定义自己的box-shadow值</li>
</ol>

<p>既然已经知道使用box-shadow画方块的方法了，自然就可以画超级玛丽了。看最上面的图就可以知道8-bit时代的超级玛丽都是由方块组成，主要有三个颜色：</p>

<ol>
<li>帽子和肚兜（？）的红色：#E6002E</li>

<li>身体的黄色：#F8B600</li>

<li>头发、胡须、衣服、鞋子的深绿色：#808A27 这里通过一行一行的方式进行绘制：</li>
</ol>

<p>一步一步话，先画帽子：</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/s36mK/embedded/result,css,html' width='100%'>&nbsp;</iframe>
<p>接着绘制脸：</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/s36mK/1/embedded/result,css,html' width='100%'>&nbsp;</iframe>
<p>然后绘制身体：</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/s36mK/2/embedded/result,css,html' width='100%'>&nbsp;</iframe>
<p>最后把脚画上：</p>
<iframe allowfullscreen='allowfullscreen' frameborder='0' height='600' src='http://jsfiddle.net/skyinlayer/s36mK/3/embedded/result,css,html' width='100%'>&nbsp;</iframe>
<p>这样就齐活了，以前dos系统或者fc游戏机中的像素画都可以通过这种方式绘制</p>

<p>完整的代码：</p>

<pre class="css21"><code class="css21">.pix {
    width: 32px;
    height: 32px;
    background-color: transparent;
    box-shadow: 
    /*帽子*/ 
    96px 0 #E6002E, 128px 0 #E6002E, 160px 0 #E6002E, 192px 0 #E6002E, 224px 0 #E6002E, 64px 32px #E6002E, 96px 32px #E6002E, 128px 32px #E6002E, 160px 32px #E6002E, 192px 32px #E6002E, 224px 32px #E6002E, 256px 32px #E6002E, 288px 32px #E6002E, 320px 32px #E6002E, 
    /*头*/ 
    64px 64px #808A27, 96px 64px #808A27, 128px 64px #808A27, 160px 64px #F8B600, 192px 64px #F8B600, 224px 64px #808A27, 256px 64px #F8B600, 32px 96px #808A27, 64px 96px #F8B600, 96px 96px #808A27, 128px 96px #F8B600, 160px 96px #F8B600, 192px 96px #F8B600, 224px 96px #808A27, 256px 96px #F8B600, 288px 96px #F8B600, 320px 96px #F8B600, 32px 128px #808A27, 64px 128px #F8B600, 96px 128px #808A27, 128px 128px #808A27, 160px 128px #F8B600, 192px 128px #F8B600, 224px 128px #F8B600, 256px 128px #808A27, 288px 128px #F8B600, 320px 128px #F8B600, 352px 128px #F8B600, 32px 160px #808A27, 64px 160px #808A27, 96px 160px #F8B600, 128px 160px #F8B600, 160px 160px #F8B600, 192px 160px #F8B600, 224px 160px #808A27, 256px 160px #808A27, 288px 160px #808A27, 320px 160px #808A27, 96px 192px #F8B600, 128px 192px #F8B600, 160px 192px #F8B600, 192px 192px #F8B600, 224px 192px #F8B600, 256px 192px #F8B600, 288px 192px #F8B600, 
    /*身体*/ 
    64px 224px #808A27, 96px 224px #808A27, 128px 224px #E6002E, 160px 224px #808A27, 192px 224px #808A27, 224px 224px #808A27, 32px 256px #808A27, 64px 256px #808A27, 96px 256px #808A27, 128px 256px #E6002E, 160px 256px #808A27, 192px 256px #808A27, 224px 256px #E6002E, 256px 256px #808A27, 288px 256px #808A27, 320px 256px #808A27, 0px 288px #808A27, 32px 288px #808A27, 64px 288px #808A27, 96px 288px #808A27, 128px 288px #E6002E, 160px 288px #E6002E, 192px 288px #E6002E, 224px 288px #E6002E, 256px 288px #808A27, 288px 288px #808A27, 320px 288px #808A27, 352px 288px #808A27, 0px 320px #F8B600, 32px 320px #F8B600, 64px 320px #808A27, 96px 320px #E6002E, 128px 320px #F8B600, 160px 320px #E6002E, 192px 320px #E6002E, 224px 320px #F8B600, 256px 320px #E6002E, 288px 320px #808A27, 320px 320px #F8B600, 352px 320px #F8B600, 0px 352px #F8B600, 32px 352px #F8B600, 64px 352px #F8B600, 96px 352px #E6002E, 128px 352px #E6002E, 160px 352px #E6002E, 192px 352px #E6002E, 224px 352px #E6002E, 256px 352px #E6002E, 288px 352px #F8B600, 320px 352px #F8B600, 352px 352px #F8B600, 0px 384px #F8B600, 32px 384px #F8B600, 64px 384px #E6002E, 96px 384px #E6002E, 128px 384px #E6002E, 160px 384px #E6002E, 192px 384px #E6002E, 224px 384px #E6002E, 256px 384px #E6002E, 288px 384px #E6002E, 320px 384px #F8B600, 352px 384px #F8B600, 64px 416px #E6002E, 96px 416px #E6002E, 128px 416px #E6002E, 224px 416px #E6002E, 256px 416px #E6002E, 288px 416px #E6002E, 
    /*脚*/ 
    32px 448px #808A27, 64px 448px #808A27, 96px 448px #808A27, 256px 448px #808A27, 288px 448px #808A27, 320px 448px #808A27, 0px 480px #808A27, 32px 480px #808A27, 64px 480px #808A27, 96px 480px #808A27, 256px 480px #808A27, 288px 480px #808A27, 320px 480px #808A27, 352px 480px #808A27;
}</code></pre>

<h2 id="_5">总结</h2>

<p>使用box-shadow绘制像素画好处就是思路很简单，易于实现</p>

<p>但坏处也很多，绘制精细的绘画肯定是要完蛋的。同时庞大的css代码量导致加载速度变得很慢。所以一般情况下，可以直接通过div+css等现行进行大体的绘制，需要一些特殊小图形的时候才使用像素画绘制。同时像素画也可以通过写脚本动态的生成。免去了手动敲CSS的麻烦</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/09/box-shadow-pix-image</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（文章分类索引） ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/06/jekyll-4</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 06 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>系列文章传送门：</p>

<p><a href="http://skyinlayer.com/blog/2014/01/25/jekyll-1/">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>

<p><a href="http://skyinlayer.com/blog/2014/01/27/jekyll-2/">使用Jekyll在Github上搭建个人博客（博客编写）</a></p>

<p><a href="http://skyinlayer.com/blog/2014/02/06/jekyll-3/">使用Jekyll在Github上搭建个人博客（分页实现）</a></p>

<p>今天又滚出去野了一天，打牌输了，好在输的不多，聊天聊到了以后的路子，不太好走啊</p>

<h2 id="category">使用Category分类</h2>

<p>一般来说，一个个人博客的文章会分为很多种，比如说有记录生活情感的、技术交流的、转载他人的等等，而在jekyll中，可以使用Category进行分类，使用方法非常简单</p>

<h3 id="">为文章定义分类</h3>

<p>首先要确定文章属于哪个分类。这个配置可以设置在文章的头信息中，使用category或者categories确定，如文章属于“test”类别：</p>

<pre><code>---
layout: MyTemplate
title: Category Sample
category: test
---</code></pre>

<p>或者使用categories，这个属性接受一个数组，代表这篇文章所述的类，如文章属于“test”和“sample”类别：</p>

<pre><code>---
layout: MyTemplate
title: Category Sample
categories: [test, sample]
---</code></pre>

<p>加入这些信息后，文章所属分类就定义好了。但是还需要在页面（或者模板）中输出分类所有的文章才能完成以分类为基础的索引功能</p>

<h3 id="_2">输出所有分类</h3>

<p>所有的分类信息都被存储在site对象的categories中，所以可以通过liquid的for标签进行输出：</p>

<pre class="xml"><code class="xml">{% for category in site.categories %}
&lt;h2&gt;{{ category | first }}&lt;/h2&gt;
&lt;/span&gt;{{ category | last | size }}&lt;/span&gt;
&lt;ul class=&quot;arc-list&quot;&gt;
    {% for post in category.last %}
        &lt;li&gt;{{ post.date | date:&quot;%d/%m/%Y&quot;}}&lt;a href=&quot;{{ post.url }}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;
    {% endfor %}
&lt;/ul&gt;
{% endfor %}</code></pre>

<p>上面代码可以看到，首先从site中取出所有categories的信息，分别输出。categories的元素为一个两个元素的数组，第一个元素为category的名字，第二个元素则为一个数组，保存有该分类下文章的列表</p>

<p>于是乎就很简单了：</p>

<ul>
<li>使用<code>{{ category | first }}</code>输出分类的名称</li>

<li>使用<code>{{ category | last | size }}</code>输出该分类下文章的数目</li>

<li>遍历category.last输出所有文章的信息，构建到该文章的索引</li>
</ul>

<p>这样就完成了在一个页面上输出所有分类，及其所有文章索引的方法了。但是需要注意的是，这种方式只能获取所有分类，而不能获取某个单一分类下的文章。毕竟jekyll编译完成后是静态页面，没有办法动态生成（除非为每一个分类都创建一个html文件，并在首页上创建一大堆通向这些html文件的a标签）。事实上，这个问题有一个解决方法是使用jekyll插件去解决。但是github不支持三方jekyll插件。所以必须绕个弯子来实现这种方式</p>

<h3 id="_3">输出单个分类下的所有文章</h3>

<p>我们可以轻松获得所有分类下的所有文章，但是没有办法只输出一个分类下的文章。</p>

<p>首先可以想到的解决方法方法：首先把所有分类和所有文章的html生成好，然后全部隐藏。把需要显示的分类的名称放在url中，使用javascript读取名称出来后根据名称显示该分类。这样做有一个坏处：如果文章数较多，而每个文章都有很多分类，那么就会出现html文件很大，加载很慢的情况。</p>

<p>于是乎又想到一种方法，将所有的数据压缩在JSON中，然后通过javascript解析JSON对象，然后动态生成html。这种方法不过是一个折中，如果需要生成的html较为复杂，完全可以使用第一种方法。但如果只是简单的索引，这种方法就足够了。根据需要考量吧。下面放一点简单的源码来介绍一下这种方法：</p>

<pre class="javascript"><code class="javascript">var dataStr = &#39;{ {% for cat in site.categories %}{% if cat[0] != site.categories.first[0] %},{% endif %}&quot;{{ cat[0] }}&quot;:[{% for post in cat[1] %}{% if post != cat[1].first %},{% endif %}{&quot;url&quot;:&quot;{{post.url}}&quot;, &quot;title&quot;:&quot;{{post.title}}&quot;, &quot;date&quot;:&quot;{{post.date | date:&quot;%d/%m/%Y&quot;}}&quot;}{% endfor %}]{% endfor %} }&#39;,
    data = JSON.parse(dataStr),
    curTag = $.query.get(&quot;cat&quot;),
    archieves = data[curTag];</code></pre>

<p>首先通过上面介绍过的方法构建JSON字符串，这里只是一个模板，读取了所有分类，并以分类名称为key，文章列表为value构建了一个对象。文章列表的元素也是一个对象，有date，url，title三个值，分别表示文章的日期、url路径、标题，帮助生成索引。解析完之后就可以通过url中的category的名称取出来了。这里使用了一个叫jQuery.query的插件，专门取url的参数并进行包装。</p>

<p>综上所述，比如只显示单一分类的页面叫showCategory.html，要显示java分类，那么首页中给个a标签，href为<code>/showCategory.html?cat=java</code>就行了，方便快捷（笑）</p>

<h3 id="_4">类别为中文时问题</h3>

<p>Windows下，使用UTF-8编码时当category为中文时，在通过url进入文章时，会出现如下错误</p>

<pre><code>Internal Server Error
&quot;\xAE\xBE&quot; from GBK to UTF-8</code></pre>

<p>我并不知道这个编码为何会需要从GBK转换为UTF-8，所以只能通过其他方式进行避开。网上应该会有人解答这个问题，需要进一步去查了，这里讲一下我怎么避开的吧</p>

<p>首先介绍一下jekyll的Permalinks这个配置，这个配置定义了文章被jekyll处理后生成结果的最终路径，默认为<code>/:categories/:year/:month/:day/:title.html</code>，也就是说，如一篇文章叫“2014-2-6-this-is-a-title.md”，在文章中定义的文类为[测试, new]，那么最终这篇文章的路径将会是“_site/测试/new/2014/02/06/this-is-a-title.html”，也就是说如果category为中文名称的话，中文将会出现在url中。然后就会根据中文去jekyll的action中索引，然后导致错误。</p>

<p>避开方法就是去掉根据permlinks中的categories，因为一般情况下根据时间来生成文件夹就已经够了，在_config.yml中新增一行：</p>

<pre><code>permalink: /:year/:month/:day/:title</code></pre>

<p>规则可以自己定，具体参照<a href="http://jekyllrb.com/docs/permalinks/">jekyll的Permlinks配置介绍页面</a>，别出现categories就行了</p>

<h2 id="_5">使用文章标签索引文章</h2>

<p>现在很多博客都支持给文章添加标签，表示这篇文章具体是哪几方面的技术。jekyll也是支持标签的，而且不需要额外的插件。使用方法和categories类似</p>

<h3 id="_6">给文章添加标签</h3>

<p>文章中的标签配置使用tags来定义，内容为一个数组，放在文章的头中，如本文的标签定义：</p>

<pre><code>---
layout: MyTemplate
title: 使用Jekyll在Github上搭建个人博客（文章分类索引）
tags: [github, jekyll]
---</code></pre>

<h3 id="_7">输出所有标签</h3>

<p>一般情况下，标签与文章为很复杂的多对多关系，所以如果生成所有标签及含有该标签的所有文章，html将会非常庞大，所以一般只是生成所有的标签，然后通过点击标签到达该标签的索引页面，页面中仅显示含有该标签的文章。</p>

<p>输出所有标签，可以通过liquid的for标签遍历site.tags来实现：</p>

<pre class="xml"><code class="xml">{% for tag in site.tags %}
    &lt;a href=&quot;/show_by_tag.html?tag={{ tag[0] }}&quot;&gt; {{ tag[0] }}&lt;/a&gt;
{% endfor %}</code></pre>

<p>tag[0]是标签的名称</p>

<h3 id="_8">输出含有某标签的所有文章数</h3>

<p>实现思路和上面categories一样，先生成JSON字符串再通过javascript动态生成html，具体代码：</p>

<pre class="javascript"><code class="javascript">var dataStr = &#39;{ {% for tag in site.tags %}{% if tag[0] != site.tags.first[0] %},{% endif %}&quot;{{ tag[0] }}&quot;:[{% for post in tag[1] %}{% if post != tag[1].first %},{% endif %}{&quot;url&quot;:&quot;{{post.url}}&quot;, &quot;title&quot;:&quot;{{post.title}}&quot;, &quot;date&quot;:&quot;{{post.date | date:&quot;%d/%m/%Y&quot;}}&quot;}{% endfor %}]{% endfor %} }&#39;,
    data = JSON.parse(dataStr),
    curTag = $.query.get(&quot;tag&quot;),
    archieves = data[curTag];</code></pre>

<p>这里还是一样，使用jQuery.query插件获取url中的参数，和上面的<code>&lt;a href=&quot;/show_by_tag.html?tag={{ tag[0] }}&quot;&gt; {{ tag[0] }}&lt;/a&gt;</code>相对应</p>

<p>标签没有字符集问题，放心使用吧</p>

<h2 id="_9">总结</h2>

<p>文章的分类其实实现并不难，但是需要绕点小弯子。如果有更好的不需要使用插件的方法希望能告知我，感激不尽</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/06/jekyll-4</guid>
            </item>
        
            <item>
                <title><![CDATA[ 【转载】入静和入世 ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/05/repost-rujingyurushi</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 05 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>本文为转载，<a href="http://home.wangjianshuo.com/cn/20120801_eae-3.htm">原文地址</a></p>

<p>本文受Paul Graham的Maker’s Schedule, Manager’s Schedule启发而作，建议大家有空去读一下。</p>

<p>人有两种思考状态，我将一种称为入静，另一种称为入世。</p>

<h3 id="">入静</h3>

<p>程序员和作家需要的是一种入静的状态。他们需要整段的，不被打扰的时间才可以工作。一个下午三点种的会议，哪怕仅仅持续15分钟，一个下午就会因此废了。问题不是会议占据的时间，关键问题是会议把一个下午分成了两块，让每块都不够大，都不足以入静。因为对于下午废掉的担心，上午的工作也受到影响，不太敢开始解决真正困难的问题。所以整天都在一种心神不宁的状态。</p>

<p>人的大脑远没有我们想象的那么简单。那是非常精密的，需要我们细心体会的工作状态。一个典型的程序员的一天是这样的：</p>

<pre><code>早上想到今天有一整天的整块时间，能够躲在一个不受打扰的地方开始写代码，想想就是件高兴的事情。然后开始打开代码，开始看，开始象电脑一样处理，慢慢的，世界安静了，问题浮现了，头脑里的问号产生了。怎么解决呢？怎么解决呢？怎么解决呢？。。。。开始思考了。开始发呆了。。。开始写点东西，跑一跑，又引入了一个新的问号。。。这就是入静的状态。</code></pre>

<p>在足够长的思考这件事情的空余，或许要上一下厕所，在路上遇到同时打招呼，但脑子还在那个状态，打招呼的是谁不记得了，也不想去注意，以免思路被打乱。然后回到座位上，脑子里其实彻底没有去过厕所的记忆，而继续思考。。。中午吃饭的时候，如果一个人最好，接着在那个状态里。。。或者随便聊点轻松的话题，并没有大碍，只要不是动脑筋的东西。这样下午可以相对容易的回到短暂离开的状态。因为我们的明意识在放松，潜意识其实还在连续的工作。</p>

<p>这种入境的状态就像睡觉。需要足够长的时间才能进入状态。我想大家都能理解凌晨三点的一个电话对于睡眠意味着什么吧。</p>

<p>在会多的公司，程序员会自己觉得效率特低，归罪于会多，其实不是会多，而是打断。</p>

<h3 id="_2">入世</h3>

<p>还有另外一种人，姑且叫做入世的人。他们的时间是按小时划分的，每个小时总要换一个会，在哪里和谁开会不重要，重要的是过一个小时一定有会。如果在两个会之间空出来一个小时，这一个小时反而是浪费时间，一定要想办法填满。找谁聊聊呢？给谁打个电话呢？旅游者是这种工作方式的极致表现。到一个地方仅有的几十个小时，一定要用活动填满，每一个小时一定要换一个地方，才能够不辜负大老远来一趟。经理，商人，投资人，甚至服务员都是这种状态。很难想象一个卖菜的不和人打交道而仅仅静思会有生计。一个证券交易员哪怕十分钟不和另外的人发生交易就会亏钱，商人必须不断的和人打交道，认识其他的商人，才能有足够的消息。经理们更多的是在协调资源，而不是创造新的东西，他们，需要用入世的方式工作。</p>

<p>两个处于入世状态的人很容易约会，甚至容易约一些没有特别目的的会，“好久不见了。聚聚？” “好呀，喝杯茶吧。”这种会议常常能产生意想不到的产出，主要原因是，切换思维状态，对于入世的人来说，成本太低了，而对于入静状态的人简直就是灾难。</p>

<h3 id="_3">入世和入静</h3>

<p>我们其实都需要两种状态。读书就需要入静，需要相对长一点的时间。沟通就需要入世，需要高效的和人打交道。不同的工作需要不同的状态。我们需要明了这种区别，不要在两种状态频繁切换。一个礼拜可以把会集中在一起，好让自己定期给自己些完全没有会的闭关时间，这样才会平衡。</p>

<p>最后，要给身边有程序员的同学们和经理们提个醒：请大家一定要理解程序员的工作状态，不要在一天的中间安排会议。当看到一个程序员冥思苦想的时候，不要过去打扰，甚至在极端的情况下，一句友好的问候都是多余的。</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/05/repost-rujingyurushi</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（分页实现） ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/05/jekyll-3</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 05 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>系列文章传送门：</p>

<p><a href="http://skyinlayer.com/blog/2014/01/25/jekyll-1/">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>

<p><a href="http://skyinlayer.com/blog/2014/01/27/jekyll-2/">使用Jekyll在Github上搭建个人博客（博客编写）</a></p>

<p>之前已经介绍了如何搭建环境和如何创建整个博客项目，并编写了博文，这篇文章主要就是介绍分页功能如何通过jekyll实现。</p>

<h3 id="">前言</h3>

<p>一个博客不可能只有几篇文章，如果所有文章全部放在一个页面中，在文章不多的情况下也许较为直观，一旦文章数量增加，不仅加大了用户需要加载的数据量，也为用户检索文章造成了障碍，所以基本上每个博客都会有文章的分页。一般的分页都是通过像JSP的模板引擎直接在从数据库中分页取出时生成动态生成页面，或者通过ajax从数据库分页取出传递到前端。但现在github+jekyll是静态的页面，没有数据库。好在jekyll支持分页功能</p>

<h3 id="_2">开启分页功能</h3>

<p>首先我们需要在jekyll中开启分页功能，在jekyll的_config.yml中加入分页配置：</p>

<pre><code>paginate: 5
paginate_path: &quot;page:num&quot;</code></pre>

<p>第一行定义了每页的文章数量，而第二行则定义了在分页的结果，比如在/index.html中使用分页，定义为page:num，则第二页的路径将是/page2/index.html，第三页的路径将是/page3/index.html，以此类推</p>

<p>需要注意的几个点：</p>

<ul>
<li>分页只在html文件中起作用</li>

<li>paginate_path同时定义了需要被分页的文件，本人测试这个叫index.html，具体目录由paginate_path中的路径定义，如果定义的目录没有，则会向上寻找index.html，直到根目录的index.html，具体机制官网上没有详细说，所以还需要进一步实验</li>
</ul>

<h3 id="_3">使用分页</h3>

<p>只是开启了分页还没有用，我们需要确实使用到首页之中，在首页(/index.html)中添加如下代码：</p>

<pre class="xml"><code class="xml">{% for post in paginator.posts %}
    &lt;a href=&quot;{{ post.url }}&quot;&gt;{{ post.title }}&lt;/a&gt;
{% endfor %}</code></pre>

<p>这样，jekyll就会根据paginator来进行分页了，被分出来多少页，就会有多少个页面生成。排1-5的文章就在/index.html中了，而排6-10的文章则在/page2/index.html中，依次类推</p>

<h3 id="_4">换页</h3>

<p>只是分页还不够，我们还需要在每个页面上做一个跳转到其他页面的导航，这里需要用到paginator的一些其他属性</p>

<p>首先检测总的页数，如果只有一页，自然就不需要分页了。通过paginator的<code>total_pages</code>属性能判断总页数：</p>

<pre class="xml"><code class="xml">{% if paginator.total_pages &gt; 1 %}
&lt;!-- 分页代码 --&gt;
{% endif %}</code></pre>

<p>我们需要一个跳转到上一页的按钮，这个按钮在第一页不需要显示，通过paginator的<code>previous_page</code>属性来判断是否是第一个页面，使用paginator的<code>previous_page_path</code>来输出上一页的路径，注意在前面添加baseurl，并进行一些必要的字符替换：</p>

<pre class="xml"><code class="xml">{% if paginator.previous_page %}
    &lt;a href=&quot;{{ paginator.previous_page_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;上一页&lt;/a&gt;
{% endif %}</code></pre>

<p>接着是生成所有页面的按钮，并使当前页按钮无效化，遍历所有页面，使用paginator的<code>page</code>属性来确定当前页，如果是当前页，则按钮无效，否则使用<code>{{ site.paginate_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; | replace: &#39;:num&#39;, page }}</code>来将:num替换成当前页面的数字生成页面路径：</p>

<pre class="xml"><code class="xml">{% for page in (1..paginator.total_pages) %}
    {% if page == paginator.page %}
      &lt;span class=&quot;active&quot;&gt;{{ page }}&lt;/span&gt;
    {% elsif page == 1 %}
      &lt;a href=&quot;{{ &#39;/index.html&#39; | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;&gt;{{ page }}&lt;/a&gt;
    {% else %}
      &lt;a href=&quot;{{ site.paginate_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; | replace: &#39;:num&#39;, page }}&quot;&gt;{{ page }}&lt;/a&gt;
    {% endif %}
{% endfor %}</code></pre>

<p>最后生成一个下一页的按钮，在最后一页不显示，和上一页按钮类似，通过paginator的<code>next_page_path</code>来确定是否还有下一页：</p>

<pre class="xml"><code class="xml">{% if paginator.next_page %}
    &lt;a href=&quot;{{ paginator.next_page_path | prepend: site.baseurl | replace: &#39;//&#39;, &#39;/&#39; }}&quot;&gt;下一页&lt;/a&gt;
{% endif %}</code></pre>

<p>这样一个完整的分页导航功能就做好了，效果就和博客主页上的分页效果是一样的</p>

<h3 id="_5">总结</h3>

<p>jekyll的分页总的来说还算给力，基本的功能可以完成。但是有一些缺陷，就是category，tag的分类分页无法实现，必须通过插件的方式来做。但是github不允许三方插件，所以只能通过一些其他的方式实现了</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/05/jekyll-3</guid>
            </item>
        
            <item>
                <title><![CDATA[ 再见，蛇年！你好，马年！ ]]></title>
                <link>http://skyinlayer.com/blog/2014/02/03/new-year</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 03 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="">辞旧岁</h2>
<hr />
<p>过年在老家闲得无聊，回头又翻了一下自己这一年来的微博，这一年来写的一些读书笔记啥的。感叹时光荏苒，岁月如梭。感觉自己进入研究生来并没有过了多久，可如今快是研二下学期了。这个2013年算是收获相当大的一年。</p>

<h3 id="javassh">Java+SSH</h3>

<p>遥想一年之前，刚刚结束研究生生涯满是课程的第一个学期，基本上也没干什么事，就是初步学习了一下SSH(struts+spring+hibernate)。至于前端内容还完全没有涉及。对Java+SSH也仅仅停留在一个实验阶段。并没有实际的融入到实验室的项目之中。记得当时用SSH自己写了一个Java的博客，但是无奈前端技能太差，写出来的页面丑的不堪入目，而使用的一些模板也是完全看不懂CSS和JavaScript导致无法修改。后来也就放弃了，不过也算是使用SSH搭的第一个项目，也算是懂了SSH和JSP的基本知识，收获颇多。之后融入了实验室项目之后，在学长的带领下，协助开发了基于iReport+JasperReport的报表系统，可以说是一次相当好的Java练兵。</p>

<p>读了的相关的书：</p>

<ol>
<li>《轻量级Java EE企业应用实战 —— Struts 2＋Spring＋Hibernate整合开发》–李刚</li>

<li>《Java编程思想》——（美）埃克尔著 陈昊鹏 译</li>
</ol>

<h3 id="python">Python</h3>

<p>当时还自学了一点python，买了好几本书，也看了不少。记得玩的是pyqt，当时在用pyqt写一个浏览器。而就是这个python的小玩意，让我接触了脚本语言，并深刻被脚本语言的简洁、优美所震撼。当时实验室导师还说，以后会用到python，很鼓励学来着，后来完全没有用到过，呵呵呵呵呵….于是乎python在正式进入实验室项目之后，就没再接触Python了，挺遗憾的。而在其中接触的Qt4的知识如今也基本上还给上帝了，但那段时间过得相当快乐，完全是出于自己的爱好去做自己想做的事，没有什么束缚也没有什么压力</p>

<p>读了的相关的书：</p>

<ol>
<li>《Python学习手册》——[美] 鲁特兹（Mark Lutz） 著 李军，等 译</li>

<li>《Python核心编程》——[美] 丘恩（Chun,W.J.） 著 宋吉广 译</li>

<li>《精通Qt4编程》——蔡志明等 著</li>
</ol>

<h3 id="_2">设计模式</h3>

<p>记得读设计模式的书都是大半夜躺床上读的，当时没买ipad mini，就把电子书下载到手机里，由于屏幕分辨率太低，就把手机横过来看的，屏幕里只能显示差不多1/3页。读的四人帮的设计模式，虽然页数不多，但由于太过抽象，强行读了一点就崩溃了。于是乎买了本Head First设计模式，虽然里面图很多，占了相当大的篇幅，但那种亲切的讲述方式，确实相对死板的概念更容易接受，不过里面并没有将所有的设计模式讲全。读完之后又重新回头结合Java编程思想里面的一些与之相关的内容沉淀了一下，收获丰富啊。这也为后来学习JavaScript模式里面的知识打了基础</p>

<p>读了的相关的书：</p>

<ol>
<li>《Head First设计模式》——[美] 弗里曼（Freeman,E.），等 著 UML China 编 OReilly Taiwan公司 译</li>

<li>《设计模式：可复用面向对象软件的基础》——Erich Gamma，等 著 刘建中，等 译</li>

<li>《大话设计模式》–程杰 著</li>
</ol>

<h3 id="_3">前端知识</h3>

<p>学习前端知识虽然开始的很早，但前期都是小打小闹，知识也零零散散。读了《Head First HTML与CSS》，虽然并没有太详细的知识，但也算是对HTML和CSS有了一个基本的了解。</p>

<p>而之后读了Nicholas C.Zakas大神写的《JavaScript高级程序设计》，可以说是看这书入门的javascript。有的人推荐大犀牛——《JavaScript权威指南》，我倒不这么看，那本书感觉作为手册倒是更好，不适合作为初学者入门。</p>

<p>在读完之后，又仔细的研读了[汤姆大叔的深入理解JavaScript系列](http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html)和[JavaScript秘密花园](http://bonsaiden.github.io/JavaScript-Garden/zh/)，深入学习了JavaScript，深刻理解了JS与其他语言的不同，体会到了其中的糟粕和精华。汤姆大叔的系列博客也导致我买了他翻译的《JavaScript编程精解》，而其中的知识也是相当的精辟，但是书的价格，呵呵</p>

<p>之后看的一些其他书，小犀牛书（JavaScript学习指南）感觉没什么油水，而鹧鸪书（JavaScript模式）则是相当的不错，里面讲了JavaScript特有的代码模式和设计模式，可以说字字珠玑，而JSON创始人Douglas Crockford的蝴蝶书（JavaScript语言精粹）讲的也是相当不错，里面的轨道图印象深刻啊。至于HTML和CSS之后读了《精通CSS+DIV网页样式与布局》，也算是了解了HTML和CSS的一些基础知识。之后也进行了相当多的尝试。编写了一些[简单的jQuery插件](https://github.com/LingyuCoder/wlyUI)。</p>

<p>就大概在这个时候，开启了我第一个真正的个人项目：XMPP的Web IM，这是一段相当长的时间，本来是实验室要做一个web im，我就研究了一下，后来导师又说取消了，但我觉得这一方面相当有趣，于是乎我以个人兴趣为驱动细细钻研XMPP协议和Web IM，编写出了一个完整的Web IM，可以说是这一年最有意义的内容了，而这也直接导致我的研究生毕业设计也变成了Web IM相关</p>

<p>在把Web IM基本功能完工以后，本着广撒网的态度，又开始接触CSS3和HTML5了，写了一些CSS3的动画，并结合JavaScript写了一些小玩意，比如[小玩意里面的时钟](http://skyinlayer.com/items.html)和[可翻页的书籍](http://skyinlayer.com/about.html)，差不多同一时间，又开始玩LESS，深刻体会到了CSS3的美妙和美好的未来，但也撞到了前端之路的大障碍：浏览器兼容性</p>

<p>HTML5主要则是钻研了canvas，感觉canvas给了浏览器无限的可能，初步使用canvas在页面上写了一个[RPG引擎](https://github.com/LingyuCoder/HTML5_GAME)，使用炎龙骑士团II黄金城之谜的图片素材（好吧，我不盈利，求不告我侵权），只是完成了其中的一些基础模块：人物移动、战斗系统、物品系统、装备系统、场景切换、剧情事件、NPC及对话等等，后来由于实验室项目上的一些其他事情就搁置了，后续我会尝试编写一个完整的游戏出来，不过不知道要到什么时候了</p>

<p>就是这些经历，让我深深爱上了前端，而立志做一个前端工程师。对自己的未来也相当期待，希望能找到像阿里之类前端很强的公司</p>

<p>读了的相关的书：</p>

<ol>
<li>《Head First HTML与CSS》——Elisabeth Robson，Eric Freeman 著 徐阳，丁小峰，等 译</li>

<li>《JavaScript高级程序设计》——Nicholas C.Zakas 著 李松峰，曹力 译</li>

<li>《JavaScript语言精粹》——Douglas Crockford（道格拉斯·克罗克福德） 著 赵泽欣，等 译</li>

<li>《JavaScript编程精解》——[美] Marijn Haverbeke 著 徐涛 译</li>

<li>《基于MVC的JavaScript Web富应用开发》——[美] Alex MacCaw 著 李晶,张散集 译</li>

<li>《JavaScript模式》——[美] 斯托扬·斯特凡洛夫 著 陈新 译</li>

<li>《JavaScript学习指南》——[美] Shelley Powers 著 谢春祥 译</li>

<li>《精通CSS+DIV网页样式与布局》——前沿科技 编</li>
</ol>

<h3 id="nodejs__mongodb">Node.js + MongoDB</h3>

<p>之前学长学姐有研究NodeJS，服务器端的JavaScript对我这种人来说确实相当有吸引力。出于个人的爱好，开始了自学NodeJS这个年轻的语言。这个学习过程就是读的BYVoid的Node书入门，之后基本上就是看API，看文档了。在朴灵的《深入浅出Node.js》出来之前，使用有限的Node知识，写了一个[多人管理的博客系统](https://github.com/LingyuCoder/NodeBlog)，支持在线写文章、评论、点赞、回复等功能。之后使用实验室的电脑搭建了自己的博客，可惜后来服务器被没收了，又没有找到合适的空间，于是乎就没再弄了。而express、async等等的使用经验却不会消失</p>

<p>在编写博客系统的时候，本着好奇的态度，又自学了MongoDB，将博客的数据库定为MongoDB。并用NodeJS实际操作了MongoDB，这个经验相当宝贵，但MongoDB还没有系统的学习，只是通过网上的资料学了个基础，不过书已经到位，就等翻开了</p>

<p>读了的相关的书：</p>

<ol>
<li>《Node.js开发指南》——BYVoid 著</li>

<li>《JavaScript异步编程：设计快速响应的网络应用》——[美] Trevor Burnham 著 许青松 译</li>
</ol>

<h2 id="_4">迎新年</h2>
<hr />
<p>去年的收获相当多啊，主要还是本着广撒网的态度，什么都去学，什么都去接触。但新的一年，有了明确的目的：找一个好工作。这是决定未来的一年，今年要为找实习，找工作做好面试笔试的准备。而之前和学长聊天的过程中，也总结出我还需要补充的一些知识：</p>

<ol>
<li>CSS的跨浏览器兼容问题</li>

<li>TCP/IP协议</li>

<li>HTTP协议</li>

<li>java的类对象，泛型和多线程</li>

<li>算法</li>

<li>…</li>
</ol>

<p>这些都要在近期去学习，这样有针对性的学习应该还是会很有效率的。</p>

<p>面试题啊，面经什么的也要开始看了，了解各个公司的现状，未来发展趋势也是相当重要。面试题还是需要相当大的积累，而如今我立志做前端工程师，面试题也会相当的详细，所以一些比较常见的方面比如JavaScript的原型、作用域什么的可定要回头再重新看看。CSS的position、float、display等等一些常见属性也要上MDN重新详细的看看。</p>

<p>同时，实验室的工作还是不能遗漏，该完成的功能必须完成，该修改的bug也要尽力去修正。而负责的模块的文档也要写出来，并且将我负责的所有内容，传承给学弟学妹。之前递交的两个本科毕业设计课题也需要精力去指导</p>

<p>还有一个问题，就是自己的研究生毕业设计问题，开的题目代码量比较大，虽然有一部分在之前的Web IM中实现了，可以直接复用。但还有很多扩展功能并没有实现，比如WebRTC之类的还需要特别调研，工作量略大啊</p>

<p>看来，新的一年，将会是忙碌的一年，也将是决定命运的一年。在这里，祝自己能找个好实习，然后顺顺利利的找个心仪的好工作吧，O(∩_∩)O哈哈~</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/02/03/new-year</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用jQuery监听DOM元素大小变化 ]]></title>
                <link>http://skyinlayer.com/blog/2014/01/28/jquery-resize</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 28 Jan 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h3 id="">起因</h3>

<p>今天写页面的时候突然有这么个需求，由于父元素（一个DIV）的height是由javascript计算出来的固定的值，而在其中增加了一个多说插件，在用户评论后，子元素（DIV）的height属性增加，导致子元素溢出。但是又不知道如何为多说的评论按钮增加回调函数，于是乎就想到了根据子元素的大小变化来重新计算父元素的height。</p>

<h3 id="onresize">onresize?</h3>

<p>平常，都是在整个浏览器窗口变化时触发一个修改布局的回调函数。使用的是window对象的resize事件，利用：</p>

<pre class="javascript"><code class="javascript">window.onresize = callback;</code></pre>

<p>来绑定。但根据resize事件的target是<code>defaultView (window)</code>，这里详见<a href="https://developer.mozilla.org/en-US/docs/Web/Reference/Events/resize">MDN的resize文档</a>，也就是说只有window对象有resize事件，于是乎就想到使用jQuery自己的事件机制来模拟一个普通元素上的resize事件</p>

<h3 id="jquery">使用jQuery事件的实现思路</h3>

<p>可以想到一种比较简单的方式：</p>

<ol>
<li>在元素绑定resize对象时，记录元素的width和height</li>

<li>使用requestAnimationFrame、setTimeout、setInterval，每隔一段时间查询其width和height，如果和记录的width和height不一样，运行回调函数并更新记录中的width为height</li>
</ol>

<h3 id="jquery_2">jQuery插件</h3>

<p>这个功能Ben Alman编写了一个jQuery插件，<a href="http://benalman.com/projects/jquery-resize-plugin/">这是传送门</a> 该插件的代码（核心部分），详细代码请查看<a href="https://raw.github.com/cowboy/jquery-resize/v1.1/jquery.ba-resize.js">Ben Alman博客</a>的内容：</p>

<pre class="javascript"><code class="javascript">(function($, window, undefined) {
  var elems = $([]),
    jq_resize = $.resize = $.extend($.resize, {}),
    timeout_id,
    str_setTimeout = &#39;setTimeout&#39;,
    str_resize = &#39;resize&#39;,
    str_data = str_resize + &#39;-special-event&#39;,
    str_delay = &#39;delay&#39;,
    str_throttle = &#39;throttleWindow&#39;;
  jq_resize[str_delay] = 250;
  jq_resize[str_throttle] = true;
  $.event.special[str_resize] = {
    setup: function() {
      if (!jq_resize[str_throttle] &amp;&amp; this[str_setTimeout]) {
        return false;
      }
      var elem = $(this);
      elems = elems.add(elem);
      $.data(this, str_data, {
        w: elem.width(),
        h: elem.height()
      });
      if (elems.length === 1) {
        loopy();
      }
    },
    teardown: function() {
      if (!jq_resize[str_throttle] &amp;&amp; this[str_setTimeout]) {
        return false;
      }
      var elem = $(this);
      elems = elems.not(elem);
      elem.removeData(str_data);
      if (!elems.length) {
        clearTimeout(timeout_id);
      }
    },
    add: function(handleObj) {
      if (!jq_resize[str_throttle] &amp;&amp; this[str_setTimeout]) {
        return false;
      }
      var old_handler;
      function new_handler(e, w, h) {
        var elem = $(this),
          data = $.data(this, str_data);
        data.w = w !== undefined ? w : elem.width();
        data.h = h !== undefined ? h : elem.height();
        old_handler.apply(this, arguments);
      }
      if ($.isFunction(handleObj)) {
        old_handler = handleObj;
        return new_handler;
      } else {
        old_handler = handleObj.handler;
        handleObj.handler = new_handler;
      }
    }
  };

  function loopy() {
    timeout_id = window[str_setTimeout](function() {
      elems.each(function() {
        var elem = $(this),
          width = elem.width(),
          height = elem.height(),
          data = $.data(this, str_data);
        if (width !== data.w || height !== data.h) {
          elem.trigger(str_resize, [data.w = width, data.h = height]);
        }
      });
      loopy();
    }, jq_resize[str_delay]);
  }
})(jQuery, this);</code></pre>

<p>jQuery为jQuery插件的开发者提供了添加自定义事件的接口，详细可以参考<a href="http://learn.jquery.com/events/event-extensions/">jQuery官方文档</a>，这里就是典型的jQuery自定义事件添加方式，其中有三个钩子：</p>

<ol>
<li>setup：<code>The setup hook is called the first time an event of a particular type is attached to an element.</code>首次绑定时执行，如果返回 false，使用默认方式绑定事件</li>

<li>teardown：<code>The teardown hook is called when the final event of a particular type is removed from an element.</code>若指定该方法，其在移除事件处理程序(removeEventListener)前执行，如果返回 false，移除默认绑定事件</li>

<li>add：<code>Each time an event handler is added to an element through an API such as .on(), jQuery calls this hook.</code>每一次给元素绑定事件，都会执行这个方法</li>
</ol>

<p>setup、teardown和add三个钩子，每个钩子最先做的事都是检测是否该对象为window对象，然后根据window对象特殊处理，因为window对象本身有resize事件</p>

<p>从setup钩子可以看到，在初始化整个事件处理时，创建一个元素队列，队列中的每隔元素都把width和height放在data中，然后每隔250ms启动loopy函数，在loopy函数中判断是否变化，如果有变，触发回调函数并更新data中的width和height</p>

<p>从teardown钩子可以看到，在元素移除事件时，只需要将元素从元素队列移除，并清除元素中的data数据。如果是元素队列中的最后一个元素，则不再继续执行loopy</p>

<p>add钩子中，对回调函数进行了包装</p>

<p>由此可以看到一个简单的jQuery自定义函数的实现机制</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/01/28/jquery-resize</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（博客编写） ]]></title>
                <link>http://skyinlayer.com/blog/2014/01/27/jekyll-2</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 27 Jan 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>系列文章传送门：</p>

<p><a href="http://skyinlayer.com/blog/2014/01/25/jekyll-1/">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>

<p>这篇文章主要介绍博客内容的编写及本地测试，内容主要来自<a href="http://jekyllrb.com/docs/home/">Jekyll的文档</a>、<a href="http://docs.shopify.com/themes/liquid-basics">Liquid的文档</a></p>

<h2 id="">创建项目</h2>
<hr />
<p>到想要创建项目的文件夹下（如d:/），运行命令：</p>

<pre class="shell"><code class="shell">jekyll new blog</code></pre>

<p>这样就会创建一个新文件夹d:/blog，其结构如下：</p>

<ol>
<li>文件夹_layouts：用于存放模板的文件夹，里面有两个模板，default.html和post.html</li>

<li>文件夹_posts：用于存放博客文章的文件夹，里面有一篇markdown格式的文章–2014-01-27-welcome-to-jekyll.markdown</li>

<li>文件夹css：存放博客所用css的文件夹</li>

<li>.gitignore：可以删掉，后面会将项目添加到git项目，所以这个不需要了</li>

<li>_coinfig.yml：jekyll的配置文件，里面可以定义相当多的配置参数，具体配置参数可以参照其<a href="http://jekyllrb.com/docs/configuration/">官网</a></li>

<li>index.html：项目的首页</li>
</ol>

<p>根据实际需要，可能还需要创建如下文件或文件夹：</p>

<ol>
<li>_includes:用于存放一些固定的HTML代码段，文件为.html格式，可以在模板中通过liquid标签引入，常用来在各个模板中复用如 导航条、标签栏、侧边栏 之类的在每个页面上都一样不变的内容，需要注意的是，这个代码段也可以是未被编译的，也就是说也可以使用liquid标签放在这些代码段中</li>

<li>image和js等自定义文件夹：用来存放一些需要的资源文件，如图片或者javascript文件，可以任意命名</li>

<li>CNAME文件：用来在github上做域名绑定的，将在后面介绍</li>

<li>favicon.ico：网站的小图标</li>

<li>….</li>
</ol>

<p>创建完需要的文件夹之后，首先需要修改的就是jekyll的配置文件_config.yml，这个配置文件的内容相当多，详细见<a href="http://jekyllrb.com/docs/configuration/">官方文档</a>，如果没有太多的额外需求，只需要设定两个参数就行了，一个是编码的字符集，一个是项目的路径，我这里是这么设定的：</p>

<pre><code>baseurl: /
encoding: utf-8</code></pre>

<p>这样一个博客项目就创建完成了</p>

<h2 id="_2">编写博文</h2>
<hr />
<p>大致上jekyll生成html的流程，jekyll首先会读取如下内容进入内存中：</p>

<ol>
<li>_posts及文件夹下的所有文章，将其参数和文章内容组织保存在内存中，所有的文章的内容、参数都在site.posts对象（其他文件夹下的文章不会放入site.posts中）</li>

<li>_layouts文件夹下的所有模板</li>

<li>_includes文件夹下的所有需要被引入的内容</li>
</ol>

<p>然后根据每一篇需要编译的文章选择的其参数定义的模板来创建一个模板，并将当前文章的内容、参数等进行扩展后放在page对象、content对象中，然后进行模板的编译，生成html文件，并按照一定规则放在_site文件夹下。也就是说在创建一篇文章时，其实所有文章的内容都已经被读取出来了，这也为文章相互之间的关联提供了可能</p>

<p>可以看一下_posts下的jekyll给的例子：</p>

<pre class="markdown"><code class="markdown">---
layout: post
title:  &quot;Welcome to Jekyll!&quot;
date:   2014-01-27 21:57:11
categories: jekyll update
---

You&#39;ll find this post in your `_posts` directory - edit this post and re-build (or run with the `-w` switch) to see your changes!
To add new posts, simply add a file in the `_posts` directory that follows the convention: YYYY-MM-DD-name-of-post.ext.

Jekyll also offers powerful support for code snippets:

{% highlight ruby %}
def print_hi(name)
  puts &quot;Hi, #{name}&quot;
end
print_hi(&#39;Tom&#39;)
#=&gt; prints &#39;Hi, Tom&#39; to STDOUT.
{% endhighlight %}

Check out the [Jekyll docs][jekyll] for more info on how to get the most out of Jekyll. File all bugs/feature requests at [Jekyll&#39;s GitHub repo][jekyll-gh].

[jekyll-gh]: https://github.com/mojombo/jekyll
[jekyll]:    http://jekyllrb.com</code></pre>

<p>可以看到在博文的最上方有被两个<code>---</code>包裹起来的一段，这里就定义了文章的一些参数，更多参数在<a href="http://jekyllrb.com/docs/frontmatter/">FrontMatter</a>和<a href="http://jekyllrb.com/docs/variables/">Variables</a>获取，简单的只需要关注几个就好：</p>

<ol>
<li>title：文章的标题</li>

<li>date：文章的日期</li>

<li>categories：定义了文章所属的目录，一个list，将会根据这个目录的list来创建目录并将文章html放在生成的目录下，文章分类时候用，这里就不使用了</li>

<li>layout：文章所使用的模板名称，也就是_layouts中定义的模板的文件名去掉.html</li>

<li>tags：例子中没有，定义了文章的标签，也是一个list，文章分类时候用，这里就不使用了</li>
</ol>

<p>这里就写一个最简单的文章，只是用其中的两个参数：layout，title，如下：</p>

<pre><code>---
layout: mylayout
title: hello-jekyll
---

Hello jekyll!</code></pre>

<p>将这个写完的文章保存为 “年-月-日-标题.markdown”的名字形式，因为如果不修改permlinks，jekyll会根据文章的标题来创建文件夹，如2014-01-27-hello会创建成/2014/01/27/hello.html。这里就保存成2014-01-27-hello.markdown</p>

<p>ps：文章的文件名不要使用中文，否则会出现bug，因为在url中会escape，而服务器查找却是按照escape后的字符串去查找 ，就会出现找不到文章的情况，使用英文代替就好，定义了title变量就无所谓文件名中标题的内容了</p>

<p>博客不能没有主页，所以我们修改index.html文件如下：</p>

<pre class="xml"><code class="xml">---
layout: mylayout
title: Hello Jekyll!
---
&lt;ul class=&quot;posts&quot;&gt;
{% for post in site.posts %}
  &lt;li&gt;&lt;span&gt;{{ post.date | date_to_string }}&lt;/span&gt; &amp;raquo; &lt;a href=&quot;{{ post.url }}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;</code></pre>

<p>还是使用我们刚才的模板，这回编译完成后生成的结果如下：</p>

<pre class="xml"><code class="xml">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;test&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        Hello Jekyll!
        &lt;ul class=&quot;posts&quot;&gt;
          &lt;li&gt;&lt;span&gt;27 Jan 2014&lt;/span&gt; &amp;raquo; &lt;a href=&quot;/2014/01/27/hello.html&quot;&gt;hello-jekyll&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>由于index文件名中没有时间，所以时间直接被忽略了，而内容段则通过liquid的for标签进行了迭代，遍历了_posts下的所有文章，将其文章的时间、路径、标题组织成html文件，生成指向博文的连接</p>

<h2 id="_3">创建模板</h2>
<hr />
<p>我们可以打开jekyll给的例子default.html看一看模板的结构:</p>

<pre class="xml"><code class="xml">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;
        &lt;title&gt;{{ page.title }}&lt;/title&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;

        &lt;!-- syntax highlighting CSS --&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/syntax.css&quot;&gt;

        &lt;!-- Custom CSS --&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/main.css&quot;&gt;

    &lt;/head&gt;
    &lt;body&gt;

        &lt;div class=&quot;site&quot;&gt;
          &lt;div class=&quot;header&quot;&gt;
            &lt;h1 class=&quot;title&quot;&gt;&lt;a href=&quot;/&quot;&gt;{{ site.name }}&lt;/a&gt;&lt;/h1&gt;
            &lt;a class=&quot;extra&quot; href=&quot;/&quot;&gt;home&lt;/a&gt;
          &lt;/div&gt;

          {{ content }}

          &lt;div class=&quot;footer&quot;&gt;
            &lt;div class=&quot;contact&quot;&gt;
              &lt;p&gt;
                Your Name&lt;br /&gt;
                What You Are&lt;br /&gt;
                you@example.com
              &lt;/p&gt;
            &lt;/div&gt;
            &lt;div class=&quot;contact&quot;&gt;
              &lt;p&gt;
                &lt;a href=&quot;https://github.com/yourusername&quot;&gt;github.com/yourusername&lt;/a&gt;&lt;br /&gt;
                &lt;a href=&quot;https://twitter.com/yourusername&quot;&gt;twitter.com/yourusername&lt;/a&gt;&lt;br /&gt;
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;

    &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>可以看到，模板和普通的html文件几乎是一样的。jekyll使用的是一个叫liquid的模板引擎创建html文件，这个模板引擎也有<a href="http://docs.shopify.com/themes/liquid-basics">详细的文档</a>，现在就只关注其中比较核心的部分，文章的标题和文章的内容</p>

<p>可以看到模板的有这么两句{{ page.title }}, {{ content }}，这两句就分别是文章标题和文章内容的占位符，如果有文章使用了这个模板，如过使用上面写的那篇hello的文章，标题就是hello-jekyll，content就是Hello jekyll!，这里定义一个自己的新模板，保存为mylayout.html</p>

<pre class="xml"><code class="xml">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;test&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
          {{ page.title }}
          {{ page.date }}
          {{ content }}
    &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>第一行是标题，然后是博文时间（在文件名中定义），然后是博文内容 这样一个简单的模板就创建好了</p>

<h2 id="_4">调试</h2>
<hr />
<p>在博客文件夹下，在命令行中输入<code>jekyll build --trace</code>就可以将所有文章文件根据其模板进行编译，生成结果，放在根目录下的_site中，这里我们使用后，会出现如下结果：\blog\_site\2014\01\27文件夹下有一个hello.html，其内容为：</p>

<pre class="xml"><code class="xml">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;test&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
          hello-jekyll
          2014-01-27 00:00:00 +0800
          &lt;p&gt;Hello jekyll!&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>可以看到，这就是编译完的博文文件，如我们设定的，第一行是标题，然后是文件名定义的时间，然后是博文内容，如果编译错误，将会在命令行中看到一个错误栈，可以方便调试，具体哪里出错了，如果不需要看错误栈，直接使用<code>jekyll build</code>就行了</p>

<p>如果想要在本地开启一个服务器查看效果，可以使用命令<code>jekyll serve</code>，这样会开启一个监听端口4000的服务器，浏览器中查看localhost:4000，则会进入index.html的内容中，点击文章的标题就可以跳转到具体的博文了</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/01/27/jekyll-2</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（环境搭建） ]]></title>
                <link>http://skyinlayer.com/blog/2014/01/25/jekyll-1</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 25 Jan 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>之前曾经使用nodejs写了一个博客系统，但是偷偷用的公司服务器。无奈被发现了，o(╯□╰)o，被勒令下线了之后只能想其他方法写博客了。原本是想换个地方搭建，于是找百度的同学要了个BAE的nodejs权限，但是抢不到配额，呵呵呵…于是乎就想到了Github上使用静态页面搭建博客的方法</p>

<h2 id="jekyllgithub">为什么是Jekyll+github？</h2>
<hr />
<p>其 <a href="http://jekyllrb.com/">官网首页</a> 上的描述是： <code>Transform your plain text into static websites and blogs</code>。Jekyll将原始文本根据一定规则转换成静态的网页和博客。但这个转换并不是简单的字符串替换就了事了，而是首先读取各个文件中的内容，根据配置文件中描述的参数在内存中构建一个巨大的对象存储整个博客的信息，然后再将这些信息根据配置文件中定义的输出方式来生成具体的HTML文件。整个项目是由Ruby写的，所以若需要在本地调试则需要安装Ruby。</p>

<p>使用Jekyll搭建博客有几个好处：</p>

<ol>
<li>不需要使用额外的数据库</li>

<li>支持markdown，liquid，以及原始的html、css</li>

<li>可以定义模板，并在模板上进行代码复用</li>

<li>github对其支持，可以直接在github上搭建，可以继承github上的各种好处（版本控制，免费，无流量限制）</li>

<li>有很多扩展插件（但是在github上用不了，github不允许用户使用扩展插件，大概是出于安全性考虑）</li>
</ol>

<p>当然缺点也有很多：</p>

<ol>
<li>生成的是静态网页，无法动态加载，若需要外部服务如评论，只能使用类似于disquz，多说这样的外部插件了</li>

<li>仅仅适合小型网站，不适合大中型网站</li>

<li>没有数据库及服务端的逻辑</li>
</ol>

<p>由此可见，用来搭建个人博客相当合适（github版本控制，免费，无流量限制，支持markdown，无需关心服务器端逻辑和数据库）</p>

<h2 id="jekyll">本地安装Jekyll</h2>
<hr />
<h3 id="rubygem">首先安装Ruby及gem</h3>

<ol>
<li>
<p>从<a href="http://rubyinstaller.org/">RubyInstaller</a>下载ruby，如果有经验的可以直接从<a href="https://www.ruby-lang.org/zh_cn/downloads/">Ruby官网</a>进行下载，前者安装比较无脑，会有一些额外的依赖包进行安装，版本也较低，而Ruby官网的版本则相对较高，但是没有额外的依赖包。下载的时候版本选较高一些的，否则会有bug，我选择的是2.0.0p353(2013-11-22)。安装的时候记得勾选添加环境变量。</p>
</li>

<li>
<p>安装devkit，<a href="http://rubyinstaller.org/">RubyInstaller</a>页面中往下拉就能看到。选择自己版本的Ruby对应的devkit，下载并解压，然后执行:</p>

<pre class="shell"><code class="shell">cd devkit
ruby dk.rb init
ruby dk.rb install</code></pre>

<p>这样就完成ruby环境的安装了</p>
</li>

<li>
<p>安装gem，这个也可以去<a href="http://rubygems.org/">gem的官网</a>进行下载，然后直接安装就行了，安装完成后使用<code>gem -v</code>查看一下是否安装成功。我安装的是2.1.11版本</p>
</li>

<li>
<p>gem是可以选择源的，默认的源有点慢，可以使用<code>ruby.taobao.org</code>的源，方便快捷 查看当前源</p>
</li>
</ol>

<pre class="shell"><code class="shell">D:\node\jekyll&gt;gem sources list
*** CURRENT SOURCES ***

https://rubygems.org/

D:\node\jekyll&gt;</code></pre>

<p>添加新源</p>

<pre class="shell"><code class="shell">gem sources -a http://ruby.taobao.org/</code></pre>

<p>删除默认源</p>

<pre class="shell"><code class="shell">gem sources --remove https://rubygems.org/</code></pre>

<p>再次查看的时候保证只有<code>http://ruby.taobao.org/</code>就行了</p>

<p>如果上面出错，去网上找找教程吧，ruby环境的搭建和gem的安装教程还是蛮多的，基本google一下遍地都是。</p>

<h3 id="gemjekyll">使用gem安装Jekyll</h3>

<p>使用命令<code>gem install jekyll</code>就可以安装jekyll及所有需要的依赖，但不包括插件，安装jekyll的时候需要注意一下安装的版问题，jekyll的最新版本为1.4.3，但是有一个bug，<a href="http://stackoverflow.com/questions/21137096/jekyll-error-running-jekyll-serve">stackoverflow</a>上有人遇到过，我自己在使用的时候也遇到了类似的问题，解决方法是安装1.4.2版本，所以这里的安装命令为：<code>gem install jekyll --version &quot;=1.4.2&quot;</code>。安装完成后使用<code>jekyll -v</code>查看一下是否安装成功了</p>

<h3 id="jekyllwindows">Jekyll在windows下的字符集问题</h3>

<p>这个问题较多人遇到过，主要是在启动jekyll服务器的时候出现，以及一些中文文件名上出现，可以参考网上的解答：</p>

<ol>
<li><a href="http://blog.jsfor.com/skill/2013/09/07/jekyll-local-structures-notes/">windows下本地jekyll博客搭建手记</a></li>

<li><a href="http://chxt6896.github.io/blog/2012/02/13/blog-jekyll-native.html">Jekyll 本地调试之若干问题</a></li>

<li><a href="http://yanping.me/cn/blog/2012/10/09/chinese-charset-problems-with-jekyll/">在Windows下使用jekyll如何避免出现中文字符集错误</a></li>
</ol>

<p>在这里，我仅仅是改了git bash的字符集，并没有去改jekyll的源文件，因为<code>self.content = File.read(File.join(base, name))</code>语句已经变了，不敢随便改。中文文件名的问题则通过改为全英文文件命名来避开，category里中文的问题则通过修改Permalinks来避开，这些后面会详细介绍</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/01/25/jekyll-1</guid>
            </item>
        
            <item>
                <title><![CDATA[ 闭合浮动最佳方案（clearfix） ]]></title>
                <link>http://skyinlayer.com/blog/2014/01/09/clearfix</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 09 Jan 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <p>传统方法：</p>

<pre class="css21"><code class="css21">.clear{clear:both;height:0;overflow:hidden;}</code></pre>

<p>这样在需要闭合的地方加一个div.clear就行了，但是会改变html文档结构，所以建议使用以下方式：</p>

<pre class="css21"><code class="css21">.clearfix:after{content:&quot;.&quot;;display:block;height:0;clear:both;visibility:hidden}
.clearfix{*+height:1%;}</code></pre>

<p>使用after伪类后可以不用改变html文档结构即完成浮动闭合,加在浮动元素的父元素上就可以了</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2014/01/09/clearfix</guid>
            </item>
        
            <item>
                <title><![CDATA[ 搭建HTML5简易聊天室 ]]></title>
                <link>http://skyinlayer.com/blog/2013/12/08/websocket</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 08 Dec 2013 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h3 id="">前面的话</h3>
<hr />
<p>之前曾经写过一个符合xmpp协议的Web IM，但使用的是JSJaC，后台用的也是与之配套的jabber client，发现nodejs的事件模式更适合作为Web IM的客户端。</p>

<p>而传统的ajax轮询机制也早晚被全双工websocket所取代，所以就打算在我的毕业设计的Web IM平台中使用websocket。</p>

<p>在这里调研一下并作出了一个简单的版聊demo，这里讲一下这个简单demo的实现方式</p>

<h3 id="websocket">WebSocket</h3>
<hr />
<p>什么是WebSocket？</p>

<p><a href="http://datatracker.ietf.org/doc/rfc6455/?include_text=1">WebSocket的协议</a> 目前还没有仔细去研读，有时间研读一下</p>

<p>根据<a href="http://www.websocket.org/">WebSocket.org</a>上的定义：</p>

<blockquote>
<p>The WebSocket specification—developed as part of the HTML5 initiative— introduced the WebSocket JavaScript interface, which defines a full-duplex single socket connection over which messages can be sent between client and server. The WebSocket standard simplifies much of the complexity around bi-directional web communication and connection management.</p>
</blockquote>

<p>如上所述websocket定义了一个浏览器和服务器之间的全双工的单一的socket连接。</p>

<p>WebSocket的API？</p>

<p><a href="http://dev.w3.org/html5/websockets/">W3C的WS的API</a> ，定义了具体的WS的接口，而一般只要注意怎么使用就行了，可以清楚地看到WS客户端的几个事件：</p>

<ol>
<li>onopen 在WS客户端和WS服务器建立连接成功后调用</li>

<li>onmessage 在WS服务器给WS客户端发送数据时调用</li>

<li>onerror 如果连接失败，发送、接收数据失败或者处理数据出现错误，则会被调用</li>

<li>onclose 在WS客户端接收到WS服务器关闭时进行调用</li>
</ol>

<h3 id="websocket_2">WebSocket服务器实现</h3>
<hr />
<p>nodejs有很多websocket的三方库，都很实用，在stackoverflow上有人问过具体应该使用哪个库，而回答者给与了<a href="http://stackoverflow.com/questions/16392260/which-websocket-library-to-use-with-node-js">较为全面的解答</a></p>

<p>这里面对各个websocket库进行了一个对比，可以根据自己的需要选择。</p>

<p>其中可以注意一下<a href="http://socket.io/#home">socket.io</a>，它对不同的浏览器有比较好的支持，在不支持websocket的时候可以转变成ajax的轮询等其他的替换，浏览器的支持也相当不错。同时还能和目前比较流行的node的web框架express相结合，其文档的例子写的很好。</p>

<p>由于我只是想搭建一个简单快捷的WS服务器，所以选用了号称probably the fastest WebSocket library for node.js的<a href="https://github.com/einaros/ws">ws</a></p>

<p>在项目中使用npm安装：</p>

<pre><code> npm install ws</code></pre>

<p>如果需要使用命令行的简易WS客户端，可以：</p>

<pre><code>npm install ws -g</code></pre>

<p>创建一个WS服务器：</p>

<pre><code>var WebSocketServer = require(&#39;ws&#39;).Server,
    wss = new WebSocketServer({
    port: process.env.WSPORT || 3001
});</code></pre>

<p>这样wss就成为了一个监听3001端口的WS服务器，我们需要为WS服务器创建WS客户端连接时候的事件：</p>

<pre><code>wss.on(&#39;connection&#39;, function(ws) {});</code></pre>

<p>这样，在有WS客户端连接我们的WS服务器时就会触发这个事件，但连接之后我么还需要传递信息，所以需要丰富这个事件的回调函数。</p>

<p>回调函数有一个参数ws，这个ws掌管着和WS客户端的连接，其事件也和WS客户端相同，不过不需要onopen。需要绑定的还有message，close：</p>

<pre><code>wss.on(&#39;connection&#39;, function(ws) {
    ws.on(&#39;message&#39;, function(data) {
        
    });
    ws.on(&#39;close&#39;, function() {
        
    });
});</code></pre>

<p>message事件在WS客户端给这个WS服务器发数据时调用，data就是这个数据，一般为string类型</p>

<p>close事件在WS客服端给这个WS服务器发送关闭请求时调用</p>

<p>一个简单的聊天室，需要在一个用户加入时告诉其他所有用户有新用户加入，也就是需要一个广播的方法，我们可以根据ws的示例来定义广播方法：</p>

<pre><code>wss.broadcast = function(data) {
    for (var i in this.clients) this.clients[i].send(JSON.stringify(data));
};</code></pre>

<p>这里可以看到wss的clients存放了所有与wss相连的WS客户端连接。</p>

<p>在一个WS客户端连接了WS服务器，我们需要把现有的所有房间内用户的信息给新进入房间的用户，并告诉所有房间内的用户有新用户加入，默认新进入房间的用户叫“游客”，修改代码：</p>

<pre><code>wss.on(&#39;connection&#39;, function(ws) {
    ws.on(&#39;message&#39;, function(data) {
    });
    ws.on(&#39;close&#39;, function() {
    });
    //给每个用户一个单独的id
    ws.uid = uuid.v4();
    //新进入房间的用户的昵称
    ws.nick = &quot;游客&quot;;
    //把目前所有房间内人员的信息发给新用户
    for (var i in this.clients) {
        ws.send(JSON.stringify({
            nick: this.clients[i].nick,
            uid: this.clients[i].uid,
            type: &quot;join&quot;
        }));
    }
    //将新加入用户的信息告诉所有房间内的用户
    wss.broadcast({
        nick: ws.nick,
        uid: ws.uid,
        type: &quot;join&quot;
    });
});</code></pre>

<p>这样新用户加入时的服务器端处理就完成了</p>

<p>在一个用户向服务器发送信息时,需要广播这条信息,同时也要指出发送人的信息,所以修改代码:</p>

<pre><code>ws.on(&#39;message&#39;, function(data) {
    wss.broadcast({
        nick: ws.nick,
        uid: ws.uid,
        time: moment(data.time).format(&quot;HH:mm:ss&quot;),
        message: data.message,
        type: &quot;message&quot;
    });
});</code></pre>

<p>在一个WS客户端向WS服务器发送关闭请求时，需要通知其他所有房间内的用户，所以修改代码：</p>

<pre><code>ws.on(&#39;close&#39;, function() {
    wss.broadcast({
        nick: ws.nick,
        uid: ws.uid,
        type: &quot;exit&quot;
    });
});</code></pre>

<p>在一个用户要修改自己的昵称，WS客户端需要向WS服务器发送申请，所以修改代码：</p>

<pre><code>ws.on(&#39;message&#39;, function(data) {
    //解析数据
    data = JSON.parse(data);
    //若为message,则为WS客户端向WS服务器发送信息,进行广播
    if (data.type === &quot;message&quot;) {
        wss.broadcast({
            nick: ws.nick,
            uid: ws.uid,
            time: moment(data.time).format(&quot;HH:mm:ss&quot;),
            message: data.message,
            type: &quot;message&quot;
        });
    //若为nickname,则为WS客户端向WS服务器发送昵称修改请求,则修改用户昵称,并进行广播
    } else if (data.type === &quot;nickname&quot;) {
        wss.broadcast({
            oldnick: ws.nick,
            nick: data.nick,
            uid: ws.uid,
            type: &quot;nickname&quot;
        });
        ws.nick = data.nick;
    }
});</code></pre>

<p>这样一个简单的聊天室的WS服务器就完成了,所有代码如下:</p>

<pre><code>var WebSocketServer = require(&#39;ws&#39;).Server,
    wss = new WebSocketServer({
        port: process.env.WSPORT || 3001
    });

wss.broadcast = function(data) {
    for (var i in this.clients) this.clients[i].send(JSON.stringify(data));
};

wss.on(&#39;connection&#39;, function(ws) {
    ws.on(&#39;message&#39;, function(data) {
        data = JSON.parse(data);
        if (data.type === &quot;message&quot;) {
            wss.broadcast({
                nick: ws.nick,
                uid: ws.uid,
                time: moment(data.time).format(&quot;HH:mm:ss&quot;),
                message: data.message,
                type: &quot;message&quot;
            });
        } else if (data.type === &quot;nickname&quot;) {
            wss.broadcast({
                oldnick: ws.nick,
                nick: data.nick,
                uid: ws.uid,
                type: &quot;nickname&quot;
            });
            ws.nick = data.nick;
        }
    });
    ws.on(&#39;close&#39;, function() {
        wss.broadcast({
            nick: ws.nick,
            uid: ws.uid,
            type: &quot;exit&quot;
        });
    });
    ws.uid = uuid.v4();
    ws.nick = &quot;游客&quot;;
    for (var i in this.clients) {
        ws.send(JSON.stringify({
            nick: this.clients[i].nick,
            uid: this.clients[i].uid,
            type: &quot;join&quot;
        }));
    }
    wss.broadcast({
        nick: ws.nick,
        uid: ws.uid,
        type: &quot;join&quot;
    });
});</code></pre>

<h3 id="websocket_3">WebSocket客户端实现</h3>
<hr />
<p>在浏览器中,则需要建立一个WS客户端</p>

<pre><code>//创建一个WS客户端
var ws = new WebSocket(&quot;ws://localhost:3001&quot;);</code></pre>

<p>给它按照WebSocket的API绑定事件:</p>

<pre><code>//WS客户端连接到WS服务器后, 设定默认昵称,并加入版聊
ws.onopen = function(event) {
    $(&quot;#nickname&quot;).val(&quot;游客&quot;);
    $logs.append(&quot;&lt;div class=&#39;alert alert-success&#39;&gt;您已加入版聊&lt;/div&gt;&quot;);
};
//如果WS服务器关闭,给予断开提示
ws.onclose = function(event) {
    $logs.append(&quot;&lt;div class=&#39;alert alert-danger&#39;&gt;您已断开版聊&lt;/div&gt;&quot;);
};
//如果WS服务器向这个WS客户端发送信息:
ws.onmessage = function(event) {
    var data = JSON.parse(event.data);
    //发送文本信息, 显示到页面上
    if (data.type === &quot;message&quot;) {
        $chat.append(&quot;&lt;p&gt;&quot; + data.nick + &quot;(&quot; + data.time + &quot;): &quot; + data.message + &quot;&lt;/p&gt;&quot;);
    //有新用户加入, 显示用户加入通知, 并修改当前用户列表
    } else if (data.type === &quot;join&quot;) {
        if ($(&quot;p[uid=&#39;&quot; + data.uid + &quot;&#39;]&quot;, $users).length === 0) {
            $users.append(&quot;&lt;p uid=&#39;&quot; + data.uid + &quot;&#39;&gt;&quot; + data.nick + &quot;&lt;/p&gt;&quot;);
            $logs.append(&quot;&lt;div class=&#39;alert alert-warning&#39;&gt;&quot; + data.nick + &quot;加入了版聊&lt;/div&gt;&quot;);
        }
    //有用户离开, 显示用户离开通知, 并修改当前用户列表
    } else if (data.type === &quot;exit&quot;) {
        $(&quot;p[uid=&#39;&quot; + data.uid + &quot;&#39;]&quot;, $users).remove();
        $logs.append(&quot;&lt;div class=&#39;alert alert-warning&#39;&gt;&quot; + data.nick + &quot;离开了版聊&lt;/div&gt;&quot;);
    //有用户修改昵称, 显示用户修改昵称, 修改用户列表
    } else if (data.type === &quot;nickname&quot;) {
        $(&quot;#nickname&quot;).val(data.nick);
        $(&quot;p[uid=&#39;&quot; + data.uid + &quot;&#39;]&quot;, $users).text(data.nick);
        $logs.append(&quot;&lt;div class=&#39;alert alert-warning&#39;&gt;&quot; + data.oldnick + &quot; 修改昵称为 &quot; + data.nick + &quot;&lt;/div&gt;&quot;);
    }
};</code></pre>

<p>具体需要发送信息时,使用ws.send发送：</p>

<pre><code>//从WS客户端向WS服务器发送信息数据
ws.send(JSON.stringify({
    time: new Date().getTime(),
    message: message,
    type: &quot;message&quot;
}));</code></pre>

<p>需要发送修改昵称请求时，采用同样的方式：</p>

<pre><code>//从WS客户端向WS服务器发送昵称修改请求
ws.send(JSON.stringify({
    nick: nick,
    type: &quot;nickname&quot;
}));</code></pre>

<p>这样一个完整的WS客户端代码：</p>

<pre><code>//创建一个WS客户端
var ws = new WebSocket(&quot;ws://localhost:3001&quot;);
//WS客户端连接到WS服务器后, 设定默认昵称,并加入版聊
ws.onopen = function(event) {
    $(&quot;#nickname&quot;).val(&quot;游客&quot;);
    $logs.append(&quot;&lt;div class=&#39;alert alert-success&#39;&gt;您已加入版聊&lt;/div&gt;&quot;);
};
//如果WS服务器关闭,给予断开提示
ws.onclose = function(event) {
    $logs.append(&quot;&lt;div class=&#39;alert alert-danger&#39;&gt;您已断开版聊&lt;/div&gt;&quot;);
};
//如果WS服务器向这个WS客户端发送信息:
ws.onmessage = function(event) {
    var data = JSON.parse(event.data);
    //发送文本信息, 显示到页面上
    if (data.type === &quot;message&quot;) {
        $chat.append(&quot;&lt;p&gt;&quot; + data.nick + &quot;(&quot; + data.time + &quot;): &quot; + data.message + &quot;&lt;/p&gt;&quot;);
    //有新用户加入, 显示用户加入通知, 并修改当前用户列表
    } else if (data.type === &quot;join&quot;) {
        if ($(&quot;p[uid=&#39;&quot; + data.uid + &quot;&#39;]&quot;, $users).length === 0) {
            $users.append(&quot;&lt;p uid=&#39;&quot; + data.uid + &quot;&#39;&gt;&quot; + data.nick + &quot;&lt;/p&gt;&quot;);
            $logs.append(&quot;&lt;div class=&#39;alert alert-warning&#39;&gt;&quot; + data.nick + &quot;加入了版聊&lt;/div&gt;&quot;);
        }
    //有用户离开, 显示用户离开通知, 并修改当前用户列表
    } else if (data.type === &quot;exit&quot;) {
        $(&quot;p[uid=&#39;&quot; + data.uid + &quot;&#39;]&quot;, $users).remove();
        $logs.append(&quot;&lt;div class=&#39;alert alert-warning&#39;&gt;&quot; + data.nick + &quot;离开了版聊&lt;/div&gt;&quot;);
    //有用户修改昵称, 显示用户修改昵称, 修改用户列表
    } else if (data.type === &quot;nickname&quot;) {
        $(&quot;#nickname&quot;).val(data.nick);
        $(&quot;p[uid=&#39;&quot; + data.uid + &quot;&#39;]&quot;, $users).text(data.nick);
        $logs.append(&quot;&lt;div class=&#39;alert alert-warning&#39;&gt;&quot; + data.oldnick + &quot; 修改昵称为 &quot; + data.nick + &quot;&lt;/div&gt;&quot;);
    }
};
//发送消息按钮事件
$(&quot;#send&quot;).click(function(event) {
    var message = $(&quot;#message&quot;).val();
    if (message.trim() !== &quot;&quot;) {
        //从WS客户端向WS服务器发送信息数据
        ws.send(JSON.stringify({
            time: new Date().getTime(),
            message: message,
            type: &quot;message&quot;
        }));
    }
});
//修改昵称按钮事件
$(&quot;#changeNick&quot;).click(function(event) {
    var nick = $(&quot;#nickname&quot;).val();
    if (nick.trim() !== &quot;&quot;) {
        //从WS客户端向WS服务器发送昵称修改请求
        ws.send(JSON.stringify({
            nick: nick,
            type: &quot;nickname&quot;
        }));
    }
});</code></pre>

<h3 id="_2">写在最后</h3>
<hr />
<p>这样一个完整的基于WebSocket的简单聊天室就完成了，试用一下，虽然功能不完善，但是已经可以用了，并且兼容firefox25和chrome</p> ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/blog/2013/12/08/websocket</guid>
            </item>
        
    </channel>
</rss>