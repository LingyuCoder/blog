{"tags":[{"name":"JavaScript","permalink":"http://lingyu.wang/tags/JavaScript/","url":"/async/tags/JavaScript.json","count":40},{"name":"React","permalink":"http://lingyu.wang/tags/React/","url":"/async/tags/React.json","count":2}],"categories":[{"name":"前端综合","permalink":"http://lingyu.wang/categories/前端综合/","url":"/async/categories/前端综合.json","count":6}],"url":"/async/posts/2015/08/30/chonggou.json","date":1440864000000,"path":{"year":2015,"month":8,"day":30,"name":"chonggou"},"subtitle":"扫灰","title":"用React做重构时的一些思考","permalink":"http://lingyu.wang/2015/08/30/chonggou/","content":"<p>好久没写东西了，主要是工作比以前学生时代忙多了，周末也是各种加班充电，沉淀的少了。最近一直在用React对手上的老业务做重构，这里写一下重构中的一些感悟和思考</p>\n<a id=\"more\"></a>\n<h2 id=\"老业务和老代码\">老业务和老代码</h2><h3 id=\"前台和后台\">前台和后台</h3><p>入职之后刚开始接手的是前台展示业务，基本上是在已有的框架上写模块，前台业务尤其是活动期间光完成业务就累得半死。</p>\n<p>后来随着一次业务调整，开始负责商家后台业务了，两边节奏和开发方式都完全不同。前台业务更新换代较快，没事就改个版啥的，后台就完全不同了：</p>\n<ol>\n<li>后台的业务偏重的是功能，与前台业务酷炫的交互不同，后台业务往往是数据的直观展示和CRUD操作</li>\n<li>前台业务往往可以根据展示的区域划分为多个模块，模块较为独立，很少有模块之间的通信。而后台业务往往是多个子功能模块通过复杂的业务逻辑串联到一起形成完整的功能</li>\n</ol>\n<h3 id=\"一些感想\">一些感想</h3><p>目前负责的应用应该是整个天猫最复杂的应用，里面都是一些老旧的代码，有很重的历史包袱。模块之间的划分不清晰，模块之间的耦合也比较严重，对DOM的交叉修改，不必要的依赖各种各样。进来后思考的最多的就是对这块老代码做重构。</p>\n<p>当然老业务只是代码老，并不代表没有新需求，所以对于接手老代码的开发者来说，最重要的一点是：</p>\n<blockquote>\n<p>老坑没填的情况下，首先保证不会挖新坑，不要明知道之前的开发者使用了错误的开发方式，还不负责任的继续使用。历史问题会随着技术的发展和时间的推移而像滚雪球一样越滚越大，如果放任其滚下去很可能最后整个应用完全不可维护</p>\n</blockquote>\n<p>目前负责老业务并不是单纯的老到只需要维护就可以了，事实上还有大量的新需求不断加入当中，它们就是滚雪球时不断粘附到雪球上的雪</p>\n<ul>\n<li>对于与老代码之间耦合不是特别强烈的新需求，采用较为独立的模块化开发方式，以一种可插拔的形式嵌入到老业务中，保证插和拔的时候不会影响老业务正常运作</li>\n<li>在老业务原有的代码上做更改，这是熟悉老业务代码的最佳方式，理清楚要修改的老业务代码逻辑，若涉及的模块和其他模块耦合程度较低，就将其抽离。如果耦合程度较高，就采用对现有架构尽可能小影响的开发方式开发</li>\n<li>解耦的过程就像剥洋葱，剥离了最外面一层，里面一层就变成最外一层了，一层层剥到核心，整个解耦过程就完成了</li>\n</ul>\n<h2 id=\"老业务中的React\">老业务中的React</h2><p>在整个解耦的过程中，采用React做解耦。目前比较流行的React开发方式是采用Common JS开发，模块直接通过npm管理，上线时采用webpack或browserify做打包。但受限于身上的历史包袱，不可能整页采用React实现，成本太大。目前整体页面依旧是普通JS，通过模块加载器管理着各个模块，其中一些模块是React实现的，利用browserify的babelify+babel-runtime做ES 6语法编译，保证即使ES 6语法编写的代码也能够正常跑在浏览器上，由于每个模块是独立的，因此这样会产生一些问题，后面会讲到</p>\n<h3 id=\"React做模块\">React做模块</h3><p>为什么要用 React 做解耦，主要是看中其封装理念，一个模块或组件，应当有：</p>\n<ol>\n<li>提供一些配置数据</li>\n<li>模块自己内部逻辑用的数据</li>\n<li>提供一些供交互的接口和事件</li>\n</ol>\n<h4 id=\"兼容JSX和原生JS调用\">兼容JSX和原生JS调用</h4><p>1，2，3分别对应props、state和onXXX回调。对于老业务而言，如果外层不是React，而是模块加载器包裹的原生JS怎么办呢？其实React组件完全可以独立运行，毕竟有<code>React.render</code>，举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'react'</span>, <span class=\"string\">'event-mixin'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">React, EventMixin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> defaultConfig = &#123;</span><br><span class=\"line\">    value: <span class=\"string\">''</span>,</span><br><span class=\"line\">    onChange: noop</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Component = React.createClass(&#123;</span><br><span class=\"line\">    mixins: [EventMixin],</span><br><span class=\"line\">    propTypes: &#123;&#125;,</span><br><span class=\"line\">    getDefaultProps: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> defaultConfig;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getValue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">    setValue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  Component.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">container, config</span>) </span>&#123;</span><br><span class=\"line\">    config = S.merge(&#123;&#125;, defaultConfig, config);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> React.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">Component</span> &#123;<span class=\"attribute\">...config</span>&#125;/&gt;</span>, container);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  return Component;</span><br><span class=\"line\">&#125;);</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，返回一个React类，这个类提供了静态方法用于在容器中直接绘制组件，方便原生JS，而JSX中也可以直接使用标签的方式使用组件</p>\n<p>对于上面说的三点：</p>\n<ol>\n<li>配置数据props的传入：原生JS采用init方法传入，JSX直接写在标签上</li>\n<li>内部数据state组件维护</li>\n<li>组件的方法和事件，对于原生JS提供了getValue、setValue这样的方法，而对于JSX使用则直接可以通过配置传入。对于事件的处理采用了混入Event模型的方式，为组件自身提供了on、off、fire这种事件模型方法供原生JS使用，而对于JSX的调用方式，则直接使用onXXX风格的回调即可</li>\n</ol>\n<p>这样组件就可以兼容外层是JSX或外层是JS的调用方式，同时兼容新业务和老业务</p>\n<h4 id=\"组件独立性\">组件独立性</h4><p>同时，一个组件应当保证对应的独立性：</p>\n<ol>\n<li>样式的独立</li>\n<li>DOM的独立</li>\n<li>组件逻辑的独立</li>\n</ol>\n<p>个人认为一个组件应该standalone就能跑起来的，React非常好的提供了DOM的独立和组件逻辑的独立，采用inline-style的方式也能提供样式的独立。其中DOM的独立非常重要，一旦多个组件DOM形成耦合，这几个组件的解耦将异常困难。React组件的每个DOM元素都分配了自己的id，一旦修改就会发生错误，强制了DOM的独立。</p>\n<p>这样组件就只关注自己了，那么问题就来了，组件都只关注自己，组件之间交互怎么办？所以有Flux</p>\n<h4 id=\"模块间通信\">模块间通信</h4><p>React解决了组件实现，组件间通信就交给了Flux的模式，Flux是一种数据通信模式，其实说简单点就是全局有一些保存数据的Store，各个React组件相互之间通信不是直接通信，而是通过这些保存数据的Store，一个组件修改Store递交数据，另外一个组件监听Store的变化获得数据来实现数据的传输。不过数据传输是单向的</p>\n<p>以往组件之间的耦合是因为一个组件直接调用了另外一个组件的接口，现在大家都不依赖接口了，直接依赖数据，从主动调用变成了被动通知变更</p>\n<p>这里有几个点：</p>\n<ol>\n<li>一个数据需求模块初始化后，一直在监听数据变化，但变更数据的模块可能根本就不存在，这个数据需求模块就蛋疼了，其实当不存在数据变更模块的时候，这个数据需求模块是不应该被初始化的</li>\n<li>由于数据需求模块只在乎数据，给他的数据长啥样，它就长啥样，多个模块共同修改同一份数据时，永远是最新的数据决定了模块的展示，数据需求模块本身必须是无状态的，因为它没办法保证它所依赖的多份数据的递交顺序</li>\n<li>数据需求模块依赖的数据结构是定死的， 变更数据的模块吐出来的数据结果也是定死的，这就产生一个问题，这两个定死的数据结构需要做适配，每个模块只关注自身，当然不应该考虑为其他模块做数据适配。所以这个适配就得在Flux上做，需要尽可能的通过定义开发规范来减少数据适配的出现</li>\n<li>需要immutable保证数据本身的独立性，防止交叉修改同一份数据导致数据污染</li>\n<li>数据都是整块递交，需要DOM Diff这样的方式来保证重绘范围尽可能小</li>\n</ol>\n<h3 id=\"Webpack和Browserify\">Webpack和Browserify</h3><p>这俩的运行机制大体上来说就是分析Common JS代码的AST语法树，找到其中的require指定的依赖名称，然后递归的分析依赖，最后将所有的依赖打包在一起，并配合打包工具自己的模块加载机制复写或替换require实现加载。采用这种方式，组件的安装和使用变得和Common JS一样简单，不用考虑组件的版本管理，因为组件在node_modules里面都有对应版本的源码。</p>\n<p>但这种方式容易产生性能问题：</p>\n<ol>\n<li>不少Common JS的模块都有自己依赖的工具包，这些工具包的版本通常并不相同，这也就导致了重复打包的问题</li>\n<li>Common JS的模块开发方式使得不少开发者没有在意自己使用的包的大小或内容，往往会为了几个很小的功能而引入一个完整的工具库，这在Node.Js上没什么，但是到了浏览器端，就成了大问题</li>\n<li>很多模块没有采用异步加载依赖的方式，而是直接require同步加载依赖，导致打包出来的入口文件巨大无比…首屏很慢</li>\n<li>ES 6的打包碎片问题，如果整页打包当然不存在碎片的问题。但是对于多个模块分开打包，就很导致每个模块自己独立打包，会生成自己的一些编译依赖，而通过模块加载器一起使用时，由于模块相互之间独立，这些依赖虽然有很多是相同的，但也会被引入很多次。目前没有什么好的解决办法，就是减少碎片生成。</li>\n<li>React组件对于子组件的引入都是同步的，如果整页都是React开发就很容易遇到3中的问题</li>\n</ol>\n<p>对于一些新业务，用打包工具整页打包还是可行的，但是一定要注意处理好异步加载的模块，同时保证依赖本身的轻量。而对于老业务，则需要减少独立打包时产生的碎片。不管什么开发方式，都需要注意1，2的情况，个人比较倾向的方式就是，最外层依旧采用现有的AMD模块管理方式，而部分模块采用React开发，防止出现5和3的问题，但4的问题就得通过定义开发规范的方式来规避了</p>\n<h2 id=\"最后\">最后</h2><p>这里随便写一点，可能个人对于React和打包技术的理解有误导致观点不符。其实还是一点，不同的业务场景有自身的技术取舍，能解决问题的技术就是好技术。</p>\n"}