{"tags":[{"name":"ES6","permalink":"http://lingyu.wang/tags/ES6/","url":"/async/tags/ES6.json","count":2},{"name":"Generator","permalink":"http://lingyu.wang/tags/Generator/","url":"/async/tags/Generator.json","count":1},{"name":"JavaScript","permalink":"http://lingyu.wang/tags/JavaScript/","url":"/async/tags/JavaScript.json","count":40},{"name":"NodeJs","permalink":"http://lingyu.wang/tags/NodeJs/","url":"/async/tags/NodeJs.json","count":14}],"categories":[{"name":"NodeJs","permalink":"http://lingyu.wang/categories/NodeJs/","url":"/async/categories/NodeJs.json","count":3}],"url":"/async/posts/2014/07/29/generator.json","date":1406563200000,"path":{"year":2014,"month":7,"day":29,"name":"generator"},"subtitle":"剖析Generator的本质","title":"细说Generator","permalink":"http://lingyu.wang/2014/07/29/generator/","content":"<p>好久没写东西了，今天看了下ES6的Generator的相关知识，在这里记录一下。主要内容翻译自规范，并加入了自己的理解和总结</p>\n<a id=\"more\"></a>\n<p>文章中有很多关于运行时上下文（Execution Context，以下简称EC）的操作，关于EC，作用域链的基础知识请移步<a href=\"http://lingyu.wang/#/art/blog/2014/03/28/js-basis\">JavaScript一些基础知识简介</a></p>\n<h1 id=\"Generator函数\">Generator函数</h1><p>generator函数执行的时候，会进行如下动作：</p>\n<ol>\n<li>创建一个VO，与当前EC（Execution Context，以下简称EC）的作用域链组成新的作用域链</li>\n<li>创建一个generator对象，其有如下值：<ul>\n<li>Scope：新建的作用域链</li>\n<li>Code：generator function内部的代码</li>\n<li>ExecutionContext：EC，目前值为null</li>\n<li>State：”newborn”</li>\n<li>Handler：默认的generator的处理器</li>\n</ul>\n</li>\n</ol>\n<p>这里可以看到，Generator函数的执行，函数体内部的代码是不会动的，而是创建一个generator对象，将代码存入其中，并给予相关的上下文</p>\n<h1 id=\"yield的行为\">yield的行为</h1><p>当执行到<code>yield e</code>时：</p>\n<ol>\n<li>计算出表达式e的值</li>\n<li>获取当前的EC，并从中获取currentGenerator，也就是yield所在的generator对象</li>\n<li>使这个generator对象的ExecutionContext指向当前EC，并将其state修改为suspended</li>\n<li>从EC栈弹出当前的EC</li>\n<li>返回(normal, 1中的结果值, null)</li>\n</ol>\n<p>可以看到，yield本身会先获得表达式的值后，将EC从栈顶弹出，交予generator对象。最后会返回一个结构，其含有三个属性，分别为运行结果、计算的结果值和null，Resume在检测到这个结构后，将停止代码的运行</p>\n<p>这里yield之后将会返回到当前函数之外，作用域将发生改变，EC栈中的栈顶也会随之改变。而我们在generator function的函数体内部的这个EC，在下一次回来继续执行时依旧需要使用，所以这里就要交给generator对象代为管理一下，等下次回来，将重新压入EC栈的栈顶</p>\n<h1 id=\"return行为\">return行为</h1><p>当执行到<code>return e</code>时：</p>\n<ol>\n<li>计算出表达式e的值</li>\n<li>获取当前EC，并从中获取currentGenerator，也就是return所在的generator对象</li>\n<li>将这个generator对象的状态修改为closed</li>\n<li>创建一个class为StopIteration的新对象，并使其value属性为1中计算的结果值</li>\n<li>throw这个对象</li>\n</ol>\n<p>return也是一样，它同样需要先计算出表达式的值。但之后它获得了generator对象并不是为了做EC栈的维护，而是为了修改generator对象的状态</p>\n<h1 id=\"Generator对象的私有属性\">Generator对象的私有属性</h1><ul>\n<li>prototype：Object.prototype</li>\n<li>code：generator函数的函数体</li>\n<li>ExecutionContext：内部代码运行使用的EC</li>\n<li>Scope：作用域链</li>\n<li>Handler：标准的generator句柄</li>\n<li>State：newborn、executing、suspended、closed</li>\n<li>Send：看内部方法部分</li>\n<li>Throw：看内部方法部分</li>\n<li>Close：看内部方法部分</li>\n</ul>\n<h1 id=\"外部接口\">外部接口</h1><h2 id=\"next\">next</h2><ol>\n<li>如果this指向的不是generator对象，抛异常</li>\n<li>调用this.send，传入一个undefined</li>\n<li>返回结果</li>\n</ol>\n<p>调用私有send方法</p>\n<h2 id=\"send\">send</h2><p>send方法允许指定一个值，作为上一次yield的返回值</p>\n<ol>\n<li>如果this指向的不是generator对象，抛异常</li>\n<li>调用this.send，传入当前第一个参数</li>\n<li>返回结果</li>\n</ol>\n<p>同样是调用私有send方法，不过传入了参数</p>\n<h2 id=\"throw\">throw</h2><ol>\n<li>如果this指向的不是generator对象，抛异常</li>\n<li>调用this.throw，传入当前第一个参数</li>\n<li>返回结果</li>\n</ol>\n<h2 id=\"close\">close</h2><p>调用close方法可以直接以当前的value作为Generator的返回值</p>\n<ol>\n<li>如果this指向的不是generator对象，抛异常</li>\n<li>调用this.close，不传入任何参数</li>\n<li>返回结果</li>\n</ol>\n<h2 id=\"iterate\">iterate</h2><p>由于每个generator对象都是一个iterator对象，直接<code>return this</code>就可以了</p>\n<h2 id=\"小结\">小结</h2><p>接口都是内部方法的一层封装，可以看到next和send实际上都是send内部方法的包装</p>\n<h1 id=\"状态定义\">状态定义</h1><ul>\n<li>newborn：Code不为null，EC为null</li>\n<li>executing：Code为null，EC不为null，且generator对象的EC为当前EC</li>\n<li>suspended：Code为null，EC不为null，且generator对象的EC不为当前EC</li>\n<li>closed：Code为null，EC为null</li>\n</ul>\n<p>调用了generator function后，生成的generator对象状态即为newborn。也就表明当前generator对象刚刚新建，还没有运行里面的任何代码。同时可以看到EC为null，说明内部运行时的EC并不存在</p>\n<p>调用了send方法后，状态会修改为executing，send方法会使用Resume去执行代码，直到遇到yield或者return。遇到yield后，代码停止继续执行，状态修改为suspended，等待下次send。遇到return后，状态将被修改为closed，说明执行完毕。</p>\n<p>当然也可以通过close方法，手动修改状态为closed</p>\n<h1 id=\"内部方法\">内部方法</h1><h2 id=\"send方法\">send方法</h2><ol>\n<li>判断generator对象的state，如果是executing或者closed，就报错。已经在运行了不能重复运行，已经关闭的自然不能运行</li>\n<li>如果state为newborn<ol>\n<li>将判断传入的参数是否为undefined（外部接口next传入undefined，send则传入给的参数）。这里如果不是undefined，就报错。也就是说刚创建的generator对象不能调用<strong>含有参数的send</strong>外部接口。</li>\n<li>创建一个新的EC，这个新的EC的currentGenerator执行这个generator对象，其作用域链为这个generator对象的作用域链</li>\n<li>将这个EC压入EC栈中</li>\n<li>执行generator中的代码，并返回或得到的结果</li>\n</ol>\n</li>\n<li>能到这，说明state只能是suspended。将state修改为executing，通过Resume(generator的ExecutionContext, normal, 传入的参数)获取结果并返回</li>\n</ol>\n<p>generator对象的next和send方法的真正实现，其只处理newborn和suspended状态</p>\n<p>在newborn状态下，这个generator内部的代码还没有被执行，其内部代码执行时的EC也没有被创建。所以需要创建一个EC并压入EC栈中</p>\n<p>而state为suspended就没有这个EC初始化的过程了，内部代码执行时的EC已经在generator的ExecutionContext上了，所以只要修改状态为executing，然后使用Resume执行代码就好</p>\n<h2 id=\"throw-1\">throw</h2><ol>\n<li>获取generator对象的state，如果为executing或者closed，无法抛异常，报错</li>\n<li>如果state为newborn，那么state修改为closed，code修改为null，返回一个包含传入参数的异常</li>\n<li>到这里说明state为suspended，修改state为executing，然后通过Resume(generator.ExectionContext, throw, 传入的参数)获得结果，并返回</li>\n</ol>\n<p>这里如果是suspended，那么需要通过Resume，且completionType为throw来进行抛错</p>\n<h2 id=\"close-1\">close</h2><ol>\n<li>获取generator对象的state，如果state为executing，那说明代码正在运行，为了防止出现错误，禁止close。</li>\n<li>如果state已经是closed了，那直接return就好</li>\n<li>如果state为newborn，state修改为closed，code修改为null，然后返回(normal, undefined, null)</li>\n<li>如果state为suspended，将其修改为executing，通过Resume(generator.ExecutionContext, return, undefined)获得结果，然后修改状态为closed，返回Resume获得的结果</li>\n</ol>\n<p>调用close方法可以直接以当前的value作为Generator的返回值，当为newborn时，还没有value，自然是undeinfed。而如果是suspended，就有value了，那么就需要通过Resume，且completionType为return来立即返回</p>\n<h2 id=\"Resume(EC,_completionType,_V)\">Resume(EC, completionType, V)</h2><ol>\n<li>将这个传入的EC（generator的ExecutionContext）压入到EC栈中</li>\n<li>从EC通过currentGenerator获取单签generator对象</li>\n<li>设置当前作用域链为当前generator对象的作用域链</li>\n<li>继续执行代码，并根据completionType做相应的处理</li>\n</ol>\n<h1 id=\"NodeJs上的不同\">NodeJs上的不同</h1><p>目前，NodeJs的generator对象上还没有close方法和send方法，但NodeJs中如果next方法传入了参数，行为将和send一样</p>\n<h2 id=\"资料\">资料</h2><p><a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:generators\" target=\"_blank\" rel=\"external\">harmony generators ES Wiki</a></p>\n"}