{"tags":[{"name":"JavaScript","permalink":"http://lingyu.wang/tags/JavaScript/","url":"/async/tags/JavaScript.json","count":39}],"categories":[{"name":"JS技术","permalink":"http://lingyu.wang/categories/JS技术/","url":"/async/categories/JS技术.json","count":13}],"url":"/async/posts/2014/05/10/read-jq-src-2.json","date":1399651200000,"path":{"year":2014,"month":5,"day":10,"name":"read-jq-src-2"},"subtitle":"闲来没事读源码系列——jQuery","title":"jQuery的数据缓存","permalink":"http://lingyu.wang/2014/05/10/read-jq-src-2/","content":"<p>这次记录了一下jQuery的数据缓存——data部分，jq中能使用data接口在节点上进行数据缓存，事实上jq将节点上的数据分成了两个部分：userData和privData，分别表示公有数据和私有数据。私有数据中存放了一些jq的其他功能需要使用的数据，比如自定义事件等等。而userData则存放jq使用者的数据。这两个数据区分别有自己的接口</p>\n<a id=\"more\"></a>\n<h2 id=\"jQuery的数据缓存简介\">jQuery的数据缓存简介</h2><p>jq中能使用data接口在节点上进行数据缓存，事实上jq将节点上的数据分成了两个部分：userData和privData，分别表示公有数据和私有数据。私有数据中存放了一些jq的其他功能需要使用的数据，比如自定义事件等等。而userData则存放jq使用者的数据。这两个数据区分别有自己的接口。</p>\n<p>jq的数据并不是直接存在dom节点中的，jq把所有的数据集中放置在两个数据对象之中，dom节点里只有数据的id。获取或插入数据时，会根据id在数据对象中找到这个dom节点对应的区域，在上面操作。</p>\n<h2 id=\"jq中数据缓存的限制\">jq中数据缓存的限制</h2><p>并不是所有对象或节点都能缓存数据，在<code>jQuery.acceptData</code>中给出了能够缓存数据的对象类型，只有element和document以及一般Object能够缓存数据<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery.acceptData = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> owner </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> owner.nodeType === <span class=\"number\">1</span> || owner.nodeType === <span class=\"number\">9</span> || !( +owner.nodeType );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据对象\">数据对象</h2><p>jq中专门有一个数据对象类Data，用于构造数据对象。私有对象和公有对象都是铜鼓哦这个构造函数创建出来的Data类实例，其构造函数为<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Data</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*老式浏览器中没有Object.preventExtensions和Object.freeze方法来限制堆对象的操作。返回一个新建的空对象，他们没有set方法*/</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty( <span class=\"keyword\">this</span>.cache = &#123;&#125;, <span class=\"number\">0</span>, &#123;</span><br><span class=\"line\">        get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">/*为这个数据对象添上jQuery版本号+随机数的版本号*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.expando = jQuery.expando + <span class=\"built_in\">Math</span>.random();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"静态方法和属性\">静态方法和属性</h3><h4 id=\"uid\">uid</h4><p>数据对象的id，自增</p>\n<h4 id=\"accepts\">accepts</h4><p>判断是否能够接受数据，直接指向之前的acceptData</p>\n<h3 id=\"核心方法\">核心方法</h3><h4 id=\"key_(owner)\">key (owner)</h4><p>owner表示数据的所有者，这个方法返回这个所有者所拥有的数据id</p>\n<p>这个方法中首先会判断owner能否接受数据数据，不能直接返回0</p>\n<p>然后会创建一个descriptor用于在创建时作为辅助对象，并尝试获取owner的当前jq版本的数据id，放在unlock变量中</p>\n<p>如果这个unlock不存在，说明这个owner没有当前版本的数据缓存，那么就得新建了。首先通过<code>Data.uid</code>自增的方式获得一个唯一的id，然后将这个id写入到descriptor，jq首先会尝试es5的<code>Object.defineProperties</code>方法来创建一个不可遍历，不可写的键值对，键为jq版本号，值为数据id。如果不能使用es5的方法，会退一步使用extend写入。往owner中成功写入id后，再在数据对象的cache区域中申请一个区域就行了，实际上就是申请了一个空对象</p>\n<p>最后，如果owner本来就id直接返回，否则返回新申请的id</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> owner </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*如果这个所有者不能接收数据，返回0*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !Data.accepts( owner ) ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> descriptor = &#123;&#125;,</span><br><span class=\"line\">        <span class=\"comment\">/*获取这个所有者已经有这个版本的数据的id*/</span></span><br><span class=\"line\">        unlock = owner[ <span class=\"keyword\">this</span>.expando ];</span><br><span class=\"line\">    <span class=\"comment\">/*如果这个所有者没有对应的数据对象，那么创建一个*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !unlock ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*自增的uid*/</span></span><br><span class=\"line\">        unlock = Data.uid++;</span><br><span class=\"line\">        <span class=\"comment\">/*往这个所有者中添加这个数据对象的版本号，并将其值设为id*/</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            descriptor[ <span class=\"keyword\">this</span>.expando ] = &#123; value: unlock &#125;;</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperties( owner, descriptor );</span><br><span class=\"line\">        <span class=\"comment\">/*如果不能使用Object.defineProperites，那么直接使用extend*/</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> ( e ) &#123;</span><br><span class=\"line\">            descriptor[ <span class=\"keyword\">this</span>.expando ] = unlock;</span><br><span class=\"line\">            jQuery.extend( owner, descriptor );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*在cache中创建对象的数据空间*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !<span class=\"keyword\">this</span>.cache[ unlock ] ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cache[ unlock ] = &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*返回这个新的id*/</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> unlock;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h4 id=\"set_(owner,_data,_value)\">set (owner, data, value)</h4><p>既然我们成功申请了空间，那么自然需要一个方法往这个空间里面添加我们的缓冲数据，set就是干这个的</p>\n<p>owner是数据所有者，data是需要加入的数据对象或名称，value则是当data表示数据名称时，它用来表示数据的值。可以看出，这是一个兼容多种接口的方法</p>\n<p>逻辑很简单，先获得owner的id，这里使用上面的key方法获得id，保证了获得id后，一定已经有相应的数据空间</p>\n<p>获取到id后做接口兼容判断，如果data是字符串，直接往这个dom的数据空间中写入<code>data:value</code>键值对就行了。如果data不是字符串，而是一个对象，那么将这个对象中的键值对一一写入到数据空间中。这里有一个小优化，当数据空间中没有数据的时候，使用了<code>jQuery.extend</code>来直接浅拷贝进去</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*加入数据（往cache中加数据）*/</span></span><br><span class=\"line\">set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> owner, data, value </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prop,</span><br><span class=\"line\">        <span class=\"comment\">/*首先获得这个所有者的id（没有就新建一个）*/</span></span><br><span class=\"line\">        unlock = <span class=\"keyword\">this</span>.key( owner ),</span><br><span class=\"line\">        <span class=\"comment\">/*获得这个数据对象对应的cache内的空间*/</span></span><br><span class=\"line\">        cache = <span class=\"keyword\">this</span>.cache[ unlock ];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*如果数据时string直接写进去*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> data === <span class=\"string\">\"string\"</span> ) &#123;</span><br><span class=\"line\">        cache[ data ] = value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*如果不是string，是对象，那么遍历对象复制进去，如果正好cache中是空对象，直接extend*/</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( jQuery.isEmptyObject( cache ) ) &#123;</span><br><span class=\"line\">            jQuery.extend( <span class=\"keyword\">this</span>.cache[ unlock ], data );</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( prop <span class=\"keyword\">in</span> data ) &#123;</span><br><span class=\"line\">                cache[ prop ] = data[ prop ];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h4 id=\"get_(owner,_key)\">get (owner, key)</h4><p>从owner对应的数据空间中获取数据的方法，也是一个兼容多接口的方法，当存在key时只获取key所对应的值。否则获取整个数据空间对象</p>\n<p>思路很明了也很简单，首先获取owner的数据id，然后获取元素的数据空间，最后判断是否存在key来确定返回的内容</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*获取数据（从cache中取数据）*/</span></span><br><span class=\"line\">get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> owner, key </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*通过owner获取id，从cache中获取在对应的完整缓存对象*/</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> cache = <span class=\"keyword\">this</span>.cache[ <span class=\"keyword\">this</span>.key( owner ) ];</span><br><span class=\"line\">    <span class=\"comment\">/*如果美没有申明要取的键，返回整个缓存，否则只返回键对应的值*/</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> key === <span class=\"literal\">undefined</span> ?</span><br><span class=\"line\">        cache : cache[ key ];</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h4 id=\"access_(owner,_key,_value)\">access (owner, key, value)</h4><p>一个包含了get和set的接口方法，根据参数来判断调用set方法还是get方法，使接口符合jq风格</p>\n<p>owner是数据所有者，这个参数总是存在的，接口分为以下三种：</p>\n<ol>\n<li>如果没有key和value，那么使用get方法获取整个数据空间对象</li>\n<li>如果只有key而key是字符串，没有value，那么使用get方法获得数据空间中key对应的值</li>\n<li>如果只有key而key是对象，那么使用set方法将key中所有的键值对写入到数据空间中</li>\n<li>如果key和value都存在，那么使用set方法往数据空间中写入key:value键值对</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">access: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> owner, key, value </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stored;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( key === <span class=\"literal\">undefined</span> ||</span><br><span class=\"line\">            ((key &amp;&amp; <span class=\"keyword\">typeof</span> key === <span class=\"string\">\"string\"</span>) &amp;&amp; value === <span class=\"literal\">undefined</span>) ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        stored = <span class=\"keyword\">this</span>.get( owner, key );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> stored !== <span class=\"literal\">undefined</span> ?</span><br><span class=\"line\">            stored : <span class=\"keyword\">this</span>.get( owner, jQuery.camelCase(key) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.set( owner, key, value );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value !== <span class=\"literal\">undefined</span> ? value : key;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h4 id=\"remove_(owner,_key)\">remove (owner, key)</h4><p>既然有增改查，必然有删。这里就是删除，需要注意的是这里key可能是数组，如果是数组，就要把数组中所有元素作为键分别进行删除了。这里会把所有需要删除的key包裹成一个数组，最后字需要循环遍历这个数组使用delete删除就行了</p>\n<p>需要注意的是，这里有一个驼峰判断，比如<code>-moz-transform</code>这样的属性，会转成驼峰形式<code>mozTransform</code>，但删除时候为了保险起见会尝试普通key形式和驼峰的key。另外key如果是一个带有空白字符（比如空格或回车等）的字符串，那么也会做分割，生成一个key数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*从owner移除属性 */</span></span><br><span class=\"line\">remove: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> owner, key </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i, name, camel,</span><br><span class=\"line\">        unlock = <span class=\"keyword\">this</span>.key( owner ),</span><br><span class=\"line\">        cache = <span class=\"keyword\">this</span>.cache[ unlock ];</span><br><span class=\"line\">    <span class=\"comment\">/*如果没有key，移除整个owner所拥有的缓存*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( key === <span class=\"literal\">undefined</span> ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cache[ unlock ] = &#123;&#125;;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Support array or space separated string of keys</span></span><br><span class=\"line\">        <span class=\"comment\">/*如果key是数组，那么将key中的每个元素转换成驼峰形式然后进行删除*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( jQuery.isArray( key ) ) &#123;</span><br><span class=\"line\">            name = key.concat( key.map( jQuery.camelCase ) );</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*如果key不是数组，将key转成驼峰*/</span></span><br><span class=\"line\">            camel = jQuery.camelCase( key );</span><br><span class=\"line\">            <span class=\"comment\">/*如果cache[key]存在，那么删除key和驼峰形式key对应的键值对*/</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( key <span class=\"keyword\">in</span> cache ) &#123;</span><br><span class=\"line\">                name = [ key, camel ];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*如果cache[key]不存在，那么要尝试删除驼峰形式的key*/</span></span><br><span class=\"line\">                name = camel;</span><br><span class=\"line\">                <span class=\"comment\">/*key可能是一个带有空格的字符串，所以需要对齐进行分割来获得所有要删除的key*/</span></span><br><span class=\"line\">                name = name <span class=\"keyword\">in</span> cache ?</span><br><span class=\"line\">                    [ name ] : ( name.match( rnotwhite ) || [] );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*上面都是获取移除的key的数组，真真移除key是在这里，用的delete*/</span></span><br><span class=\"line\">        i = name.length;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( i-- ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> cache[ name[ i ] ];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h4 id=\"hasData_(owner)\">hasData (owner)</h4><p>判断一个元素是否含有数据，直接判断这个元素对应的数据空间是否存在，如果存在看它是不是空对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*判断是否存在数据*/</span></span><br><span class=\"line\">hasData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> owner </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*判断缓存对象是否是空对象*/</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> !jQuery.isEmptyObject(</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cache[ owner[ <span class=\"keyword\">this</span>.expando ] ] || &#123;&#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"discard_(owner)\">discard (owner)</h4><p>移除掉owner的所有缓存，直接在cache上用delete删<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*移除整个缓存对象*/</span></span><br><span class=\"line\">discard: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> owner </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( owner[ <span class=\"keyword\">this</span>.expando ] ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.cache[ owner[ <span class=\"keyword\">this</span>.expando ] ];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数据对象创建\">数据对象创建</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*私有数据对象*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data_priv = <span class=\"keyword\">new</span> Data();</span><br><span class=\"line\"><span class=\"comment\">/*公有数据对象*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data_user = <span class=\"keyword\">new</span> Data();</span><br></pre></td></tr></table></figure>\n<p>可以看到，私有数据对象和公有数据对象都是数据对象构造函数的实例</p>\n<h2 id=\"jQuery对数据对象操作接口\">jQuery对数据对象操作接口</h2><h3 id=\"dataAttr方法\">dataAttr方法</h3><p>事由于HTML5存在<code>data-xxx</code>来在DOM节点上缓存数据，jq的数据缓存机制决定，当用户从DOM节点获取数据时，不仅获得其在jq中缓存的数据，也会获得使用HTML5的<code>data-xxx</code>缓存的数据，这个方法就是读取DOM节点中的所有<code>data-xxx</code>形式的数据，将其被分到jq的数据对象中。由于HTML5的缓存很弱，只能缓存字符串类型，这里在保存前还会做相应的数据转换，转换诸如true、false、null、数字以及还会判断是否是json，然后解析json</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function dataAttr( elem, key, data ) &#123;&#10;    var name;&#10;&#10;    /*&#22914;&#26524;&#27809;&#26377;data&#65292;&#32780;&#20803;&#32032;&#20026;element&#31867;&#22411;*/&#10;    if ( data === undefined &#38;&#38; elem.nodeType === 1 ) &#123;&#10;&#10;        /*&#20174;data-xxx&#23646;&#24615;&#20013;&#33719;&#21462;&#25968;&#25454;*/&#10;        name = &#34;data-&#34; + key.replace( rmultiDash, &#34;-$1&#34; ).toLowerCase();&#10;        data = elem.getAttribute( name );&#10;        /*&#22914;&#26524;&#23545;&#35937;&#26159;&#23383;&#31526;&#20018;&#65292;&#20998;&#21035;&#23581;&#35797;&#36716;&#25104;true&#12289;false&#12289;null&#65292;&#22914;&#26524;&#20351;&#29992;&#123;&#125;&#21253;&#35065;&#65292;&#24403;&#20570;JSON&#35299;&#26512;*/&#10;        if ( typeof data === &#34;string&#34; ) &#123;&#10;            try &#123;&#10;                data = data === &#34;true&#34; ? true :&#10;                    data === &#34;false&#34; ? false :&#10;                    data === &#34;null&#34; ? null :&#10;                    // Only convert to a number if it doesn&#39;t change the string&#10;                    +data + &#34;&#34; === data ? +data :&#10;                    rbrace.test( data ) ? jQuery.parseJSON( data ) :&#10;                    data;&#10;            &#125; catch( e ) &#123;&#125;&#10;&#10;            /*&#20889;&#20837;&#21040;&#20844;&#20849;&#25968;&#25454;&#23545;&#35937;&#20013;*/&#10;            data_user.set( elem, key, data );&#10;        &#125; else &#123;&#10;            data = undefined;&#10;        &#125;&#10;    &#125;&#10;    return data;&#10;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"静态方法\">静态方法</h3><p>jq提供一系列的静态方法操作数据对象，jq为公有数据对象和私有数据对象分别定义了一套接口，私有数据对象的操作前一般都带下划线</p>\n<h4 id=\"hasData_(elem)\">hasData (elem)</h4><p>判断元素是否含有数据，这里会检测公有数据和私有数据<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hasData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> elem </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data_user.hasData( elem ) || data_priv.hasData( elem );</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"data_(elem,_name,_data)\">data (elem, name, data)</h4><p>通过数据对象的access方法获得或写入数据，只操作公有数据对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> elem, name, data </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data_user.access( elem, name, data );</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"removeData_(elem,_name)\">removeData (elem, name)</h4><p>从数据对象移除数据，只操作公有数据对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">removeData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> elem, name </span>) </span>&#123;</span><br><span class=\"line\">    data_user.remove( elem, name );</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"_data_(elem,_name,_data)\">_data (elem, name, data)</h4><p>通过数据对象的access方法获得或写入数据，只操作私有数据对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_data: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> elem, name, data </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data_priv.access( elem, name, data );</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"_removeData_(elem,_name)\">_removeData (elem, name)</h4><p>从数据对象移除数据，只操作私有数据对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_removeData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> elem, name </span>) </span>&#123;</span><br><span class=\"line\">    data_priv.remove( elem, name );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"在jq对象上添加数据对象操作方法\">在jq对象上添加数据对象操作方法</h3><p>jq对象既然维护了一系列的DOM节点，自然通过扩展fn的方式为这些DOM节点提供数据对象操作方法</p>\n<h4 id=\"data_(key,_value)\">data (key, value)</h4><p>jq的接口有个特点，写全部，得第一。当往jq对象中写入数据时，每个DOM节点都会被写入数据，而读取数据时，只会读取DOM列表中的第一个节点的数据。这里也不例外。这个方法同样是重载方法：</p>\n<ol>\n<li>如果key和value都不存在，获取第一个元素的公有对象。在获取数据前，会检查第一个DOM节点，判断它是否存在HTML5的data属性，如果存在，会获取其值并复制到元素的jq数据对象中，并在元素的私有数据空间写入一个<code>hasDataAttrs:true</code>作为标示，最后返回合并了HTML5的data后的数据空间对象</li>\n<li>如果key是对象，那么每个DOM节点都需要写入这个对象，然后返回这个jq对象</li>\n<li>否则使用access来判断具体需要获取值还是写入。获取时，在含有DOM节点，有key而没有value时，获取key对应的值。如果通过直接key没有获得数据，就尝试将key转换为驼峰格式来获取对应的值。如果还获取不到，那么尝试使用dataAttr方法获取包含了HTML5的data的数据。如果还是获取不到，我们尽力了，返回undefined。写入时，则会遍历jq对象中所有的DOM节点，每个节点都会先检查是否有驼峰形式的key，无论有没有都写进去。但如果存在连字符，而没有驼峰key，那么写入普通key的键值对作为备份。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> key, value </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i, name, data,</span><br><span class=\"line\">        elem = <span class=\"keyword\">this</span>[ <span class=\"number\">0</span> ],</span><br><span class=\"line\">        attrs = elem &amp;&amp; elem.attributes;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*如果没有key也没有value，获取jq对象中第一个元素的所有公有数据，需要考虑dom元素的data-属性*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( key === <span class=\"literal\">undefined</span> ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*jq对象中有节点*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( <span class=\"keyword\">this</span>.length ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*第一个节点的数据*/</span></span><br><span class=\"line\">            data = data_user.get( elem );</span><br><span class=\"line\">            <span class=\"comment\">/*如果节点为element类型且私有数据中没有标记hasDataAttrs</span><br><span class=\"line\">            将节点中的所有data-类型的属性写入到公共数据中</span><br><span class=\"line\">            然后在私有数据中设定hasDataAttrs为true*/</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( elem.nodeType === <span class=\"number\">1</span> &amp;&amp; !data_priv.get( elem, <span class=\"string\">\"hasDataAttrs\"</span> ) ) &#123;</span><br><span class=\"line\">                i = attrs.length;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ( i-- ) &#123;</span><br><span class=\"line\">                    name = attrs[ i ].name;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( name.indexOf( <span class=\"string\">\"data-\"</span> ) === <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">                        name = jQuery.camelCase( name.slice(<span class=\"number\">5</span>) );</span><br><span class=\"line\">                        dataAttr( elem, name, data[ name ] );</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                data_priv.set( elem, <span class=\"string\">\"hasDataAttrs\"</span>, <span class=\"literal\">true</span> );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*如果key是一个对象，说明需要将这个对象添加到jq中每个节点的公有数据中*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> key === <span class=\"string\">\"object\"</span> ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            data_user.set( <span class=\"keyword\">this</span>, key );</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*通过access判断*/</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> access( <span class=\"keyword\">this</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> value </span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> data,</span><br><span class=\"line\">            <span class=\"comment\">/*生成驼峰的key*/</span></span><br><span class=\"line\">            camelKey = jQuery.camelCase( key );</span><br><span class=\"line\">        <span class=\"comment\">/*如果jq对象中有元素，且没有value，说明调用get获取数据*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( elem &amp;&amp; value === <span class=\"literal\">undefined</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*直接使用key获取*/</span></span><br><span class=\"line\">            data = data_user.get( elem, key );</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( data !== <span class=\"literal\">undefined</span> ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/*如果直接用key未能获取导数据，尝试驼峰格式的key*/</span></span><br><span class=\"line\">            data = data_user.get( elem, camelKey );</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( data !== <span class=\"literal\">undefined</span> ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/*如果还是无法获取，尝试从data-属性获取*/</span></span><br><span class=\"line\">            data = dataAttr( elem, camelKey, <span class=\"literal\">undefined</span> );</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( data !== <span class=\"literal\">undefined</span> ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/*我们尝试了所有情况，但还是没有数据，返回undefined*/</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*写入数据*/</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">/*通过驼峰形式key获取公共数据*/</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> data = data_user.get( <span class=\"keyword\">this</span>, camelKey );</span><br><span class=\"line\">            <span class=\"comment\">/*往驼峰形式key中写入公共数据*/</span></span><br><span class=\"line\">            data_user.set( <span class=\"keyword\">this</span>, camelKey, value );</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/*key中存在连字符，而通过驼峰形式的key获取不到数据，需要直接对key写入数据*/</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( key.indexOf(<span class=\"string\">\"-\"</span>) !== -<span class=\"number\">1</span> &amp;&amp; data !== <span class=\"literal\">undefined</span> ) &#123;</span><br><span class=\"line\">                data_user.set( <span class=\"keyword\">this</span>, key, value );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"literal\">null</span>, value, <span class=\"built_in\">arguments</span>.length &gt; <span class=\"number\">1</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span> );</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h4 id=\"removeData_(key)\">removeData (key)</h4><p>这个就比较简单了，直接遍历jq对象中所有的DOM节点，每个都删除就行了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*从公共数据中移除包含key（或key中元素）的键值对*/</span></span><br><span class=\"line\">removeData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> key </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        data_user.remove( <span class=\"keyword\">this</span>, key );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"为动画服务的queue和dequeue\">为动画服务的queue和dequeue</h2><p>事实上，jq还提供了一套为动画服务器的queue和dequeue接口，为动画服务提供data操作。这套接口操作是在私有数据对象上的。</p>\n<h3 id=\"静态方法-1\">静态方法</h3><h4 id=\"queue_(elem,_type,_data)\">queue (elem, type, data)</h4><p>逻辑不复杂，也分读写两种情况。以<code>type + &quot;queue&quot;</code>（如果没有传入type，默认为fxqueue）为key，从私有数据空间获取数据。</p>\n<p>如果是写情况，没有获得到数据或或得到的数据不是数组时，直接把key:data这样的键值对写进私有数据空间。如果获得到数据且是个数组，那么把data加在这个数组的后面。</p>\n<p>如果是读情况，获得导数据后直接返回，如果没有数据，返回一个空数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*压入或读取一组数据*/</span></span><br><span class=\"line\">queue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> elem, type, data </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> queue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( elem ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*重命名一下type，默认叫fxqueue*/</span></span><br><span class=\"line\">        type = ( type || <span class=\"string\">\"fx\"</span> ) + <span class=\"string\">\"queue\"</span>;</span><br><span class=\"line\">        <span class=\"comment\">/*从私有数据中获得已有的queue数据*/</span></span><br><span class=\"line\">        queue = data_priv.get( elem, type );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*如果存在data，需要写入数据*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( data ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*之前没有缓存中没有数据且data是一个数组，那么就把这个data缓存*/</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( !queue || jQuery.isArray( data ) ) &#123;</span><br><span class=\"line\">                queue = data_priv.access( elem, type, jQuery.makeArray(data) );</span><br><span class=\"line\">            <span class=\"comment\">/*之前有数据，直接把data连在数据数组后头*/</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                queue.push( data );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queue || [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h4 id=\"dequeue_(elem,_type)\">dequeue (elem, type)</h4><p>事实上，在使用queue时一般都是压入一个函数和字符串混合成的数组，这里需要递归去执行这些函数</p>\n<p>会找到第一个不是inprogress字符串的函数弹出并裕兴，然后将inprogress字符串压入，递归执行dequeue方法。如果所有全部执行完（数组为空），那么这组数据可以删除掉了。事实上在每次dequeue函数结束完成之后，会调动钩子中的函数，这些将会在动画中详细介绍</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*运行一组数据，找到第一个不是inprogress字符串的函数弹出并运行，然后将inprogress重新压入，递归执行dequeue，如果函数全部执行完，那么通过钩子把这组数据删掉*/</span></span><br><span class=\"line\">dequeue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> elem, type </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*获取type，默认为fx*/</span></span><br><span class=\"line\">    type = type || <span class=\"string\">\"fx\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*获取一组数据*/</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> queue = jQuery.queue( elem, type ),</span><br><span class=\"line\">        startLength = queue.length,</span><br><span class=\"line\">        <span class=\"comment\">/*获取状态*/</span></span><br><span class=\"line\">        fn = queue.shift(),</span><br><span class=\"line\">        <span class=\"comment\">/*获取元素的钩子*/</span></span><br><span class=\"line\">        hooks = jQuery._queueHooks( elem, type ),</span><br><span class=\"line\">        next = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            jQuery.dequeue( elem, type );</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*如果当前数据第一个元素是字符串，说明正在处理，拿到它下一个元素，是个函数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( fn === <span class=\"string\">\"inprogress\"</span> ) &#123;</span><br><span class=\"line\">        fn = queue.shift();</span><br><span class=\"line\">        startLength--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( fn ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*调用这个函数，如果类型是默认的fx，那么将继续处于处理中状态*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type === <span class=\"string\">\"fx\"</span> ) &#123;</span><br><span class=\"line\">            queue.unshift( <span class=\"string\">\"inprogress\"</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*删除掉钩子中的停止函数*/</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> hooks.stop;</span><br><span class=\"line\">        <span class=\"comment\">/*在这个函数上调用，并提供钩子*/</span></span><br><span class=\"line\">        fn.call( elem, next, hooks );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*如果队列已经空了，那么调用empty删除掉这个键值对*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !startLength &amp;&amp; hooks ) &#123;</span><br><span class=\"line\">        hooks.empty.fire();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h4 id=\"_queueHooks_(elem,_type)\">_queueHooks (elem, type)</h4><p>提供默认钩子的函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_queueHooks: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> elem, type </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> key = type + <span class=\"string\">\"queueHooks\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data_priv.get( elem, key ) || data_priv.access( elem, key, &#123;</span><br><span class=\"line\">        empty: jQuery.Callbacks(<span class=\"string\">\"once memory\"</span>).add(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            data_priv.remove( elem, [ type + <span class=\"string\">\"queue\"</span>, key ] );</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"jq对象上的queue和dequeue\">jq对象上的queue和dequeue</h3><h4 id=\"queue_(type,_data)\">queue (type, data)</h4><p>对jq对象中的每个DOM节点分别调用queue方法。但如果数据的第一个元素是函数而不是inprogress，那么会立即调用dequeue开始执行<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> type, data </span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> setter = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> type !== <span class=\"string\">\"string\"</span> ) &#123;</span><br><span class=\"line\">            data = type;</span><br><span class=\"line\">            type = <span class=\"string\">\"fx\"</span>;</span><br><span class=\"line\">            setter--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( <span class=\"built_in\">arguments</span>.length &lt; setter ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> jQuery.queue( <span class=\"keyword\">this</span>[<span class=\"number\">0</span>], type );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> data === <span class=\"literal\">undefined</span> ?</span><br><span class=\"line\">            <span class=\"keyword\">this</span> :</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> queue = jQuery.queue( <span class=\"keyword\">this</span>, type, data );</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// ensure a hooks for this queue</span></span><br><span class=\"line\">                jQuery._queueHooks( <span class=\"keyword\">this</span>, type );</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( type === <span class=\"string\">\"fx\"</span> &amp;&amp; queue[<span class=\"number\">0</span>] !== <span class=\"string\">\"inprogress\"</span> ) &#123;</span><br><span class=\"line\">                    jQuery.dequeue( <span class=\"keyword\">this</span>, type );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    &#125;,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"dequeue_(type)\">dequeue (type)</h4><p>对jq对象中每个DOM元素执行dequeue操作</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*对jq对象中的每个元素执行dequeue操作，执行内部已压入的函数*/</span></span><br><span class=\"line\">dequeue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> type </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        jQuery.dequeue( <span class=\"keyword\">this</span>, type );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h4 id=\"clearQueue_(type)\">clearQueue (type)</h4><p>清除jq对象中每个DOM的type对应的数据列表<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*清除对应的类型的操作列表*/</span></span><br><span class=\"line\">clearQueue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> type </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.queue( type || <span class=\"string\">\"fx\"</span>, [] );</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"promise_(type,_obj)\">promise (type, obj)</h4><p>获取一个promise对象，这个promise对象会在jq中的所有DOM元素type所对应的数据列表中的方法都已被执行完时resolve<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*创建一个deferred对象，如果队列中所有的函数都被执行完毕，那么resolve这个deferred对象*/</span></span><br><span class=\"line\">promise: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> type, obj </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp,</span><br><span class=\"line\">        count = <span class=\"number\">1</span>,</span><br><span class=\"line\">        defer = jQuery.Deferred(),</span><br><span class=\"line\">        elements = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">        i = <span class=\"keyword\">this</span>.length,</span><br><span class=\"line\">        resolve = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( !( --count ) ) &#123;</span><br><span class=\"line\">                defer.resolveWith( elements, [ elements ] );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> type !== <span class=\"string\">\"string\"</span> ) &#123;</span><br><span class=\"line\">        obj = type;</span><br><span class=\"line\">        type = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    type = type || <span class=\"string\">\"fx\"</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( i-- ) &#123;</span><br><span class=\"line\">        tmp = data_priv.get( elements[ i ], type + <span class=\"string\">\"queueHooks\"</span> );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( tmp &amp;&amp; tmp.empty ) &#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            tmp.empty.add( resolve );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> defer.promise( obj );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\">总结</h2><p>缓存的这块的核心知识还是比较好理解的，除了queue和dequeue要结合动画理解，需要注意的是HTML5的data带来的问题。其他的实际上就是对象上的增删改查了</p>\n"}