{"tags":[{"name":"JavaScript","permalink":"http://lingyu.wang/tags/JavaScript/","url":"/async/tags/JavaScript.json","count":39}],"categories":[{"name":"JS技术","permalink":"http://lingyu.wang/categories/JS技术/","url":"/async/categories/JS技术.json","count":13}],"url":"/async/posts/2014/05/17/read-jq-src-5.json","date":1400256000000,"path":{"year":2014,"month":5,"day":17,"name":"read-jq-src-5"},"subtitle":"闲来没事读源码系列——jQuery","title":"jQuery的异步控制","permalink":"http://lingyu.wang/2014/05/17/read-jq-src-5/","content":"<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>\n<a id=\"more\"></a>\n<h2 id=\"简介\">简介</h2><p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>\n<h2 id=\"jQuery-Callbacks\">jQuery.Callbacks</h2><p>这是回调函数列表的构造器，内部使用一个数组来保存回调函数列表，并提供一系列的方法来维护这个列表。另外这个列表还有一些状态</p>\n<h3 id=\"配置选项\">配置选项</h3><p>创建一个回调函数列表可能会用到如下参数：</p>\n<ol>\n<li>options：一个选项类表，确定了回调函数列表如何工作，以及一些常见配置</li>\n<li>once：默认情况下回调函数列表的执行时没有次数限制的，但如果设置了once，将设置回调函数列表只会被执行一次</li>\n<li>memory：决定了在回调函数列表在执行过程中，是否会保留上一个函数执行的结果</li>\n<li>unique：决定了回调函数列表中的函数能否重复</li>\n<li>stopOnFalse：决定了在一个回调函数返回false后，后面的回调函数将不会被执行</li>\n</ol>\n<p>接下来看看构造函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">options = <span class=\"keyword\">typeof</span> options === <span class=\"string\">\"string\"</span> ?</span><br><span class=\"line\">    ( optionsCache[ options ] || createOptions( options ) ) :</span><br><span class=\"line\">    jQuery.extend( &#123;&#125;, options );</span><br></pre></td></tr></table></figure>\n<p>options可以是字符串，如<code>&quot;once memory&quot;</code>，如果是字符串，就先进行解析并缓存。如果options是对象，那么直接options就是这个对象</p>\n<h3 id=\"私有变量\">私有变量</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"comment\">// Last fire value (for non-forgettable lists)</span></span><br><span class=\"line\">    <span class=\"comment\">/*用于存放运行结果*/</span></span><br><span class=\"line\">    memory,</span><br><span class=\"line\">    <span class=\"comment\">/*标志所有回调函数列表是否被触发过*/</span></span><br><span class=\"line\">    fired,</span><br><span class=\"line\">    <span class=\"comment\">/*标志当前正在执行回调函数列表中的函数*/</span></span><br><span class=\"line\">    firing,</span><br><span class=\"line\">    <span class=\"comment\">/*第一个被执行的回调函数*/</span></span><br><span class=\"line\">    firingStart,</span><br><span class=\"line\">    <span class=\"comment\">/*回调函数列表的长度*/</span></span><br><span class=\"line\">    firingLength,</span><br><span class=\"line\">    <span class=\"comment\">/*当前执行的回调函数在回调函数列表中的下标，如果移除了回调函数，将会对其进行修改*/</span></span><br><span class=\"line\">    firingIndex,</span><br><span class=\"line\">    <span class=\"comment\">/*保存回调函数的列表*/</span></span><br><span class=\"line\">    list = [],</span><br><span class=\"line\">    <span class=\"comment\">/*如果回调函数列表时多次执行的，那么在运行回调函数列表的过程中，可能会再次触发，这时候就需要一个队列进行等待了*/</span></span><br><span class=\"line\">    stack = !options.once &amp;&amp; [],</span><br></pre></td></tr></table></figure>\n<p>这里面都是一些私有变量，没啥太多好说的，官方代码里也对每个变量都写了注释</p>\n<h3 id=\"触发函数fire\">触发函数fire</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fire = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> data </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*如果使用了memory配置，data会先被保存在memory中*/</span></span><br><span class=\"line\">    memory = options.memory &amp;&amp; data;</span><br><span class=\"line\">    <span class=\"comment\">/*表明这个回调函数列表已经被触发过了*/</span></span><br><span class=\"line\">    fired = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*确定当前执行的回调函数在回调函数列表中的位置*/</span></span><br><span class=\"line\">    firingIndex = firingStart || <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*将起始设为0*/</span></span><br><span class=\"line\">    firingStart = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*获取回调函数列表的总长度*/</span></span><br><span class=\"line\">    firingLength = list.length;</span><br><span class=\"line\">    <span class=\"comment\">/*修改状态为正在执行*/</span></span><br><span class=\"line\">    firing = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*依次执行回调函数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*如果回调函数返回值是false且设定了stopOnFalse，那么执行结束，memory清空*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( list[ firingIndex ].apply( data[ <span class=\"number\">0</span> ], data[ <span class=\"number\">1</span> ] ) === <span class=\"literal\">false</span> &amp;&amp; options.stopOnFalse ) &#123;</span><br><span class=\"line\">            memory = <span class=\"literal\">false</span>; <span class=\"comment\">// To prevent further calls using add</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*修改正在执行状态为false*/</span></span><br><span class=\"line\">    firing = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*如果等待队列中有数据，那么需要获取等待队列中的数据，再次执行回调函数列表*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( list ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*多次执行的话，stack是个数组*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( stack ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*从等待队列中弹出数据再次执行*/</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( stack.length ) &#123;</span><br><span class=\"line\">                fire( stack.shift() );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*如果是单次执行，且所有函数正常执行完成，缓存了最终结果，清空回调函数列表*/</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( memory ) &#123;</span><br><span class=\"line\">            list = [];</span><br><span class=\"line\">        <span class=\"comment\">/*否则说明函数没有正常执行完成，将回调函数列表设为无效*/</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            self.disable();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>这里可以看到触发回调函数列表的逻辑。触发后，会依次执行列表中的回调函数，这里执行时有一个stopOnFalse设置，如果函数返回false，那么就终止执行。另外在执行过程中，如果又有新的执行请求到来，需要将执行请求放入等待队列之中，等待当前执行中的所有回调函数完成之后再重新执行。当然这个设定对once类型的回调函数列表不起作用</p>\n<h3 id=\"实例\">实例</h3><p>接下来创建了一个self对象，并进行了返回，这是个一个构造函数，说明self是真正返回的实例。看看实例中有哪些方法：</p>\n<h4 id=\"add\">add</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( list ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//首先保存当前列表长度</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> start = list.length;</span><br><span class=\"line\">        <span class=\"comment\">/*使用jQuery.each方法遍历深度遍历arguments：</span><br><span class=\"line\">        1. 如果键值对中值为函数，那么直接添加，需要注意的是如果有unique选项，在添加前需要判重</span><br><span class=\"line\">        2. 如果值为对象那么遍历这个对象进行添加 */</span></span><br><span class=\"line\">        (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"> args </span>) </span>&#123;</span><br><span class=\"line\">            jQuery.each( args, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> _, arg </span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> type = jQuery.type( arg );</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( type === <span class=\"string\">\"function\"</span> ) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( !options.unique || !self.has( arg ) ) &#123;</span><br><span class=\"line\">                    list.push( arg );</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( arg &amp;&amp; arg.length &amp;&amp; type !== <span class=\"string\">\"string\"</span> ) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Inspect recursively</span></span><br><span class=\"line\">                    add( arg );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;)( <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">        <span class=\"comment\">/*如果正在执行回调函数列表，那么需要维护一下长度*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( firing ) &#123;</span><br><span class=\"line\">            firingLength = list.length;</span><br><span class=\"line\">        <span class=\"comment\">/*如果memory中已经有值，执行所有新增加的回调函数*/</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( memory ) &#123;</span><br><span class=\"line\">            firingStart = start;</span><br><span class=\"line\">            fire( memory );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*返回this方便链式操作*/</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>这个方法往回调函数列表中添加新函数，jQuery会非常智能的使用each对参数进行深度遍历来添加所有函数。需要注意的是，如果回调函数列表正在执行，添加之后需要维护长度。另外如果memory中有数据，我们就应该立即执行新添加的回调函数</p>\n<h4 id=\"remove\">remove</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">remove: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( list ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*遍历arguments，对每个函数分执行删除操作*/</span></span><br><span class=\"line\">        jQuery.each( <span class=\"built_in\">arguments</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> _, arg </span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> index;</span><br><span class=\"line\">            <span class=\"comment\">/*通过jQuery.inArray获取函数在回调函数列表中的位置*/</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -<span class=\"number\">1</span> ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*删除掉这个函数*/</span></span><br><span class=\"line\">                list.splice( index, <span class=\"number\">1</span> );</span><br><span class=\"line\">                <span class=\"comment\">/*如果正在执行回调函数，需要维护长度和当前正在执行的回调函数的下标*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( firing ) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( index &lt;= firingLength ) &#123;</span><br><span class=\"line\">                        firingLength--;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( index &lt;= firingIndex ) &#123;</span><br><span class=\"line\">                        firingIndex--;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*返回this方便链式操作*/</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>这里同样使用<code>jQuery.each</code>遍历所有参数，获取其中的函数，通过inArray判定，然后通过splice移除。这里需要注意的是，在回调函数列表正在执行时，删除操作同样需要维护长度，另外还可能需要维护当前正在运行的函数的下标</p>\n<h4 id=\"has_(fn)\">has (fn)</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">has: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> fn </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn ? jQuery.inArray( fn, list ) &gt; -<span class=\"number\">1</span> : !!( list &amp;&amp; list.length );</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>判断一个函数是否在回调函数列表中，分判断函数和判断列表两种情况：</p>\n<ol>\n<li>若有fn，直接用inArray判定</li>\n<li>若无fn，直接判断列表是否有长度不为0的list列表</li>\n</ol>\n<h4 id=\"empty\">empty</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">empty: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    list = [];</span><br><span class=\"line\">    firingLength = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>清空回调函数列表，没啥好说的…list社为空数组，长度设为0</p>\n<h4 id=\"disable和disabled\">disable和disabled</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">disabled: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    list = stack = memory = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">disabled: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !list;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>将回调函数列表设定为无效，实际上就是将list，stack，memory设成undefined，检测无效也很简单，直接通过list判断，没设定无效情况下，list都是数组，其必然是真值</p>\n<h4 id=\"lock和locked\">lock和locked</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    stack = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !memory ) &#123;</span><br><span class=\"line\">        self.disable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">locked: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !stack;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>lock和locked故名思意就是将回调函数列表锁住，其判定方式是stack是否存在，在once设置下，stack本来就不存在，直接就是locked。而非once情况下，lock函数会设定stack为undefined，这样就无法在回调函数运行时进行fire了，就算锁住了。另外，如果没有memory，说明回调函数执行失败了，直接disbale掉就好</p>\n<h4 id=\"fireWith和fire\">fireWith和fire</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fireWith: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> context, args </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*如果回调函数列表还有效，没触发过或者可以多次触发，那么就满足触发条件了*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( list &amp;&amp; ( !fired || stack ) ) &#123;</span><br><span class=\"line\">        args = args || [];</span><br><span class=\"line\">        args = [ context, args.slice ? args.slice() : args ];</span><br><span class=\"line\">        <span class=\"comment\">/*如果正在出发，就放到等待队列中*/</span></span><br><span class=\"line\">        <span class=\"comment\">/*如果once且触发过或正在触发，可以从私有方法fire中看到，fired是在方法一开始被设置的，所以无法通过上面的fired条件，能到这里必然是没有触发或多次触发的情况。而没有触发不存在firing状态，也就不需要检测stack了*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( firing ) &#123;</span><br><span class=\"line\">            stack.push( args );</span><br><span class=\"line\">        <span class=\"comment\">/*否则直接触发*/</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            fire( args );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">fire: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    self.fireWith( <span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">fired: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !!fired;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里fire实际上使用fireWith实现的，我们只需要看fireWith就好。这里fireWith将触发回调函数列表的执行，触发条件是：当前回调函数列表有效，且没触发过或可以多次触发（stack存在就是可以多次触发），需要注意的是，如果正在触发，也就是firing状态时，触发请求将会被放入stack中等待</p>\n<p>fired没啥好说的，判断回调函数列表是否被触发过</p>\n<h3 id=\"小结\">小结</h3><p>这个<code>jQuery.Callbacks</code>本质上就是维护一个数组，这个数组中都是函数。一个特点就是可以通过fire方式去挨个执行这些函数，并提供了一些配置来确定执行的过程以及执行的次数。每个Deferred对象将拥有三个Callbacks实例</p>\n<h2 id=\"Deferred\">Deferred</h2><p>jQuery的异步控制使用Deferred/Promise，每一个Deferred对象对应一个Promise对象，首先来看看其构造函数</p>\n<h3 id=\"构造函数\">构造函数</h3><h4 id=\"三个状态，三个操作，三个列表\">三个状态，三个操作，三个列表</h4><p>Deferred有三个状态：</p>\n<ol>\n<li>pending</li>\n<li>resolved</li>\n<li>rejected</li>\n</ol>\n<p>pending状态是最初状态，它等待resolve操作或reject操作，使用resolve操作表示成功，将跳转到resolved状态，而使用reject将跳转到rejected状态，这两个转变是不可逆的。另外在pending状态下可以无限次调用notify操作</p>\n<p>事实上，每个操作对应着一系列的回调函数，看一下定义：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tuples = [</span><br><span class=\"line\">    [ <span class=\"string\">\"resolve\"</span>, <span class=\"string\">\"done\"</span>, jQuery.Callbacks(<span class=\"string\">\"once memory\"</span>), <span class=\"string\">\"resolved\"</span> ],</span><br><span class=\"line\">    [ <span class=\"string\">\"reject\"</span>, <span class=\"string\">\"fail\"</span>, jQuery.Callbacks(<span class=\"string\">\"once memory\"</span>), <span class=\"string\">\"rejected\"</span> ],</span><br><span class=\"line\">    [ <span class=\"string\">\"notify\"</span>, <span class=\"string\">\"progress\"</span>, jQuery.Callbacks(<span class=\"string\">\"memory\"</span>) ]</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这里为resolve、reject、notify这三个操作分别创建了Callbakcs的实例。这里为三个操作的具体定义如下：</p>\n<ol>\n<li>resolve方法，对应的添加回调函数的方法是done，回调函数列表类型是once和memory，运行后状态转变到resolved</li>\n<li>reject方法，对应的添加回调函数的方法是fail，回调函数列表类型是once和memory，运行后状态转变到rejected</li>\n<li>notify方法，对应的添加回调函数的方法为progress，回调函数列表类型是memory，说明可执行多次，执行后不会转变状态</li>\n</ol>\n<p>构造函数下面，会为每一个操作在Promise对象和Deferred对象上生成对应的函数（Promise上是：done、fail、progress。Deferred上是：resolve、reject、notify）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*针对三个操作分别进行加工*/</span></span><br><span class=\"line\">jQuery.each( tuples, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> i, tuple </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*获取操作的回调函数列表*/</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> list = tuple[ <span class=\"number\">2</span> ],</span><br><span class=\"line\">        <span class=\"comment\">/*获取操作执行后的状态*/</span></span><br><span class=\"line\">        stateString = tuple[ <span class=\"number\">3</span> ];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// promise[ done | fail | progress ] = list.add</span></span><br><span class=\"line\">    <span class=\"comment\">/*为promise对象分别生成done、fail、progress方法，直接映射到对应的回调函数列表对象的add添加方法*/</span></span><br><span class=\"line\">    promise[ tuple[<span class=\"number\">1</span>] ] = list.add;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Handle state</span></span><br><span class=\"line\">    <span class=\"comment\">/* 如果状态会改变，说明是resolve方法或reject方法，由于状态转变不可逆，所以需要在回调函数列表最后添加三个函数，分别用于状态修改、使回调函数列表无效、将回调函数列表锁住*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( stateString ) &#123;</span><br><span class=\"line\">        list.add(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// state = [ resolved | rejected ]</span></span><br><span class=\"line\">            state = stateString;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// [ reject_list | resolve_list ].disable; progress_list.lock</span></span><br><span class=\"line\">        &#125;, tuples[ i ^ <span class=\"number\">1</span> ][ <span class=\"number\">2</span> ].disable, tuples[ <span class=\"number\">2</span> ][ <span class=\"number\">2</span> ].lock );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// deferred[ resolve | reject | notify ]</span></span><br><span class=\"line\">    <span class=\"comment\">/*在deferred上添加resolve、reject、notify方法，分别映射到其回调函数列表的fireWith上*/</span></span><br><span class=\"line\">    deferred[ tuple[<span class=\"number\">0</span>] ] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        deferred[ tuple[<span class=\"number\">0</span>] + <span class=\"string\">\"With\"</span> ]( <span class=\"keyword\">this</span> === deferred ? promise : <span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">/*为deferred对象添加resolveWith，rejectWith，notifyWith，对应的回调函数列表的fireWith*/</span></span><br><span class=\"line\">    deferred[ tuple[<span class=\"number\">0</span>] + <span class=\"string\">\"With\"</span> ] = list.fireWith;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上面的三种操作，只是定义了名称，这里才是真正生成对应函数的地方。jq会为每个Deferred对象生成6个方法：</p>\n<ol>\n<li>resolve</li>\n<li>reject</li>\n<li>notify</li>\n<li>resolveWith</li>\n<li>rejectWith</li>\n<li>notifyWith</li>\n</ol>\n<p>上面三个实际上是直接调用下面三个，只不过加了个默认的参数。下面三个实际上就是对应回调函数列表的fireWith方法。</p>\n<p>同时，这里还会为promise增加三个方法：</p>\n<ol>\n<li>done</li>\n<li>fail</li>\n<li>progress</li>\n</ol>\n<p>这三个方法就是为对应的回调函数列表添加新函数的方法，直接映射到对应回调函数列表的add方法就行了</p>\n<p>另外需要注意一下resolve和reject方法的一次性，实际上也就是在回调函数列表最后加上disable和lock方法</p>\n<h3 id=\"promise对象\">promise对象</h3><p>上面反复说了Promise对象，来看看Promise对象的真正面貌：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise = &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*获得当前状态的方法*/</span></span><br><span class=\"line\">    state: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">/*无论执行成功与否，都执行参数中的回调*/</span></span><br><span class=\"line\">    always: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        deferred.done( <span class=\"built_in\">arguments</span> ).fail( <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">/*顺序声明三个函数，分别在成功，失败，执行中时进行调用，返回一个promise对象*/</span></span><br><span class=\"line\">    then: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> <span class=\"comment\">/* fnDone, fnFail, fnProgress */</span> </span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*then的代码*/</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// Get a promise for this deferred</span></span><br><span class=\"line\">    <span class=\"comment\">// If obj is provided, the promise aspect is added to the object</span></span><br><span class=\"line\">    <span class=\"comment\">/*获取promise对象*/</span></span><br><span class=\"line\">    promise: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> obj </span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj != <span class=\"literal\">null</span> ? jQuery.extend( obj, promise ) : promise;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">deferred = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">/*pipe方法，实际上就是then，为了符合标准罢了*/</span></span><br><span class=\"line\">promise.pipe = promise.then;</span><br><span class=\"line\"><span class=\"comment\">/*这里为Promise添加了done、fail、progress方法*/</span></span><br><span class=\"line\"><span class=\"comment\">/*这里为Deferred添加了resolve、resolveWith、reject、rejectWith、notify、notifyWith方法*/</span></span><br><span class=\"line\">jQuery.each( tuples, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> i, tuple </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*上面的代码*/</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">/*将Promise对象的所有方法拷贝给Deferred对象*/</span></span><br><span class=\"line\">promise.promise( deferred );</span><br></pre></td></tr></table></figure>\n<p>这里可以看到，promise对象提供了几个接口：</p>\n<ol>\n<li>state：获取当前Deferred对象的状态</li>\n<li>always：欧诺更是使用done和fail，使得参数中的方法在deferred成功和失败时都执行</li>\n<li>then：使用done、fail、progress分别绑定函数，代码较多，后面再讲</li>\n<li>promise：如果对象存在，向一个对象添加promise对象中的接口，否则直接返回promise对象</li>\n<li>pipe：就是then，别名而已</li>\n<li>done，fail，progress：上面介绍过，不赘述了</li>\n</ol>\n<h4 id=\"Promise和Deferred的区别\">Promise和Deferred的区别</h4><p>这里在申明了promise对象之后，在Deferred对象中添加了promise所有的方法。另外Deferred对象拥有之前说的resolve等6个方法，Deferred对象和Promise对象的区别就很明显了：Promise实际上就是没有resolve、resolveWith、reject、rejectWith、notify、notifyWith这六个方法，其他和Deferred对象一样</p>\n<h4 id=\"then和pipe\">then和pipe</h4><p>上面略过了then方法，这里单独拉出来说一下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">then: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> <span class=\"comment\">/* fnDone, fnFail, fnProgress */</span> </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fns = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*这里新建了一个Deferred对象，并返回其Promise对象，以构成一个Deferred对象链</span><br><span class=\"line\">    由于这里返回的是Promise对象，没有resolve等方法，所以触发必须在整个Deferred对象链的头上触发</span><br><span class=\"line\">    链上的每个Deferred对象的三个回调函数列表的最后，都会有一个函数，用于触发链的下一个Deferred对象的相对应的回调函数列表</span><br><span class=\"line\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> jQuery.Deferred(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> newDefer </span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*对于上面三种，分别将函数加入到对应的回调函数列表中*/</span></span><br><span class=\"line\">        jQuery.each( tuples, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> i, tuple </span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> fn = jQuery.isFunction( fns[ i ] ) &amp;&amp; fns[ i ];</span><br><span class=\"line\">            <span class=\"comment\">/*向当前Deferred最后添加一个函数，用于触发链的下一个Deferred对象的相关回调函数列表*/</span></span><br><span class=\"line\">            deferred[ tuple[<span class=\"number\">1</span>] ](<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> returned = fn &amp;&amp; fn.apply( <span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">                <span class=\"comment\">/*如果返回值是Deferred对象，获取其Promise对象，并为其绑定相关触发操作*/</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) &#123;</span><br><span class=\"line\">                    returned.promise()</span><br><span class=\"line\">                        .done( newDefer.resolve )</span><br><span class=\"line\">                        .fail( newDefer.reject )</span><br><span class=\"line\">                        .progress( newDefer.notify );</span><br><span class=\"line\">                <span class=\"comment\">/*如果不是Deferred对象，直接在新建的deferred对象上添加相关触发操作*/</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    newDefer[ tuple[ <span class=\"number\">0</span> ] + <span class=\"string\">\"With\"</span> ]( <span class=\"keyword\">this</span> === promise ? newDefer.promise() : <span class=\"keyword\">this</span>, fn ? [ returned ] : <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        fns = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;).promise();</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>这个函数是Deferred的一个非常重要的函数，它实现了一个Deferred链。这个Deferred链的特点是，只有链的头节点是Deferred对象，后面都是Promise对象，这也意味着，只能在头节点触发resolve、reject、notify操作。触发了操作之后，对应的操作会顺着链传递下去，触发了一个节点resolve，执行完毕后，会自动触发下一个节点的resolve，reject和notify同理。</p>\n<p>这里传入的三个函数会分别在当前的Deferred相关操作被触发时执行，如果执行返回的是一个Deferred/Promise对象，获取其Promise对象，新建的Deferred对象将会被链在这个返回的Deferred对象之后。如果返回其他的值，新建的Deferred对象的resolveWith、rejectWith、notifyWith方法会被直接触发，达到链式的效果。</p>\n<h3 id=\"小结-1\">小结</h3><p>这就是jQuery的Deferred/Promise的全貌了。Promise对象实际上是Deferred对象的除去resolve等6个方法的子集。done、fail、progress分别对应一个回调函数列表，这三个方法实际上就是往对应的回调函数列表中插入函数。但then和pipe不相同，它们会新建一个Deferred对象，并构造一个Deferred对象链。这也让jQuery的Deferred/Promise显得不论不类。</p>\n<h2 id=\"when\">when</h2><p>when方法提供了将多个Deferred对象聚集的能力，在when方法中传入一些Deferred对象，返回一个Deferred对象。在参数中的所有Deferred对象都被resolve之后，会resolve这个返回的Deferred对象，如果参数中的Deferred有一个被reject了，那么这个返回的Deferred也会被reject。另外，在参数中的Deferred对象resolve时，返沪ideDeferred也会被notify。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">when: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> subordinate <span class=\"comment\">/* , ..., subordinateN */</span> </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">/*切分参数到数组*/</span></span><br><span class=\"line\">        resolveValues = slice.call( <span class=\"built_in\">arguments</span> ),</span><br><span class=\"line\">        <span class=\"comment\">/*数组长度*/</span></span><br><span class=\"line\">        length = resolveValues.length,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 未完成的需要监听的Deferred对象的个数 */</span></span><br><span class=\"line\">        remaining = length !== <span class=\"number\">1</span> || ( subordinate &amp;&amp; jQuery.isFunction( subordinate.promise ) ) ? length : <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">/*新建一个Deferred对象用于管理所有的Deferred对象结果，*不妨就叫管理Deferred吧，如果参数只有一个Deferred，就不需要新建了，直接用它就行了/</span><br><span class=\"line\">        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span><br><span class=\"line\">        使用一个计数器来计算的，计数器就是remaining，初始为需要执行的Deferred对象的个数，每有一个Deferred被resolve，就减一，减到0时，所有的Deferred都被resolve了，就触发新建的Deferred的resolve。</span><br><span class=\"line\"></span><br><span class=\"line\">        如果有Deferred被resolve，但remaining没有到0，就触发管理Deferred的notify</span><br><span class=\"line\">        */</span></span><br><span class=\"line\">        updateFunc = function( i, contexts, values ) &#123;</span><br><span class=\"line\">            return function( value ) &#123;</span><br><span class=\"line\">                contexts[ i ] = this;</span><br><span class=\"line\">                values[ i ] = arguments.length &gt; 1 ? slice.call( arguments ) : value;</span><br><span class=\"line\">                if ( values === progressValues ) &#123;</span><br><span class=\"line\">                    deferred.notifyWith( contexts, values );</span><br><span class=\"line\">                &#125; else if ( !( --remaining ) ) &#123;</span><br><span class=\"line\">                    deferred.resolveWith( contexts, values );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        progressValues, progressContexts, resolveContexts;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*为每个Deferred对象增加我们的更新函数，如果有reject，那么也触发管理Deferred的reject*/</span></span><br><span class=\"line\">    if ( length &gt; 1 ) &#123;</span><br><span class=\"line\">        progressValues = new Array( length );</span><br><span class=\"line\">        progressContexts = new Array( length );</span><br><span class=\"line\">        resolveContexts = new Array( length );</span><br><span class=\"line\">        for ( ; i &lt; length; i++ ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*这里只处理Deferred/Promise，其他不考虑*/</span></span><br><span class=\"line\">            if ( resolveValues[ i ] &amp;&amp; jQuery.isFunction( resolveValues[ i ].promise ) ) &#123;</span><br><span class=\"line\">                resolveValues[ i ].promise()</span><br><span class=\"line\">                    .done( updateFunc( i, resolveContexts, resolveValues ) )</span><br><span class=\"line\">                    .fail( deferred.reject )</span><br><span class=\"line\">                    .progress( updateFunc( i, progressContexts, progressValues ) );</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                --remaining;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*如果传入的参数都没有Deferred，直接resolve管理Deferred就好*/</span></span><br><span class=\"line\">    if ( !remaining ) &#123;</span><br><span class=\"line\">        deferred.resolveWith( resolveContexts, resolveValues );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*将这个管理Deferred对象返回*/</span></span><br><span class=\"line\">    return deferred.promise();</span><br><span class=\"line\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>从上面可以看到主要的实现思路就是，新建一个管理Deferred对象，它期望在参数中所有的Deferred被resolve后，执行自己的resolve操作。内部使用了一个计数器remaining，用于表明还有多少个Deferred尚未resolve。当这个计数器变成0时，所有的Deferred都被resolve了，那么这个管理Deferred也可以被resolve了。</p>\n<p>为了维护这个计数器，在每个Deferred的done回调函数列表最后，绑定一个updateFunc函数，这个函数内部会修改remaining，以及判断是应该执行管理Deferred对象的resolve还是notify</p>\n<p>而由于任何一个Deferred被reject的话，管理Deferred都会被reject，所以直接在每一个Deferred的fail回调函数列表上添加管理Deferred的reject方法就行了</p>\n<p>另外需要注意一下参数中只有一个或没有Deferred的情况，前者可以省去创建管理Deferred对象，直接使用参数中的Deferred对象作为管理对象就行了。后者则可以直接执行resolve方法</p>\n<h2 id=\"总结\">总结</h2><p>jQuery中使用Deferred/Promise对象进行异步管理，其内部维护了三个Callbacks回调函数列表，这与常规的Promise的链式实现并不一致。在稍早的版本中，then方法其实也是和done、fail、progress一样往回调函数列表里添加方法，并不会形成Deferred链，后来Resig估计也发现了自己理解错了标准，于是乎通过pipe和then生成Deferred链，但这种Callbacks和Deferred链同时存在的方式，显得不伦不类，不过普通的需求基本上都能满足。jQuery的ready、ajax等都是使用Deferred/Promise来进行异步控制的</p>\n"}