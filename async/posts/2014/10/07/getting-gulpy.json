{"tags":[{"name":"Gulp","permalink":"http://lingyu.wang/tags/Gulp/","url":"/async/tags/Gulp.json","count":2},{"name":"JavaScript","permalink":"http://lingyu.wang/tags/JavaScript/","url":"/async/tags/JavaScript.json","count":39},{"name":"NodeJs","permalink":"http://lingyu.wang/tags/NodeJs/","url":"/async/tags/NodeJs.json","count":14}],"categories":[{"name":"翻译","permalink":"http://lingyu.wang/categories/翻译/","url":"/async/categories/翻译.json","count":11}],"url":"/async/posts/2014/10/07/getting-gulpy.json","date":1412611200000,"path":{"year":2014,"month":10,"day":7,"name":"getting-gulpy"},"subtitle":"Getting gulpy -- Advanced tips for using gulp.js","title":"Gulp思维 —— Gulp高级技巧","permalink":"http://lingyu.wang/2014/10/07/getting-gulpy/","content":"<p><strong>本文翻译自<a href=\"https://medium.com/@webprolific/getting-gulpy-a2010c13d3d5\" target=\"_blank\" rel=\"external\">Getting gulpy — Advanced tips for using gulp.js</a></strong></p>\n<p>感受过<a href=\"http://gulpjs.com/\" target=\"_blank\" rel=\"external\">gulp.js</a>带来的兴奋过后，你需要的不仅仅是它的光鲜，而是切切实实的实例。这篇文章讨论了一些使用gulp.js时常踩的坑，以及一些更加高级和定制化的插件和流的使用技巧。</p>\n<a id=\"more\"></a>\n<h2 id=\"基本任务\">基本任务</h2><p>gulp的基本设置拥有非常友好的语法，让你能够非常方便的对文件进行转换：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'scripts'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'./src/**/*.js'</span>)</span><br><span class=\"line\">        .pipe(uglify())</span><br><span class=\"line\">        .pipe(concat(<span class=\"string\">'all.min.js'</span>))</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'build/'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这种方式能够应付绝大多数情况，但如果你需要更多的定制，很快就会遇到麻烦了。这篇将介绍这其中的一些情况并提供解决方案。</p>\n<h2 id=\"流不兼容？\">流不兼容？</h2><p>使用gulp时，你可能会陷入“流不兼容”的问题。这主要是因为常规流和Vinyl文件对象有差异，或是使用了仅支持buffer（不支持流）库的gulp插件与常规流不兼容。</p>\n<p>比如说，你不能直接将常规流与gulp和（或）gulp插件相连。我们创建一个可读流，并尝试使用<a href=\"https://www.npmjs.org/package/gulp-uglify\" target=\"_blank\" rel=\"external\">gulp-uglify</a>和<a href=\"https://www.npmjs.org/package/gulp-rename\" target=\"_blank\" rel=\"external\">gulp-rename</a>来进行转换，将最后得到的内容交给<code>gulp.dest()</code>。下面就是个错误的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> uglify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-uglify'</span>),</span><br><span class=\"line\">    rename = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-rename'</span>);</span><br><span class=\"line\">gulp.task(<span class=\"string\">'bundle'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs.createReadStream(<span class=\"string\">'app.js'</span>)</span><br><span class=\"line\">        .pipe(uglify())</span><br><span class=\"line\">        .pipe(rename(<span class=\"string\">'bundle.min.js'</span>))</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'dist/'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>为什么我们不能将可读流和一个gulp插件直接相连？gulp难道不就是一个基于流的构建系统吗？是的，但上面的例子忽视了一个事实，gulp插件期望的输入是Vinyl文件对象。你不能直接将一个可读流与一个以Vinyl文件对象作为输入的函数（插件）相连</p>\n<h2 id=\"Vinyl文件对象\">Vinyl文件对象</h2><p>gulp使用了<a href=\"https://github.com/wearefractal/vinyl-fs\" target=\"_blank\" rel=\"external\">vinyl-fs</a>，它实现了<code>gulp.src()</code>和<code>gulp.dest()</code>方法。vinyl-fs使用<a href=\"https://github.com/wearefractal/vinyl\" target=\"_blank\" rel=\"external\">vinyl</a>文件对象——一种“虚拟文件格式”。如果我们需要将gulp和（或）gulp插件与常规的可读流一起使用，我们就需要先把可读流转换为vinyl。</p>\n<p>使用<a href=\"https://www.npmjs.org/package/vinyl-source-stream\" target=\"_blank\" rel=\"external\">vinyl-source-stream</a>是个不错的选择，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> source = <span class=\"built_in\">require</span>(<span class=\"string\">'vinyl-source-stream'</span>),</span><br><span class=\"line\">    marked = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-marked'</span>);</span><br><span class=\"line\">fs.createReadStream(<span class=\"string\">'*.md'</span>)</span><br><span class=\"line\">    .pipe(source())</span><br><span class=\"line\">    .pipe(marked())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'dist/'</span>));</span><br></pre></td></tr></table></figure>\n<p>另外一个例子首先通过<a href=\"http://browserify.org/\" target=\"_blank\" rel=\"external\">browserify</a>封装并最终将其转换为一个vinyl流：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> browserify = <span class=\"built_in\">require</span>(<span class=\"string\">'browserify'</span>),</span><br><span class=\"line\">    uglify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-uglify'</span>),</span><br><span class=\"line\">    source = <span class=\"built_in\">require</span>(<span class=\"string\">'vinyl-source-stream'</span>);</span><br><span class=\"line\">gulp.task(<span class=\"string\">'bundle'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> browserify(<span class=\"string\">'./src/app.js'</span>)</span><br><span class=\"line\">        .bundle()</span><br><span class=\"line\">        .pipe(source(‘bundle.min.js))</span><br><span class=\"line\">        .pipe(uglify())</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'dist/'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>哎呦不错哦。注意我们不再需要使用gulp-rename了，因为vinyl-source-stream创建了一个拥有指定文件名的vinyl文件实例（这样gulp.dest方法将使用这个文件名）</p>\n<h3 id=\"gulp-dest\">gulp.dest</h3><p>这个gulp方法创建了一个可写流，它真的很方便。它重新使用可读流中的文件名，然后在必要时创建文件夹（使用<a href=\"https://www.npmjs.org/package/mkdirp\" target=\"_blank\" rel=\"external\">mkdirp</a>）。在写入操作完成后，你能够继续使用这个流（比如：你需要使用gzip压缩数据并写入到其他文件）</p>\n<h2 id=\"流和buffer\">流和buffer</h2><p>既然你有兴趣使用gulp，这篇文章假设你已经了解了流的基础知识。无论是buffer还是流，vinyl的虚拟文件都能包含在内。使用常规可读流时，你可以监听data事件来检测数据碎片的到来：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.createReadStream(<span class=\"string\">'/usr/share/dict/words'</span>).on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chunk</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Read %d bytes of data'</span>, chunk.length);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&gt; Read <span class=\"number\">65536</span> bytes <span class=\"keyword\">of</span> data</span><br><span class=\"line\">&gt; Read <span class=\"number\">65536</span> bytes <span class=\"keyword\">of</span> data</span><br><span class=\"line\">&gt; Read <span class=\"number\">65536</span> bytes <span class=\"keyword\">of</span> data</span><br><span class=\"line\">&gt; Read <span class=\"number\">65536</span> bytes <span class=\"keyword\">of</span> data</span><br><span class=\"line\">&gt; ...</span><br></pre></td></tr></table></figure>\n<p>不同的是，使用<code>gulp.src()</code>会将转换成buffer的vinyl文件对象重新写入到流中。也就是说，你获得的不再是数据碎片，而是将内容转换成buffer后的（虚拟）文件。vinyl文件格式拥有一个属性来表示里面是buffer还是流，gulp默认使用buffer：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.src(<span class=\"string\">'/usr/share/dict/words'</span>).on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Read %d bytes of data'</span>, file.contents.length);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&gt; Read <span class=\"number\">2493109</span> bytes <span class=\"keyword\">of</span> data</span><br></pre></td></tr></table></figure>\n<p>这个例子说明了在文件被完整加入到流之前数据会被转换成buffer。</p>\n<h2 id=\"Gulp默认使用buffer\">Gulp默认使用buffer</h2><p>尽管更加推荐使用流中的数据，但很多插件的底层库使用的是buffer。有时候必须使用buffer，因为转换需要完整的文件内容。比如文本替换和正则表达式的情形。如果使用数据碎片，将会面临匹配失败的风险。同样，像<a href=\"http://lisperator.net/uglifyjs/\" target=\"_blank\" rel=\"external\">UglifyJS</a>和<a href=\"https://github.com/google/traceur-compiler\" target=\"_blank\" rel=\"external\">Traceur Compiler</a>需要输入完整的文件内容（至少需要语法完整的JavaScript字符串）</p>\n<p>这就是为什么gulp默认使用转换成buffer的流，因为这更好处理。</p>\n<p>使用转换成buffer的流也有缺点，处理大文件时将非常低效。文件必须完全读取，然后才能被加入到流中。那么问题来了，文件的尺寸多大才会降低性能？对于普通的文本文件，比如JavaScript、CSS、模板等等，这些使用buffer开销非常小。</p>\n<p>在任何情况下，如果将buffer选项设为false，你可以告诉gulp流中传递的内容究竟是什么。如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.src(<span class=\"string\">'/usr/share/dict/words'</span>, &#123;buffer: <span class=\"literal\">false</span>&#125;).on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stream = file.contents;</span><br><span class=\"line\">    stream.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chunk</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Read %d bytes of data'</span>, chunk.length);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&gt; Read <span class=\"number\">65536</span> bytes <span class=\"keyword\">of</span> data</span><br><span class=\"line\">&gt; Read <span class=\"number\">65536</span> bytes <span class=\"keyword\">of</span> data</span><br><span class=\"line\">&gt; Read <span class=\"number\">65536</span> bytes <span class=\"keyword\">of</span> data</span><br><span class=\"line\">&gt; Read <span class=\"number\">65536</span> bytes <span class=\"keyword\">of</span> data</span><br><span class=\"line\">&gt; ...</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"从流到buffer\">从流到buffer</h2><p>由于所需的输入（输出）流和gulp插件不尽相同，你可能需要将流转换成buffer（反之亦然）。之前已经有过介绍，大多数插件使用buffer（尽管他们的一部分也支持流）。比如<a href=\"https://www.npmjs.org/package/gulp-uglify\" target=\"_blank\" rel=\"external\">gulp-uglify</a>和<a href=\"https://www.npmjs.org/package/gulp-traceur\" target=\"_blank\" rel=\"external\">gulp-traceur</a>。你可以通过<a href=\"https://www.npmjs.org/package/gulp-buffer\" target=\"_blank\" rel=\"external\">gulp-buffer</a>来转换成buffer：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> source = <span class=\"built_in\">require</span>(<span class=\"string\">'vinyl-source-stream'</span>),</span><br><span class=\"line\">    buffer = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-buffer'</span>),</span><br><span class=\"line\">    uglify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-uglify'</span>);</span><br><span class=\"line\">fs.createReadStream(<span class=\"string\">'./src/app.js'</span>)</span><br><span class=\"line\">    .pipe(source(<span class=\"string\">'app.min.js'</span>))</span><br><span class=\"line\">    .pipe(buffer())</span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'dist/'</span>));</span><br></pre></td></tr></table></figure>\n<p>或者另一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-buffer'</span>),</span><br><span class=\"line\">    traceur = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-traceur'</span>);</span><br><span class=\"line\">gulp.src(<span class=\"string\">'app.js'</span>, &#123;buffer: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\">    .pipe(buffer())</span><br><span class=\"line\">    .pipe(traceur())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'dist/'</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"将buffer转换为流\">将buffer转换为流</h2><p>你也可以使用<a href=\"https://www.npmjs.org/package/gulp-streamify\" target=\"_blank\" rel=\"external\">gulp-streamify</a>或<a href=\"https://www.npmjs.org/package/gulp-stream\" target=\"_blank\" rel=\"external\">gulp-stream</a>将一个使用buffer的插件的输出转化为一个可读流。这样处理之后，跟在使用buffer的插件后面的（只能）使用流的插件也能正常工作了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wrap = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-wrap'</span>),</span><br><span class=\"line\">    streamify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-streamify'</span>),</span><br><span class=\"line\">    uglify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-uglify'</span>),</span><br><span class=\"line\">    gzip = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-gzip'</span>);</span><br><span class=\"line\">gulp.src(<span class=\"string\">'app.js'</span>, &#123;buffer: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\">    .pipe(wrap(<span class=\"string\">'(function()&#123;&lt;%= contents %&gt;&#125;());'</span>))</span><br><span class=\"line\">    .pipe(streamify(uglify()))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'build'</span>))</span><br><span class=\"line\">    .pipe(gzip())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'build'</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"不是所有事都需要插件\">不是所有事都需要插件</h2><p>虽然已经有很多使用且方便的插件，很多任务以及转换可以不使用插件而轻易完成。插件会带来一些问题，你需要依赖一个额外的npm模块，一个插件接口和（反应迟钝？）的维护者，等等。如果一个任务可以不使用插件而使用原生模块就能轻易完成，绝大多数情况下，都建议不要使用插件。能够理解上面所说的概念，并能够在所处的情况下做出正确的决定，这点非常重要。下面来看一些例子：</p>\n<h3 id=\"vinyl-source-stream\">vinyl-source-stream</h3><p>之前的例子中，我们已经直接使用了browserify，而不是使用（现已加入黑名单）<a href=\"https://www.npmjs.org/package/gulp-browserify\" target=\"_blank\" rel=\"external\">gulp-browserify</a>插件。这里的关键是使用vinyl-source-stream（或类似的库）进行加工，来将常规的可读流输入使用vinyl的插件。</p>\n<h3 id=\"文本转换\">文本转换</h3><p>另一个例子就是基于字符串的变换。这里有一个非常基础的插件，直接使用了vinyl的buffer：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">modify</span>(<span class=\"params\">modifier</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> through2.obj(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file, encoding, done</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> content = modifier(<span class=\"built_in\">String</span>(file.contents));</span><br><span class=\"line\">        file.contents = <span class=\"keyword\">new</span> Buffer(content);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.push(file);</span><br><span class=\"line\">        done();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你可以像这样使用这个插件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'modify'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'app.js'</span>)</span><br><span class=\"line\">        .pipe(modify(version))</span><br><span class=\"line\">        .pipe(modify(swapStuff))</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'build'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">version</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.replace(<span class=\"regexp\">/__VERSION__/</span>, pkg.version);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swapStuff</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.replace(<span class=\"regexp\">/(\\w+)\\s(\\w+)/</span>, <span class=\"string\">'$2, $1'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个插件并没有完成，而且也不能处理流（<a href=\"https://gist.github.com/webpro/a9a9e14d291c021894b3\" target=\"_blank\" rel=\"external\">完整版本</a>）。然而，这个例子说明，可以很轻易地通过一些基本函数来创建新的变换。<a href=\"https://www.npmjs.org/package/through2\" target=\"_blank\" rel=\"external\">through2</a>库提供了非常优秀的Node流封装，并且允许像上面那样使用转换函数。</p>\n<h2 id=\"任务流程\">任务流程</h2><p>如果你需要去运行一些定制化或动态的任务，了解gulp所使用的<a href=\"https://www.npmjs.org/package/orchestrator\" target=\"_blank\" rel=\"external\">Orchestrator</a>模块会很有帮助。<code>gulp.add</code>方法其实就是<code>Orchestrator.add</code>方法（事实上所有的方法都是从Orchestrator继承而来的）。但为什么你需要这个？</p>\n<ul>\n<li>你不想“私有任务”（比如：不暴露给命令行工具）弄乱gulp任务列表。</li>\n<li>你需要更多的动态的和（或）可重用的子任务。</li>\n</ul>\n<h2 id=\"最后的思考\">最后的思考</h2><p>请注意，gulp（或grunt）并不总是当前情境下的最佳工具。比如说，如果你需要拼接并使用uglify压缩一系列的JavaScript文件，又或者你需要编译一些SASS文件，你可能需要考虑使用makefile或npm run，通过命令行来实现。减少依赖，减少配置，才是正解。</p>\n<p>阅读<a href=\"http://substack.net/task_automation_with_npm_run\" target=\"_blank\" rel=\"external\">通过npm run来实现任务自动化</a>来了解更多信息。你需要明确通过一系列的“自定义构建”后需要得到什么，而哪个工具最合适。</p>\n<p>不过，我觉得gulp是一个伟大的构建系统，我很喜欢使用它，它展现了Node.js中流的强大。</p>\n<p>希望这些能够帮到你！如果你有任何反馈或其他提议，请在评论中告诉我，或者加我的twitter：<a href=\"https://twitter.com/webprolific\" target=\"_blank\" rel=\"external\">@webprolific</a></p>\n"}