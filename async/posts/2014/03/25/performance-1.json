{"tags":[{"name":"CSS","permalink":"http://lingyu.wang/tags/CSS/","url":"/async/tags/CSS.json","count":35},{"name":"HTML","permalink":"http://lingyu.wang/tags/HTML/","url":"/async/tags/HTML.json","count":29},{"name":"JavaScript","permalink":"http://lingyu.wang/tags/JavaScript/","url":"/async/tags/JavaScript.json","count":39}],"categories":[{"name":"性能优化","permalink":"http://lingyu.wang/categories/性能优化/","url":"/async/categories/性能优化.json","count":5}],"url":"/async/posts/2014/03/25/performance-1.json","date":1395676800000,"path":{"year":2014,"month":3,"day":25,"name":"performance-1"},"subtitle":"前端性能优化系列","title":"前端性能优化（DOM操作篇）","permalink":"http://lingyu.wang/2014/03/25/performance-1/","content":"<p>最近准备笔试面试题的时候看到很多关于前端性能优化的问题，所以提前调研做做准备，加上我之前写的两篇博客，组成一个新系列</p>\n<a id=\"more\"></a>\n<h2 id=\"缓存DOM对象\">缓存DOM对象</h2><p>JavaScript的DOM操作可以说是JavaScript最重要的功能，我们经常要根据用户的操作来动态的增加和删除元素，或是通过AJAX返回的数据动态生成元素。比如我们获得了一个很多元素的数组<code>data[]</code>，需要将其每个值生成一个li元素插入到一个id为container的ul元素中，最简单（最慢）的方式是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> liNode, i, m;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, m = data.length; i &lt; m; i++) &#123;</span><br><span class=\"line\">    liNode = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">    liNode.innerText = data[i];</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"container\"</span>).appendChild(liNode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里每一次循环都会去查找id为container的元素，效率自然非常低，所以我们需要将元素在循环前查询完毕，在循环中仅仅是引用就行了，修改代码为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ulNode = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"container\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> liNode, i, m;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, m = data.length; i &lt; m; i++) &#123;</span><br><span class=\"line\">    liNode = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">    liNode.innerText = data[i];</span><br><span class=\"line\">    ulNode.appendChild(liNode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缓存DOM对象的方式也经常被用在元素的查找中，查找元素应该是DOM操作中最频繁的操作了，其效率优化也是大头。在一般情况下，我们会根据需要，将一些频繁被查找的元素缓存起来，在查找它或查找它的子孙元素时，以它为起点进行查找，就能提高查找效率了。</p>\n<h2 id=\"在内存中操作元素\">在内存中操作元素</h2><p>由于DOM操作会导致浏览器的回流，回流需要花费大量的时间进行样式计算和节点重绘与渲染，所以应当尽量减少回流次数。一种可靠的方法就是加入元素时不要修改页面上已经存在的元素，而是在内存中的节点进行大量的操作，最后再一并将修改运用到页面上。DOM操作本身提供一个创建内存节点片段的功能:<code>document.createDocumentFragment()</code>，我们可以将其运用于上述代码中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ulNode = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"container\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> liNode, i, m;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, m = data.length; i &lt; m; i++) &#123;</span><br><span class=\"line\">    liNode = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">    liNode.innerText = data[i];</span><br><span class=\"line\">    fragment.appendChild(liNode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ulNode.appendChild(fragment);</span><br></pre></td></tr></table></figure></p>\n<p>这样就只会触发一次回流，效率会得到很大的提升。如果需要对一个元素进行复杂的操作（删减、添加子节点），那么我们应当先将元素从页面中移除，然后再对其进行操作，或者将其复制一个（<code>cloneNode()</code>），在内存中进行操作后再替换原来的节点</p>\n<h2 id=\"一次性DOM节点生成\">一次性DOM节点生成</h2><p>在这里我们每次都需要生成节点（<code>document.createElement(&quot;li&quot;)</code>），然后将其加入到内存片段中，我们可以通过<code>innerHTML</code>属性来一次性生成节点，具体的思路就是使用字符串拼接的方式，先生成相应的HTML字符串，最后一次性写入到ul的innerHTML中。修改代码为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ulNode = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"container\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fragmentHtml = <span class=\"string\">\"\"</span>, i, m;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, m = data.length; i &lt; m; i++) &#123;</span><br><span class=\"line\">    fragmentHtml += <span class=\"string\">\"&lt;li&gt;\"</span> + data[i] + <span class=\"string\">\"&lt;/li&gt;\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ulNode.innerHTML = fragmentHtml;</span><br></pre></td></tr></table></figure></p>\n<p>这样效率也会有提升，不过手动拼写字符串是相当麻烦的一件事</p>\n<h2 id=\"通过类修改样式\">通过类修改样式</h2><p>有时候我们需要通过JavaScript给元素增加样式，比如如下代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.style.fontWeight = <span class=\"string\">'bold'</span>;</span><br><span class=\"line\">element.style.backgroundImage = <span class=\"string\">'url(back.gif)'</span>;</span><br><span class=\"line\">element.style.backgroundColor = <span class=\"string\">'white'</span>;</span><br><span class=\"line\">element.style.color = <span class=\"string\">'white'</span>;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure></p>\n<p>这样效率很低，每次修改style属性后都会触发元素的重绘，如果修改了的属性涉及大小和位置，将会导致回流。所以我们应当尽量避免多次为一个元素设置style属性，应当通过给其添加新的CSS类，来修改其CSS<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\">.element</span> <span class=\"rules\">&#123;</span><br><span class=\"line\">    <span class=\"rule\"><span class=\"attribute\">background-image</span>:<span class=\"value\"> <span class=\"function\">url</span>(back.gif)</span></span>;</span><br><span class=\"line\">    <span class=\"rule\"><span class=\"attribute\">background-color</span>:<span class=\"value\"> <span class=\"hexcolor\">#fff</span></span></span>;</span><br><span class=\"line\">    <span class=\"rule\"><span class=\"attribute\">color</span>:<span class=\"value\"> <span class=\"hexcolor\">#fff</span></span></span>;</span><br><span class=\"line\">    <span class=\"rule\"><span class=\"attribute\">font-weight</span>:<span class=\"value\"> <span class=\"string\">'bold'</span></span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.className += <span class=\"string\">\" element\"</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过事件代理批量操作事件\">通过事件代理批量操作事件</h2><p>还是之前那个ul和添加li，如果我们需要给每个li都绑定一个click事件，就可能写出类似如下代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ulNode = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"container\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment();</span><br><span class=\"line\"><span class=\"keyword\">var</span> liNode, i, m;</span><br><span class=\"line\"><span class=\"keyword\">var</span> liFnCb = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, m = data.length; i &lt; m; i++) &#123;</span><br><span class=\"line\">    liNode = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">    liNode.innerText = data[i];</span><br><span class=\"line\">    liNode.addEventListener(<span class=\"string\">\"click\"</span>, liFnCb, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    fragment.appendChild(liNode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ulNode.appendChild(fragment);</span><br></pre></td></tr></table></figure></p>\n<p>这里每个li元素都需要执行一次<code>addEventListener()</code>方法，如果li元素数量一多，就会降低效率。所以我们可以通过事件代理的方式，将事件绑定在ul上，然后通过<code>event.target</code>来确定被点击的元素是否是li元素，同时我们也可以使用<code>innerHTML</code>属性一次性创建节点了，修改代码为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ulNode = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"container\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fragmentHtml = <span class=\"string\">\"\"</span>, i, m;</span><br><span class=\"line\"><span class=\"keyword\">var</span> liFnCb = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, m = data.length; i &lt; m; i++) &#123;</span><br><span class=\"line\">    fragmentHtml += <span class=\"string\">\"&lt;li&gt;\"</span> + data[i] + <span class=\"string\">\"&lt;/li&gt;\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ulNode.innerHTML = fragmentHtml;</span><br><span class=\"line\">ulNode.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(evt.target.tagName.toLowerCase() === <span class=\"string\">'li'</span>) &#123;</span><br><span class=\"line\">        liFnCb.call(evt.target, evt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这样事件绑定的代码就只要执行一次，可以监听所有li元素的事件了。当然如果需要移除事件回调函数，我们也不需要循环遍历所有的li元素，只需要移除ul元素上的事件处理就行了</p>\n"}